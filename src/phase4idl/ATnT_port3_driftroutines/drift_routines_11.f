      REAL FUNCTION  SMNSX(FUNCT, P, STEP, TOL, X)                      
C                                                                       
C *** NELDER-MEAD SIMPLEX METHOD (PATTERN SEARCH) FOR UNCONSTRAINED     
C *** MINIMIZATION, EASY-TO-USE VERSION.                                
C                                                                       
      INTEGER P                                                         
      REAL STEP, TOL, X(P)                                              
      REAL FUNCT                                                        
      EXTERNAL FUNCT                                                    
C                                                                       
C *** PARAMETERS ***                                                    
C                                                                       
C FUNC (INPUT)   EXTERNAL FUNCTION TO COMPUTE F(X)                      
C P    (INPUT)   PROBLEM DIMENSION                                      
C STEP (IN/OUT)  ON INPUT, THE SIZE OF THE INITIAL STEPS (FROM WHICH    
C                THE INITIAL SIMPLEX IS CONSTRUCTED.  ON OUTPUT,        
C                THE MAXIMUM WIDTH OF THE FINAL SIMPLEX IN ANY          
C                COORDINATE DIRECTION.                                  
C TOL  (IN/OUT)  ON INPUT, THE CONVERGENCE TOLERANCE (ON THE STANDARD   
C                DEVIATION OF THE FUNCTION VALUES AT THE SIMPLEX        
C                VERTICES).  ON OUTPUT, TOL IS SET TO THIS STANDARD     
C                DEVIATION.                                             
C X    (OUTPUT)  THE BEST X VALUE FOUND, CORRESPONDING TO THE RETURN    
C                VALUE FROM SMNSX                                       
C                                                                       
C                                                                       
      REAL RSTAK(1000)                                                  
      COMMON /CSTAK/ RSTAK                                              
C                                                                       
      INTEGER ISTKGT                                                    
      REAL  M7NSX                                                       
      EXTERNAL ISTKGT, ISTKRL,  M7NSX                                   
C                                                                       
C *** LOCAL VARIABLES ***                                               
C                                                                       
      INTEGER DX1, I, IRC, ITMX, J, P1, S1, SIJ, XE1, XR1, Y1           
      REAL A, B, T, ZERO                                                
      DATA ZERO/0.E+0/                                                  
C                                                                       
C *** BODY ***                                                          
C                                                                       
      IF (P .LE. 0) GO TO 40                                            
      IF (STEP .LE. ZERO) GO TO 50                                      
      IF (TOL .LE. ZERO) GO TO 50                                       
      DX1 = ISTKGT(P*(P+5)+1, 3)                                        
      XE1 = DX1 + P                                                     
      XR1 = XE1 + P                                                     
      Y1 = XR1 + P                                                      
      P1 = P + 1                                                        
      S1 = Y1 + P1                                                      
      ITMX = 1000                                                       
C                                                                       
C *** INITIALIZE S ***                                                  
C                                                                       
      A = -STEP / FLOAT(P1)                                             
      B = STEP + A                                                      
      SIJ = S1                                                          
      DO 20 I = 1, P1                                                   
         DO 10 J = 1, P                                                 
            T = X(J) + A                                                
            IF (I .EQ. J) T = X(J) + B                                  
            RSTAK(SIJ) = T                                              
            SIJ = SIJ + 1                                               
 10         CONTINUE                                                    
 20      CONTINUE                                                       
C                                                                       
       SMNSX =  M7NSX(RSTAK(DX1), FUNCT, IRC, ITMX, P, P1, P, RSTAK(S1),
     1               TOL, X, RSTAK(XE1), RSTAK(XR1), RSTAK(Y1))         
      GO TO (70, 30, 40, 60), IRC                                       
C/6S                                                                    
C30   CALL SETERR(43H SMNSX -- NO CONVERGENCE IN 1000 ITERATIONS, 43,   
C    1            1, 1)                                                 
C/7S                                                                    
 30   CALL SETERR(' SMNSX -- NO CONVERGENCE IN 1000 ITERATIONS', 43,    
     1            1, 1)                                                 
C/                                                                      
      GO TO 70                                                          
C/6S                                                                    
C40   CALL SETERR(39H SMNSX -- NONPOSITIVE PROBLEM DIMENSION, 39, 2, 2) 
C50   CALL SETERR(39H SMNSX CALLED WITH STEP OR TOL .LE. 0.0, 39, 4, 2) 
C60   CALL SETERR(                                                      
C    1  60H SMNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES,
C    2            59, 3, 1)                                             
C/7S                                                                    
 40   CALL SETERR(' SMNSX -- NONPOSITIVE PROBLEM DIMENSION', 39, 2, 2)  
 50   CALL SETERR(' SMNSX CALLED WITH STEP OR TOL .LE. 0.0', 39, 4, 2)  
 60   CALL SETERR(                                                      
     1  ' SMNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES', 
     2            59, 3, 1)                                             
C/                                                                      
C                                                                       
C *** SET STEP TO THE MAX. SIMPLEX WIDTH IN ANY COORDINATE DIRECTION... 
C                                                                       
 70   STEP = ZERO                                                       
      DO 90 I = 1, P                                                    
         A = RSTAK(S1)                                                  
         B = A                                                          
         SIJ = S1                                                       
         S1 = S1 + 1                                                    
         DO 80 J = 2, P1                                                
            SIJ = SIJ + P                                               
            T = RSTAK(SIJ)                                              
            IF (A .GT. T) A = T                                         
            IF (B .LT. T) B = T                                         
 80         CONTINUE                                                    
         STEP = AMAX1(STEP, B-A)                                        
 90      CONTINUE                                                       
C                                                                       
      CALL ISTKRL(1)                                                    
 999  RETURN                                                            
C *** LAST LINE OF  SMNSX FOLLOWS ***                                   
      END                                                               
      DOUBLE PRECISION FUNCTION DSMNSX(FUNCT, P, STEP, TOL, X)          
C                                                                       
C *** NELDER-MEAD SIMPLEX METHOD (PATTERN SEARCH) FOR UNCONSTRAINED     
C *** MINIMIZATION, EASY-TO-USE VERSION.                                
C                                                                       
      INTEGER P                                                         
      DOUBLE PRECISION STEP, TOL, X(P)                                  
      DOUBLE PRECISION FUNCT                                            
      EXTERNAL FUNCT                                                    
C                                                                       
C *** PARAMETERS ***                                                    
C                                                                       
C FUNC (INPUT)   EXTERNAL FUNCTION TO COMPUTE F(X)                      
C P    (INPUT)   PROBLEM DIMENSION                                      
C STEP (IN/OUT)  ON INPUT, THE SIZE OF THE INITIAL STEPS (FROM WHICH    
C                THE INITIAL SIMPLEX IS CONSTRUCTED.  ON OUTPUT,        
C                THE MAXIMUM WIDTH OF THE FINAL SIMPLEX IN ANY          
C                COORDINATE DIRECTION.                                  
C TOL  (IN/OUT)  ON INPUT, THE CONVERGENCE TOLERANCE (ON THE STANDARD   
C                DEVIATION OF THE FUNCTION VALUES AT THE SIMPLEX        
C                VERTICES).  ON OUTPUT, TOL IS SET TO THIS STANDARD     
C                DEVIATION.                                             
C X    (OUTPUT)  THE BEST X VALUE FOUND, CORRESPONDING TO THE RETURN    
C                VALUE FROM DSMNSX                                      
C                                                                       
C                                                                       
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
C                                                                       
      INTEGER ISTKGT                                                    
      DOUBLE PRECISION DM7NSX                                           
      EXTERNAL ISTKGT, ISTKRL, DM7NSX                                   
C                                                                       
C *** LOCAL VARIABLES ***                                               
C                                                                       
      INTEGER DX1, I, IRC, ITMX, J, P1, S1, SIJ, XE1, XR1, Y1           
      DOUBLE PRECISION A, B, T, ZERO                                    
      DATA ZERO/0.D+0/                                                  
C                                                                       
C *** BODY ***                                                          
C                                                                       
      IF (P .LE. 0) GO TO 40                                            
      IF (STEP .LE. ZERO) GO TO 50                                      
      IF (TOL .LE. ZERO) GO TO 50                                       
      DX1 = ISTKGT(P*(P+5)+1, 4)                                        
      XE1 = DX1 + P                                                     
      XR1 = XE1 + P                                                     
      Y1 = XR1 + P                                                      
      P1 = P + 1                                                        
      S1 = Y1 + P1                                                      
      ITMX = 1000                                                       
C                                                                       
C *** INITIALIZE S ***                                                  
C                                                                       
      A = -STEP / FLOAT(P1)                                             
      B = STEP + A                                                      
      SIJ = S1                                                          
      DO 20 I = 1, P1                                                   
         DO 10 J = 1, P                                                 
            T = X(J) + A                                                
            IF (I .EQ. J) T = X(J) + B                                  
            DSTAK(SIJ) = T                                              
            SIJ = SIJ + 1                                               
 10         CONTINUE                                                    
 20      CONTINUE                                                       
C                                                                       
      DSMNSX = DM7NSX(DSTAK(DX1), FUNCT, IRC, ITMX, P, P1, P, DSTAK(S1),
     1               TOL, X, DSTAK(XE1), DSTAK(XR1), DSTAK(Y1))         
      GO TO (70, 30, 40, 60), IRC                                       
C/6S                                                                    
C30   CALL SETERR(43HDSMNSX -- NO CONVERGENCE IN 1000 ITERATIONS, 43,   
C    1            1, 1)                                                 
C/7S                                                                    
 30   CALL SETERR('DSMNSX -- NO CONVERGENCE IN 1000 ITERATIONS', 43,    
     1            1, 1)                                                 
C/                                                                      
      GO TO 70                                                          
C/6S                                                                    
C40   CALL SETERR(39HDSMNSX -- NONPOSITIVE PROBLEM DIMENSION, 39, 2, 2) 
C50   CALL SETERR(39HDSMNSX CALLED WITH STEP OR TOL .LE. 0.0, 39, 4, 2) 
C60   CALL SETERR(                                                      
C    1  60HDSMNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES,
C    2            59, 3, 1)                                             
C/7S                                                                    
 40   CALL SETERR('DSMNSX -- NONPOSITIVE PROBLEM DIMENSION', 39, 2, 2)  
 50   CALL SETERR('DSMNSX CALLED WITH STEP OR TOL .LE. 0.0', 39, 4, 2)  
 60   CALL SETERR(                                                      
     1  'DSMNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES', 
     2            59, 3, 1)                                             
C/                                                                      
C                                                                       
C *** SET STEP TO THE MAX. SIMPLEX WIDTH IN ANY COORDINATE DIRECTION... 
C                                                                       
 70   STEP = ZERO                                                       
      DO 90 I = 1, P                                                    
         A = DSTAK(S1)                                                  
         B = A                                                          
         SIJ = S1                                                       
         S1 = S1 + 1                                                    
         DO 80 J = 2, P1                                                
            SIJ = SIJ + P                                               
            T = DSTAK(SIJ)                                              
            IF (A .GT. T) A = T                                         
            IF (B .LT. T) B = T                                         
 80         CONTINUE                                                    
         STEP = DMAX1(STEP, B-A)                                        
 90      CONTINUE                                                       
C                                                                       
      CALL ISTKRL(1)                                                    
 999  RETURN                                                            
C *** LAST LINE OF DSMNSX FOLLOWS ***                                   
      END                                                               
      REAL FUNCTION  MNSX(FUNC, ITMX, P, PP, S, TOL, X)                 
C                                                                       
C *** NELDER-MEAD SIMPLEX METHOD (PATTERN SEARCH) FOR UNCONSTRAINED     
C *** MINIMIZATION.                                                     
C                                                                       
      INTEGER ITMX, P, PP                                               
      REAL S(PP,1), TOL, X(P)                                           
      REAL FUNC                                                         
      EXTERNAL FUNC                                                     
C                                                                       
C *** PARAMETERS ***                                                    
C                                                                       
C FUNC (INPUT)   EXTERNAL FUNCTION TO COMPUTE F(X)                      
C ITMX (INPUT)   MAX. NO. OF ITERATIONS ALLOWED                         
C P    (INPUT)   PROBLEM DIMENSION                                      
C PP   (INPUT)   LEAD DIMENSION OF S, WHICH MUST BE AT LEAST P          
C S    (IN/OUT)  ON INPUT, THE INITIAL SIMPLEX.  ON OUTPUT, THE FINAL   
C                SIMPLEX                                                
C TOL  (IN/OUT)  ON INPUT, THE CONVERGENCE TOLERANCE (ON THE STANDARD   
C                DEVIATION OF THE FUNCTION VALUES AT THE SIMPLEX        
C                VERTICES).  ON OUTPUT, TOL IS SET TO THIS STANDARD     
C                DEVIATION.                                             
C X    (OUTPUT)  THE BEST X VALUE FOUND, CORRESPONDING TO THE RETURN    
C                VALUE FROM MNSX                                        
C                                                                       
C                                                                       
      REAL RSTAK(1000)                                                  
      COMMON /CSTAK/ RSTAK                                              
C                                                                       
      INTEGER ISTKGT                                                    
      REAL M7NSX                                                        
      EXTERNAL ISTKGT, ISTKRL, M7NSX                                    
C                                                                       
C *** LOCAL VARIABLES ***                                               
C                                                                       
      INTEGER DX1, IRC, XE1, XR1, Y1                                    
      REAL ZERO                                                         
      DATA ZERO/0.E+0/                                                  
C                                                                       
C *** BODY ***                                                          
C                                                                       
      IF (TOL .LE. ZERO) GO TO 30                                       
      DX1 = ISTKGT(4*P+1, 3)                                            
      XE1 = DX1 + P                                                     
      XR1 = XE1 + P                                                     
      Y1 = XR1 + P                                                      
       MNSX = M7NSX(RSTAK(DX1), FUNC, IRC, ITMX, P, P+1, PP, S, TOL,    
     1               X, RSTAK(XE1), RSTAK(XR1), RSTAK(Y1))              
      GO TO (50, 10, 20, 40), IRC                                       
C/6S                                                                    
C10   CALL SETERR(33H MNSX -- ITERATION LIMIT EXCEEDED, 33, 1, 1)       
C/7S                                                                    
 10   CALL SETERR(' MNSX -- ITERATION LIMIT EXCEEDED', 33, 1, 1)        
C/                                                                      
      GO TO 50                                                          
C/6S                                                                    
C20   CALL SETERR(27H MNSX -- INVALID DIMENSIONS, 27, 2, 2)             
C30   CALL SETERR(30H MNSX CALLED WITH TOL .LE. 0.0, 31, 4, 2)          
C40   CALL SETERR(                                                      
C    1   59H MNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES,
C    2            59, 3, 1)                                             
C/7S                                                                    
 20   CALL SETERR(' MNSX -- INVALID DIMENSIONS', 27, 2, 2)              
 30   CALL SETERR(' MNSX CALLED WITH TOL .LE. 0.0', 31, 4, 2)           
 40   CALL SETERR(                                                      
     1   ' MNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES', 
     2            59, 3, 1)                                             
C/                                                                      
 50   CALL ISTKRL(1)                                                    
      RETURN                                                            
C *** LAST LINE OF  MNSX FOLLOWS ***                                    
      END                                                               
      DOUBLE PRECISION FUNCTION DMNSX(FUNCT, ITMX, P, PP, S, TOL, X)    
C                                                                       
C *** NELDER-MEAD SIMPLEX METHOD (PATTERN SEARCH) FOR UNCONSTRAINED     
C *** MINIMIZATION.                                                     
C                                                                       
      INTEGER ITMX, P, PP                                               
      DOUBLE PRECISION S(PP,1), TOL, X(P)                               
      EXTERNAL FUNCT                                                    
      DOUBLE PRECISION FUNCT                                            
C                                                                       
C *** PARAMETERS ***                                                    
C                                                                       
C FUNC (INPUT)   EXTERNAL FUNCTION TO COMPUTE F(X)                      
C ITMX (INPUT)   MAX. NO. OF ITERATIONS ALLOWED                         
C P    (INPUT)   PROBLEM DIMENSION                                      
C PP   (INPUT)   LEAD DIMENSION OF S, WHICH MUST BE AT LEAST P          
C S    (IN/OUT)  ON INPUT, THE INITIAL SIMPLEX.  ON OUTPUT, THE FINAL   
C                SIMPLEX                                                
C TOL  (IN/OUT)  ON INPUT, THE CONVERGENCE TOLERANCE (ON THE STANDARD   
C                DEVIATION OF THE FUNCTION VALUES AT THE SIMPLEX        
C                VERTICES).  ON OUTPUT, TOL IS SET TO THIS STANDARD     
C                DEVIATION.                                             
C X    (OUTPUT)  THE BEST X VALUE FOUND, CORRESPONDING TO THE RETURN    
C                VALUE FROM DMNSX                                       
C                                                                       
C                                                                       
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
C                                                                       
      INTEGER ISTKGT                                                    
      DOUBLE PRECISION DM7NSX                                           
      EXTERNAL ISTKGT, ISTKRL, DM7NSX                                   
C                                                                       
C *** LOCAL VARIABLES ***                                               
C                                                                       
      INTEGER DX1, IRC, XE1, XR1, Y1                                    
      DOUBLE PRECISION ZERO                                             
      DATA ZERO/0.D+0/                                                  
C                                                                       
C *** BODY ***                                                          
C                                                                       
      IF (TOL .LE. ZERO) GO TO 30                                       
      DX1 = ISTKGT(4*P+1, 4)                                            
      XE1 = DX1 + P                                                     
      XR1 = XE1 + P                                                     
      Y1 = XR1 + P                                                      
      DMNSX = DM7NSX(DSTAK(DX1), FUNCT, IRC, ITMX, P, P+1, PP, S, TOL,  
     1               X, DSTAK(XE1), DSTAK(XR1), DSTAK(Y1))              
      GO TO (50, 10, 20, 40), IRC                                       
C/6S                                                                    
C10   CALL SETERR(33HDMNSX -- ITERATION LIMIT EXCEEDED, 33, 1, 1)       
C/7S                                                                    
 10   CALL SETERR('DMNSX -- ITERATION LIMIT EXCEEDED', 33, 1, 1)        
C/                                                                      
      GO TO 50                                                          
C/6S                                                                    
C20   CALL SETERR(27HDMNSX -- INVALID DIMENSIONS, 27, 2, 2)             
C30   CALL SETERR(30HDMNSX CALLED WITH TOL .LE. 0.0, 31, 4, 2)          
C40   CALL SETERR(                                                      
C    1   59HDMNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES,
C    2            59, 3, 1)                                             
C/7S                                                                    
 20   CALL SETERR('DMNSX -- INVALID DIMENSIONS', 27, 2, 2)              
 30   CALL SETERR('DMNSX CALLED WITH TOL .LE. 0.0', 31, 4, 2)           
 40   CALL SETERR(                                                      
     1   'DMNSX -- FUNCTION AT SIMPLEX CENTER EXCEEDS MAX AT VERTICES', 
     2            59, 3, 1)                                             
C/                                                                      
 50   CALL ISTKRL(1)                                                    
      RETURN                                                            
C *** LAST LINE OF DMNSX FOLLOWS ***                                    
      END                                                               
      REAL FUNCTION  M7NSX(DX, FUNC, IRC, ITMX, P, P1, PP,              
     1                                 S, TOL, X0, XE, XR, Y)           
C                                                                       
C *** NELDER-MEAD SIMPLEX METHOD (PATTERN SEARCH) FOR UNCONSTRAINED     
C *** MINIMIZATION.                                                     
C                                                                       
      INTEGER IRC, ITMX, P, P1, PP                                      
      REAL DX(P), FUNC, S(PP,P1), TOL, X0(P), XE(P), XR(P),             
     1                 Y(P1)                                            
      EXTERNAL FUNC                                                     
C                                                                       
C *** PARAMETERS ***                                                    
C                                                                       
C DX   (SCRATCH) STEP DIRECTION VECTOR                                  
C FUNC (INPUT)   EXTERNAL FUNCTION TO COMPUTE F(X)                      
C IRC  (OUTPUT)  RETURN CODE... 1 = CONVERGENCE TEST SATISFIED,         
C                2 = ITERATION LIMIT EXCEEDED,                          
C                3 = INVALID INPUT, 4 = CONVERGENCE TEST SATISFIED,     
C                BUT F IS LARGER AT THE CENTROID THAN AT ANY VERTEX.    
C ITMX (INPUT)   MAX. NO. OF ITERATIONS ALLOWED                         
C P    (INPUT)   PROBLEM DIMENSION                                      
C P1   (INPUT)   P+1, THE NUMBER OF COLUMNS OF S                        
C PP   (INPUT)   LEAD DIMENSION OF S, WHICH MUST BE AT LEAST P          
C S    (IN/OUT)  ON INPUT, THE INITIAL SIMPLEX.  ON OUTPUT, THE FINAL   
C                SIMPLEX                                                
C TOL  (IN/OUT)  ON INPUT, THE CONVERGENCE TOLERANCE (ON THE STANDARD   
C                DEVIATION OF THE FUNCTION VALUES AT THE SIMPLEX        
C                VERTICES).  ON OUTPUT, TOL IS SET TO THIS STANDARD     
C                DEVIATION.                                             
C X0   (OUTPUT)  THE BEST X VALUE FOUND, CORRESPONDING TO THE RETURN    
C                VALUE FROM  M7NSX                                      
C XE   (SCRATCH)                                                        
C XR   (SCRATCH)                                                        
C Y    (OUTPUT)  THE FUNCTION VALUES AT THE CURRENT SIMPLEX VERTICES    
C                                                                       
C                                                                       
C *** INTRINSIC FUNCTIONS ***                                           
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C *** EXTERNAL FUNCTIONS AND SUBROUTINES ***                            
C                                                                       
      REAL  V2NRM                                                       
      EXTERNAL  V2NRM, V2AXY, V7CPY,  V7SCL,  V7SCP                     
C                                                                       
C *** LOCAL VARIABLES ***                                               
C                                                                       
      INTEGER I, ITER, J, KH, KL, KS                                    
      REAL SD, T, YE, YH, YI, YL, YR, YS                                
C                                                                       
      REAL P1INV, PINV                                                  
      REAL ALPHA, BETA, GAMMA, HALF, ONE, NEGONE, ZERO                  
      DATA ALPHA/1.0E+0/, BETA/0.5E+0/, GAMMA/2.E+0/, HALF/0.5E+0/,     
     1     ONE/1.E+0/, NEGONE/-1.E+0/, ZERO/0.E+0/                      
C                                                                       
C *** BODY ***                                                          
C                                                                       
      IF (P1 .NE. P + 1) GO TO 190                                      
      IF (P .LE. 0) GO TO 190                                           
      IF (PP .LT. P) GO TO 190                                          
C                                                                       
      PINV = ONE / FLOAT(P)                                             
      P1INV = ONE / FLOAT(P1)                                           
C                                                                       
      DO 10 I = 1, P1                                                   
 10     Y(I) = FUNC(P, S(1,I))                                          
C                                                                       
      IRC = 1                                                           
      DO 150 ITER = 1, ITMX                                             
C                                                                       
C *** CONVERGENCE TEST ***                                              
C                                                                       
         SD =  V2NRM(P1, Y)                                             
         IF (SD .LE. ZERO) GO TO 160                                    
         T = ZERO                                                       
         DO 20 I = 1, P1                                                
 20         T = T + Y(I)                                                
         T = P1INV * T / SD                                             
         SD = SD *  SQRT( AMAX1(P1INV - T**2, ZERO) )                   
         IF (SD .LE. TOL) GO TO 160                                     
C                                                                       
C *** FIND XH, XL ***                                                   
C                                                                       
         KH = 1                                                         
         KL = 1                                                         
         YH = Y(1)                                                      
         YL = YH                                                        
         DO 40 I = 2, P1                                                
            YI = Y(I)                                                   
            IF (YI .LE. YH) GO TO 30                                    
               YH = YI                                                  
               KH = I                                                   
 30         IF (YI .GE. YL) GO TO 40                                    
               YL = YI                                                  
               KL = I                                                   
 40         CONTINUE                                                    
C                                                                       
C *** COMPUTE SIMPLEX CENTROID X0 ***                                   
C                                                                       
         CALL  V7SCP(P, X0, ZERO)                                       
         DO 50 I = 1, P1                                                
            IF (I .NE. KH) CALL V2AXY(P, X0, ONE, X0, S(1,I))           
 50         CONTINUE                                                    
         CALL  V7SCL(P, X0, PINV, X0)                                   
C                                                                       
C *** COMPUTE DIRECTION DX AND REFLECTION POINT XR ***                  
C                                                                       
         CALL V2AXY(P, DX, NEGONE, S(1,KH), X0)                         
         CALL V2AXY(P, XR, ALPHA, DX, X0)                               
         YR = FUNC(P, XR)                                               
         IF (YR .GE. YL) GO TO 60                                       
C                                                                       
C *** CONSIDER EXPANSION STEP ***                                       
C                                                                       
         CALL V2AXY(P, XE, GAMMA*ALPHA, DX, X0)                         
         YE = FUNC(P, XE)                                               
         IF (YE .GE. YL) GO TO 90                                       
C        *** ACCEPT EXPANSION STEP ***                                  
         CALL V7CPY(P, S(1,KH), XE)                                     
         Y(KH) = YE                                                     
         GO TO 150                                                      
C                                                                       
C *** FIND SECOND HIGHEST FUNCTION VALUE ***                            
C                                                                       
 60      YS = Y(1)                                                      
         KS = 1                                                         
         IF (KH .NE. 1) GO TO 70                                        
            YS = Y(2)                                                   
            KS = 2                                                      
 70      DO 80 I = 2, P1                                                
            IF (I .EQ. KH) GO TO 80                                     
            YI = Y(I)                                                   
            IF (YI .LE. YS) GO TO 80                                    
            YS = YI                                                     
            KS = I                                                      
 80         CONTINUE                                                    
C                                                                       
         IF (YS .LT. YR) GO TO 100                                      
C        *** ACCEPT REFLECTION STEP ***                                 
 90      CALL V7CPY(P, S(1,KH), XR)                                     
         Y(KH) = YR                                                     
         GO TO 150                                                      
C                                                                       
C *** COMPUTE CONTRACTION STEP ***                                      
C                                                                       
 100     IF (YR .GE. YH) GO TO 110                                      
            CALL V7CPY(P, S(1,KH), XR)                                  
            Y(KH) = YR                                                  
            YH = YR                                                     
            CALL V2AXY(P, DX, NEGONE, XR, X0)                           
 110     CALL V2AXY(P, XE, -BETA, DX, X0)                               
         YE = FUNC(P, XE)                                               
C                                                                       
         IF (YE .GE. YH) GO TO 120                                      
C        *** ACCEPT CONTRACTION STEP ***                                
         CALL V7CPY(P, S(1,KH), XE)                                     
         Y(KH) = YE                                                     
         GO TO 150                                                      
C                                                                       
C *** SHRINK THE SIMPLEX ***                                            
C                                                                       
 120     DO 140 I = 1, P1                                               
            IF (I .EQ. KL) GO TO 140                                    
            DO 130 J = 1, P                                             
 130            S(J,I) = HALF * (S(J,I) + S(J,KL))                      
            Y(I) = FUNC(P, S(1,I))                                      
 140        CONTINUE                                                    
C                                                                       
 150     CONTINUE                                                       
C                                                                       
C *** ITERATION LIMIT EXCEEDED ***                                      
C                                                                       
      IRC = 2                                                           
C                                                                       
C *** CONVERGENCE -- RETURN BEST POINT IN X0 ***                        
C                                                                       
 160  TOL = SD                                                          
      YL = Y(1)                                                         
      YH = YL                                                           
      KL = 1                                                            
      CALL  V7SCL(P, X0, P1INV, S)                                      
      DO 180 I = 2, P1                                                  
         CALL V2AXY(P, X0, P1INV, S(1,I), X0)                           
         YI = Y(I)                                                      
         IF (YI .GE. YL) GO TO 170                                      
            YL = YI                                                     
            KL = I                                                      
            GO TO 180                                                   
 170     IF (YH .LT. YI) YH = YI                                        
 180     CONTINUE                                                       
       M7NSX = FUNC(P, X0)                                              
      IF ( M7NSX .LE. YL) GO TO 999                                     
      CALL V7CPY(P, X0, S(1,KL))                                        
      T =  M7NSX                                                        
       M7NSX = YL                                                       
      IF (IRC .EQ. 2) GO TO 999                                         
      IF (T .GT. YH + SD) IRC = 4                                       
      GO TO 999                                                         
C                                                                       
C *** INVALID INPUT ***                                                 
C                                                                       
 190  IRC = 3                                                           
       M7NSX = ZERO                                                     
C                                                                       
 999  RETURN                                                            
C *** LAST LINE OF  M7NSX FOLLOWS ***                                   
      END                                                               
      DOUBLE PRECISION FUNCTION DM7NSX(DX, FUNC, IRC, ITMX, P, P1, PP,  
     1                                 S, TOL, X0, XE, XR, Y)           
C                                                                       
C *** NELDER-MEAD SIMPLEX METHOD (PATTERN SEARCH) FOR UNCONSTRAINED     
C *** MINIMIZATION.                                                     
C                                                                       
      INTEGER IRC, ITMX, P, P1, PP                                      
      DOUBLE PRECISION DX(P), FUNC, S(PP,P1), TOL, X0(P), XE(P), XR(P), 
     1                 Y(P1)                                            
      EXTERNAL FUNC                                                     
C                                                                       
C *** PARAMETERS ***                                                    
C                                                                       
C DX   (SCRATCH) STEP DIRECTION VECTOR                                  
C FUNC (INPUT)   EXTERNAL FUNCTION TO COMPUTE F(X)                      
C IRC  (OUTPUT)  RETURN CODE... 1 = CONVERGENCE TEST SATISFIED,         
C                2 = ITERATION LIMIT EXCEEDED,                          
C                3 = INVALID INPUT, 4 = CONVERGENCE TEST SATISFIED,     
C                BUT F IS LARGER AT THE CENTROID THAN AT ANY VERTEX.    
C ITMX (INPUT)   MAX. NO. OF ITERATIONS ALLOWED                         
C P    (INPUT)   PROBLEM DIMENSION                                      
C P1   (INPUT)   P+1, THE NUMBER OF COLUMNS OF S                        
C PP   (INPUT)   LEAD DIMENSION OF S, WHICH MUST BE AT LEAST P          
C S    (IN/OUT)  ON INPUT, THE INITIAL SIMPLEX.  ON OUTPUT, THE FINAL   
C                SIMPLEX                                                
C TOL  (IN/OUT)  ON INPUT, THE CONVERGENCE TOLERANCE (ON THE STANDARD   
C                DEVIATION OF THE FUNCTION VALUES AT THE SIMPLEX        
C                VERTICES).  ON OUTPUT, TOL IS SET TO THIS STANDARD     
C                DEVIATION.                                             
C X0   (OUTPUT)  THE BEST X VALUE FOUND, CORRESPONDING TO THE RETURN    
C                VALUE FROM DM7NSX                                      
C XE   (SCRATCH)                                                        
C XR   (SCRATCH)                                                        
C Y    (OUTPUT)  THE FUNCTION VALUES AT THE CURRENT SIMPLEX VERTICES    
C                                                                       
C                                                                       
C *** INTRINSIC FUNCTIONS ***                                           
C/+                                                                     
      DOUBLE PRECISION DSQRT                                            
C/                                                                      
C *** EXTERNAL FUNCTIONS AND SUBROUTINES ***                            
C                                                                       
      DOUBLE PRECISION DV2NRM                                           
      EXTERNAL DV2NRM,DV2AXY,DV7CPY, DV7SCL, DV7SCP                     
C                                                                       
C *** LOCAL VARIABLES ***                                               
C                                                                       
      INTEGER I, ITER, J, KH, KL, KS                                    
      DOUBLE PRECISION SD, T, YE, YH, YI, YL, YR, YS                    
C                                                                       
      DOUBLE PRECISION P1INV, PINV                                      
      DOUBLE PRECISION ALPHA, BETA, GAMMA, HALF, ONE, NEGONE, ZERO      
      DATA ALPHA/1.0D+0/, BETA/0.5D+0/, GAMMA/2.D+0/, HALF/0.5D+0/,     
     1     ONE/1.D+0/, NEGONE/-1.D+0/, ZERO/0.D+0/                      
C                                                                       
C *** BODY ***                                                          
C                                                                       
      IF (P1 .NE. P + 1) GO TO 190                                      
      IF (P .LE. 0) GO TO 190                                           
      IF (PP .LT. P) GO TO 190                                          
C                                                                       
      PINV = ONE / FLOAT(P)                                             
      P1INV = ONE / FLOAT(P1)                                           
C                                                                       
      DO 10 I = 1, P1                                                   
 10     Y(I) = FUNC(P, S(1,I))                                          
C                                                                       
      IRC = 1                                                           
      DO 150 ITER = 1, ITMX                                             
C                                                                       
C *** CONVERGENCE TEST ***                                              
C                                                                       
         SD = DV2NRM(P1, Y)                                             
         IF (SD .LE. ZERO) GO TO 160                                    
         T = ZERO                                                       
         DO 20 I = 1, P1                                                
 20         T = T + Y(I)                                                
         T = P1INV * T / SD                                             
         SD = SD * DSQRT( DMAX1(P1INV - T**2, ZERO) )                   
         IF (SD .LE. TOL) GO TO 160                                     
C                                                                       
C *** FIND XH, XL ***                                                   
C                                                                       
         KH = 1                                                         
         KL = 1                                                         
         YH = Y(1)                                                      
         YL = YH                                                        
         DO 40 I = 2, P1                                                
            YI = Y(I)                                                   
            IF (YI .LE. YH) GO TO 30                                    
               YH = YI                                                  
               KH = I                                                   
 30         IF (YI .GE. YL) GO TO 40                                    
               YL = YI                                                  
               KL = I                                                   
 40         CONTINUE                                                    
C                                                                       
C *** COMPUTE SIMPLEX CENTROID X0 ***                                   
C                                                                       
         CALL DV7SCP(P, X0, ZERO)                                       
         DO 50 I = 1, P1                                                
            IF (I .NE. KH) CALL DV2AXY(P, X0, ONE, X0, S(1,I))          
 50         CONTINUE                                                    
         CALL DV7SCL(P, X0, PINV, X0)                                   
C                                                                       
C *** COMPUTE DIRECTION DX AND REFLECTION POINT XR ***                  
C                                                                       
         CALL DV2AXY(P, DX, NEGONE, S(1,KH), X0)                        
         CALL DV2AXY(P, XR, ALPHA, DX, X0)                              
         YR = FUNC(P, XR)                                               
         IF (YR .GE. YL) GO TO 60                                       
C                                                                       
C *** CONSIDER EXPANSION STEP ***                                       
C                                                                       
         CALL DV2AXY(P, XE, GAMMA*ALPHA, DX, X0)                        
         YE = FUNC(P, XE)                                               
         IF (YE .GE. YL) GO TO 90                                       
C        *** ACCEPT EXPANSION STEP ***                                  
         CALL DV7CPY(P, S(1,KH), XE)                                    
         Y(KH) = YE                                                     
         GO TO 150                                                      
C                                                                       
C *** FIND SECOND HIGHEST FUNCTION VALUE ***                            
C                                                                       
 60      YS = Y(1)                                                      
         KS = 1                                                         
         IF (KH .NE. 1) GO TO 70                                        
            YS = Y(2)                                                   
            KS = 2                                                      
 70      DO 80 I = 2, P1                                                
            IF (I .EQ. KH) GO TO 80                                     
            YI = Y(I)                                                   
            IF (YI .LE. YS) GO TO 80                                    
            YS = YI                                                     
            KS = I                                                      
 80         CONTINUE                                                    
C                                                                       
         IF (YS .LT. YR) GO TO 100                                      
C        *** ACCEPT REFLECTION STEP ***                                 
 90      CALL DV7CPY(P, S(1,KH), XR)                                    
         Y(KH) = YR                                                     
         GO TO 150                                                      
C                                                                       
C *** COMPUTE CONTRACTION STEP ***                                      
C                                                                       
 100     IF (YR .GE. YH) GO TO 110                                      
            CALL DV7CPY(P, S(1,KH), XR)                                 
            Y(KH) = YR                                                  
            YH = YR                                                     
            CALL DV2AXY(P, DX, NEGONE, XR, X0)                          
 110     CALL DV2AXY(P, XE, -BETA, DX, X0)                              
         YE = FUNC(P, XE)                                               
C                                                                       
         IF (YE .GE. YH) GO TO 120                                      
C        *** ACCEPT CONTRACTION STEP ***                                
         CALL DV7CPY(P, S(1,KH), XE)                                    
         Y(KH) = YE                                                     
         GO TO 150                                                      
C                                                                       
C *** SHRINK THE SIMPLEX ***                                            
C                                                                       
 120     DO 140 I = 1, P1                                               
            IF (I .EQ. KL) GO TO 140                                    
            DO 130 J = 1, P                                             
 130            S(J,I) = HALF * (S(J,I) + S(J,KL))                      
            Y(I) = FUNC(P, S(1,I))                                      
 140        CONTINUE                                                    
C                                                                       
 150     CONTINUE                                                       
C                                                                       
C *** ITERATION LIMIT EXCEEDED ***                                      
C                                                                       
      IRC = 2                                                           
C                                                                       
C *** CONVERGENCE -- RETURN BEST POINT IN X0 ***                        
C                                                                       
 160  TOL = SD                                                          
      YL = Y(1)                                                         
      YH = YL                                                           
      KL = 1                                                            
      CALL DV7SCL(P, X0, P1INV, S)                                      
      DO 180 I = 2, P1                                                  
         CALL DV2AXY(P, X0, P1INV, S(1,I), X0)                          
         YI = Y(I)                                                      
         IF (YI .GE. YL) GO TO 170                                      
            YL = YI                                                     
            KL = I                                                      
            GO TO 180                                                   
 170     IF (YH .LT. YI) YH = YI                                        
 180     CONTINUE                                                       
      DM7NSX = FUNC(P, X0)                                              
      IF (DM7NSX .LE. YL) GO TO 999                                     
      CALL DV7CPY(P, X0, S(1,KL))                                       
      T = DM7NSX                                                        
      DM7NSX = YL                                                       
      IF (IRC .EQ. 2) GO TO 999                                         
      IF (T .GT. YH + SD) IRC = 4                                       
      GO TO 999                                                         
C                                                                       
C *** INVALID INPUT ***                                                 
C                                                                       
 190  IRC = 3                                                           
      DM7NSX = ZERO                                                     
C                                                                       
 999  RETURN                                                            
C *** LAST LINE OF DM7NSX FOLLOWS ***                                   
      END                                                               
      SUBROUTINE  NSF1(N,L,X,X1,X2,T,C)                                 
C                                                                       
C     *************************************************                 
C     LINEAR LEAST SQUARES WITH ONE NONLINEAR PARAMETER                 
C     *************************************************                 
C                                                                       
C     N   (INPUT)  NUMBER OF EQUATIONS                                  
C     L   (INPUT)  NUMBER OF PARAMTERS (UNKNOWNS)                       
C     X   (OUTPUT)  SOLUTION TO NONLINEAR PARAMETER                     
C     X1  (INPUT)  ONE END OF INTERVAL CONTAINING X                     
C     X2  (INPUT)  OTHER END OF INTERVAL                                
C     T   (INPUT)  TOLERANCE                                            
C     C   (OUTPUT)  SOLUTION VECTOR OF LINEAR PARAMETERS                
C                                                                       
      REAL RS(1000)                                                     
      INTEGER IS(1000)                                                  
      INTEGER L                                                         
      REAL C(L)                                                         
      REAL FMIN                                                         
      EXTERNAL L4ST1                                                    
      COMMON/L6NCB/NN,NP,IB,IY                                          
      COMMON/CSTAK/R(1000)                                              
      EQUIVALENCE (R(1),IS(1))                                          
      EQUIVALENCE (R(1),RS(1))                                          
C                                                                       
CI DIMENSION ERROR CHECK                                                
C                                                                       
C/6S                                                                    
C     IF(L .LT. 1) CALL SETERR(14H NSF1 - L.LT.1,14,1,2)                
C     IF(L .GT. N) CALL SETERR(14H NSF1 - L.GT.N,14,2,2)                
C/7S                                                                    
      IF(L .LT. 1) CALL SETERR(' NSF1 - L.LT.1',14,1,2)                 
      IF(L .GT. N) CALL SETERR(' NSF1 - L.GT.N',14,2,2)                 
C/                                                                      
C                                                                       
      NN=N                                                              
      NP=L                                                              
      IB=ISTKGT(N*L,3)                                                  
      IY=ISTKGT(N,3)                                                    
C                                                                       
C SOLVE 1-DIM PROBLEM                                                   
C                                                                       
      FRSD=FMIN(L4ST1,X,X1,X2,T)                                        
      CALL GETAY(NN,NP,X,RS(IB),RS(IY))                                 
C                                                                       
C SOLVE REMAINING LINEAR LEAST-SQUARES PROBLEM                          
C                                                                       
      CALL LSTSQ(NN,NP,NN,NP,RS(IB),RS(IY),1,C)                         
      CALL ISTKRL(2)                                                    
      RETURN                                                            
      END                                                               
      REAL FUNCTION L4ST1(X)                                            
C                                                                       
C 1-DIM FUNCTION                                                        
C                                                                       
      REAL RS(1000)                                                     
      INTEGER IS(1000)                                                  
      INTEGER P,RLEN                                                    
      COMMON/L6NCB/N,P,IB,IY                                            
      COMMON/CSTAK/R(1000)                                              
      EQUIVALENCE (R(1),IS(1))                                          
      EQUIVALENCE (R(1),RS(1))                                          
C                                                                       
      IW=ISTKGT(P, 3)                                                   
      RLEN= (P*(P+1))/2                                                 
      IR=ISTKGT(RLEN, 3)                                                
      IIPVT=ISTKGT(P,2)                                                 
C                                                                       
C EVALUATE FUNCTION                                                     
C                                                                       
      CALL L4ST2(X,N,P,F,RS(IB),RS(IY),RS(IW),RS(IR),RLEN,IS(IIPVT))    
      L4ST1=F                                                           
      CALL ISTKRL(3)                                                    
      RETURN                                                            
      END                                                               
      SUBROUTINE L4ST2(X,N,P,F,B,Y,W,R,RLEN,IPVT)                       
C                                                                       
C EVALUATES NORM OF LAST (N-P) ELEMENTS OF QY                           
C                                                                       
      INTEGER P,PI,RLEN                                                 
      REAL B(N,P),Y(N),W(P),R(RLEN)                                     
      INTEGER IPVT(P)                                                   
      DOUBLE PRECISION S, DSQRT                                         
      CALL GETAY(N,P,X,B,Y)                                             
C                                                                       
C QR DECOMPOSITION                                                      
C                                                                       
      CALL Q7RFH(IER,IPVT,N,N,0,P,B,R,RLEN,W)                           
      IF(IER .EQ. 0) PI=P                                               
      IF(IER .EQ. 0) GO TO 100                                          
      PI=IABS(IER)-1                                                    
C                                                                       
C QY                                                                    
C                                                                       
  100 CALL Q7APL(N,N,PI,B,Y,IER)                                        
C                                                                       
C CALCULATE NORM                                                        
C                                                                       
      S=0.D0                                                            
      PI=PI+1                                                           
      DO 200 I=PI,N                                                     
  200    S=S+Y(I)*DBLE(Y(I))                                            
      R2N=DSQRT(S)                                                      
      F=R2N                                                             
      RETURN                                                            
      END                                                               
      SUBROUTINE DNSF1(N,L,X,X1,X2,T,C)                                 
C                                                                       
C     *************************************************                 
C     LINEAR LEAST SQUARES WITH ONE NONLINEAR PARAMETER                 
C     *************************************************                 
C                                                                       
C     N   (INPUT)  NUMBER OF EQUATIONS                                  
C     L   (INPUT)  NUMBER OF PARAMTERS (UNKNOWNS)                       
C     X   (OUTPUT)  SOLUTION TO NONLINEAR PARAMETER                     
C     X1  (INPUT)  ONE END OF INTERVAL CONTAINING X                     
C     X2  (INPUT)  OTHER END OF INTERVAL                                
C     T   (INPUT)  TOLERANCE                                            
C     C   (OUTPUT)  SOLUTION VECTOR OF LINEAR PARAMETERS                
C                                                                       
      DOUBLE PRECISION RS(500)                                          
      INTEGER IS(1000)                                                  
      INTEGER L                                                         
      DOUBLE PRECISION C(L)                                             
      DOUBLE PRECISION X,X1,X2,T                                        
      DOUBLE PRECISION DFMIN                                            
      EXTERNAL DL4ST1                                                   
      COMMON/DL6NCB/NN,NP,IB,IY                                         
      COMMON/CSTAK/R(1000)                                              
      EQUIVALENCE (R(1),IS(1))                                          
      EQUIVALENCE (R(1),RS(1))                                          
C                                                                       
CI DIMENSION ERROR CHECK                                                
C                                                                       
C/6S                                                                    
C     IF(L .LT. 1) CALL SETERR(14HDNSF1 - L.LT.1,14,1,2)                
C     IF(L .GT. N) CALL SETERR(14HDNSF1 - L.GT.N,14,2,2)                
C/7S                                                                    
      IF(L .LT. 1) CALL SETERR('DNSF1 - L.LT.1',14,1,2)                 
      IF(L .GT. N) CALL SETERR('DNSF1 - L.GT.N',14,2,2)                 
C/                                                                      
C                                                                       
      NN=N                                                              
      NP=L                                                              
      IB=ISTKGT(N*L,4)                                                  
      IY=ISTKGT(N,4)                                                    
C                                                                       
C SOLVE 1-DIM PROBLEM                                                   
C                                                                       
      FRSD=DFMIN(DL4ST1,X,X1,X2,T)                                      
      CALL GETAY(NN,NP,X,RS(IB),RS(IY))                                 
C                                                                       
C SOLVE REMAINING LINEAR LEAST-SQUARES PROBLEM                          
C                                                                       
      CALL DLSTSQ(NN,NP,NN,NP,RS(IB),RS(IY),1,C)                        
      CALL ISTKRL(2)                                                    
      RETURN                                                            
      END                                                               
      DOUBLE PRECISION FUNCTION DL4ST1(X)                               
C                                                                       
C 1-DIM FUNCTION                                                        
C                                                                       
      DOUBLE PRECISION X, F                                             
      DOUBLE PRECISION RS(500)                                          
      INTEGER IS(1000)                                                  
      INTEGER P,RLEN                                                    
      COMMON/DL6NCB/N,P,IB,IY                                           
      COMMON/CSTAK/R(1000)                                              
      EQUIVALENCE (R(1),IS(1))                                          
      EQUIVALENCE (R(1),RS(1))                                          
C                                                                       
      IW=ISTKGT(P, 4)                                                   
      RLEN= (P*(P+1))/2                                                 
      IR=ISTKGT(RLEN, 4)                                                
      IIPVT=ISTKGT(P,2)                                                 
C                                                                       
C EVALUATE FUNCTION                                                     
C                                                                       
      CALL DL4ST2(X,N,P,F,RS(IB),RS(IY),RS(IW),RS(IR),RLEN,IS(IIPVT))   
      DL4ST1=F                                                          
      CALL ISTKRL(3)                                                    
      RETURN                                                            
      END                                                               
      SUBROUTINE DL4ST2(X,N,P,F,B,Y,W,R,RLEN,IPVT)                      
C                                                                       
C EVALUATES NORM OF LAST (N-P) ELEMENTS OF QY                           
C                                                                       
      INTEGER P,PI,RLEN                                                 
      DOUBLE PRECISION B(N,P),Y(N),W(P),R(RLEN), X,F                    
      INTEGER IPVT(P)                                                   
      DOUBLE PRECISION S, DSQRT, R2N                                    
      CALL GETAY(N,P,X,B,Y)                                             
C                                                                       
C QR DECOMPOSITION                                                      
C                                                                       
      CALL DQ7RFH(IER,IPVT,N,N,0,P,B,R,RLEN,W)                          
      IF(IER .EQ. 0) PI=P                                               
      IF(IER .EQ. 0) GO TO 100                                          
      PI=IABS(IER)-1                                                    
C                                                                       
C QY                                                                    
C                                                                       
  100 CALL DQ7APL(N,N,PI,B,Y,IER)                                       
C                                                                       
C CALCULATE NORM                                                        
C                                                                       
      S=0.D0                                                            
      PI=PI+1                                                           
      DO 200 I=PI,N                                                     
  200    S=S+Y(I)*(Y(I))                                                
      R2N=DSQRT(S)                                                      
      F=R2N                                                             
      RETURN                                                            
      END                                                               
      SUBROUTINE  SN2F(N, P, X, CALCR,   MXFCAL, ACC )                  
C                                                                       
C ** SIMPLIED VERSION OF DN2F                                           
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCR SUBROUTINE TO EVALUATE RESIDUAL                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER N, P, MXFCAL                                              
      REAL X(N), ACC                                                    
      EXTERNAL CALCR,   C6LCR                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      REAL DSTAK(1000)                                                  
      INTEGER ISTAK(1000)                                               
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24H SN2F - N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SN2F - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SN2F -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR(' SN2F - N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SN2F - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SN2F -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV = P + 82                                                      
      LV = P*(N + 2*P + 17) + 2*N + 105                                 
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  N2F(N, P, X,  C6LCR,  ISTAK(IV), LIV, LV,                   
     1            DSTAK(V1), IU, UR, CALCR)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27H SN2F -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24H SN2F -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32H SN2F -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SN2F -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR(' SN2F -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR(' SN2F -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR(' SN2F -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SN2F -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SN2F  FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  SN2FB(N, P, X,B, CALCR,   MXFCAL, ACC )               
C                                                                       
C ** SIMPLIED VERSION OF N2FB                                           
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW CONTAINS LOWER BOUNDS ON VARIABLES AND SECOND          
C      ROW CONSTAINS UPPER BOUNDS                                       
C CALCR SUBROUTINE TO EVALUATE RESIDUAL                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER N, P, MXFCAL                                              
      REAL X(N), ACC , B(2,P)                                           
      EXTERNAL CALCR,   C6LCR                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      REAL DSTAK(1000)                                                  
      INTEGER ISTAK(1000)                                               
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24H SN2FB- N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SN2FB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SN2FB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR(' SN2FB- N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SN2FB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SN2FB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV = 4*P + 82                                                    
      LV = P*(N + 2*P + 21) + 2*N + 105                                 
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  N2FB(N, P, X,B,  C6LCR,  ISTAK(IV), LIV, LV,                
     1            DSTAK(V1), IU, UR, CALCR)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26H SN2FB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27H SN2FB-SINGULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24H SN2FB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32H SN2FB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SN2FB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR(' SN2FB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR(' SN2FB-SINGULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR(' SN2FB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR(' SN2FB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SN2FB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SN2FB FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE    SN2G(N, P, X, CALCR, CALCJ, MXFCAL, ACC )           
C                                                                       
C  ***  VERSION OF NL2SOL THAT CALLS  DRN2G  ***                        
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV, MXFCAL                                     
      REAL X(P), ACC                                                    
      EXTERNAL CALCR, CALCJ                                             
C                                                                       
C  ***  PARAMETER USAGE  ***                                            
C                                                                       
C N....... TOTAL NUMBER OF RESIDUALS.                                   
C P....... NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.      
C X....... PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,     
C             OUTPUT = BEST VALUE FOUND).                               
C CALCR... SUBROUTINE FOR COMPUTING RESIDUAL VECTOR.                    
C CALCJ... SUBROUTINE FOR COMPUTING JACOBIAN MATRIX = MATRIX OF FIRST   
C             PARTIALS OF THE RESIDUAL VECTOR.                          
C MXFCAL...MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS             
C ACC .....DESIRED ACCURACY                                             
C                                                                       
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      INTEGER ISTKGT                                                    
      EXTERNAL  IVSET,   RN2G, ISTKGT                                   
C DIVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                
C  DRN2G... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DR1, IV1, JJ, N1, N2, NF, R1, RD1                     
      INTEGER IVV1,V1,IVD,IVJ,IVNEXT,IVNFCA,IVNFGC,IVR,IVREGD           
      INTEGER IVTOOB,IVNEED,IVREG0                                      
      INTEGER IVM1,VM1                                                  
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NFCALL, NFGCAL, R, REGD, REGD0, TOOBIG, VNEED
      INTEGER ISTAK(1000)                                               
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1),ISTAK(1))                                   
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, R/61/,        
C    1     REGD/67/, REGD0/82/, TOOBIG/2/, VNEED/4/                     
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NFCALL=6, NFGCAL=7, R=61,        
     1           REGD=67, REGD0=82, TOOBIG=2, VNEED=4)                  
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24H SN2G - N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SN2G - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SN2G -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR(' SN2G - N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SN2G - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SN2G -ACC .LT.0.0',18,3,2)                          
C/                                                                      
       LIV=P+82                                                         
       LV=P*(N+2*P+17)+2*N+105                                          
       IVV1=ISTKGT(LIV,2)                                               
       IVM1=IVV1-1                                                      
       V1=ISTKGT(LV, 3)                                                 
       VM1=V1-1                                                         
       CALL IVSET(1,ISTAK(IVV1),LIV,LV,DSTAK(V1))                       
      ISTAK(IVM1+21)=0                                                  
      ISTAK(IVM1+17)=MXFCAL                                             
      ISTAK(IVM1+18)=MXFCAL                                             
      ISTAK(IVM1+57)=0                                                  
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      IV1 = ISTAK(IVV1)                                                 
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) ISTAK(IVV1) = 13                                 
      IVNEED=IVM1+VNEED                                                 
      IF (ISTAK(IVV1) .EQ. 13)ISTAK(IVNEED) =ISTAK(IVNEED) + P + N*(P+2)
      CALL   RN2G(X, DSTAK(V1),ISTAK(IVV1), LIV, LV, N, N, N1, N2, P,   
     1DSTAK(V1),DSTAK(V1),DSTAK(V1), X)                                 
      IF (ISTAK(IVV1) .NE. 14) GO TO 999                                
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IVD=IVM1+D                                                        
      IVNEXT=IVM1+NEXTV                                                 
      ISTAK(IVD) = ISTAK(IVNEXT)                                        
      IVR=IVM1+R                                                        
      ISTAK(IVR) = ISTAK(IVD) + P                                       
      IVREG0=IVM1+REGD0                                                 
      ISTAK(IVREG0) = ISTAK(IVR) + N                                    
      IVJ=IVM1+J                                                        
      ISTAK(IVJ) = ISTAK(IVREG0) + N                                    
      ISTAK(IVNEXT) = ISTAK(IVJ) + N*P                                  
      IVNFCA=IVM1+NFCALL                                                
      IVNFGC=IVM1+NFGCAL                                                
      IVREGD=IVM1+REGD                                                  
      IVTOOB=IVM1+TOOBIG                                                
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = ISTAK(IVD)+VM1                                               
      DR1 = ISTAK(IVJ)+VM1                                              
      R1 = ISTAK(IVR)+VM1                                               
      RD1 = ISTAK(IVREG0)+VM1                                           
C                                                                       
 20   CALL   RN2G(DSTAK(D1), DSTAK(DR1), ISTAK(IVV1), LIV, LV, N, N,    
     1 N1, N2, P, DSTAK(R1),DSTAK(RD1),DSTAK(V1),X)                     
      IF (ISTAK(IVV1)-2) 30, 50, 999                                    
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = ISTAK(IVNFCA)                                                
      CALL CALCR(N, P, X, NF, DSTAK(R1))                                
      IF (NF .GT. 0) GO TO 40                                           
         ISTAK(IVTOOB) = 1                                              
         GO TO 20                                                       
 40   IF (ISTAK(IVV1) .GT. 0) GO TO 20                                  
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 50   CALL CALCJ(N, P, X, ISTAK(IVNFGC), DSTAK(DR1))                    
      IF (ISTAK(IVNFGC) .EQ. 0) ISTAK(IVTOOB) = 1                       
      GO TO 20                                                          
C                                                                       
C  ***  INDICATE WHETHER THE REGRESSION DIAGNOSTIC ARRAY WAS COMPUTED   
C  ***  AND PRINT IT IF SO REQUESTED...                                 
C                                                                       
C                                                                       
 999  CONTINUE                                                          
      JJ=ISTAK(IVV1)                                                    
      IF(JJ.LT.7) GO TO 80                                              
C/6S                                                                    
C     IF (JJ.EQ.7)CALL SETERR(27H SN2G -SINGULAR CONVERGENCE,27,4,1)    
C     IF(JJ.EQ.8)CALL SETERR(24H SN2G -FALSE CONVERGENCE,24,5,1)        
C     IF(JJ.EQ.9)CALL SETERR(32H SN2G -FUNCTION EVALUATION LIMIT,32,6,1)
C     IF (JJ.EQ.63)                                                     
C    1CALL SETERR(43H SN2G -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C     IF(JJ.EQ.65)                                                      
C    1CALL SETERR(47H SN2G -JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,8,1)                                                           
C/7S                                                                    
      IF (JJ.EQ.7)CALL SETERR(' SN2G -SINGULAR CONVERGENCE',27,4,1)     
      IF(JJ.EQ.8)CALL SETERR(' SN2G -FALSE CONVERGENCE',24,5,1)         
      IF(JJ.EQ.9)CALL SETERR(' SN2G -FUNCTION EVALUATION LIMIT',32,6,1) 
      IF (JJ.EQ.63)                                                     
     1CALL SETERR(' SN2G -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
      IF(JJ.EQ.65)                                                      
     1CALL SETERR(' SN2G -JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,8,1)                                                           
C/                                                                      
 80   CALL LEAVE                                                        
      RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    SN2G FOLLOWS  ***                               
      END                                                               
      SUBROUTINE  SN2GB(N, P, X, B, CALCR, CALCJ, MXFCAL, ACC)          
C                                                                       
C  ***  VERSION OF NL2SOL THAT CALLS  RN2GB ***                         
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV, MXFCAL                                     
      REAL X(P), B(2,P), ACC                                            
      EXTERNAL CALCR, CALCJ                                             
C                                                                       
C  ***  PARAMETER USAGE  ***                                            
C                                                                       
C N....... TOTAL NUMBER OF RESIDUALS.                                   
C P....... NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.      
C X....... PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,     
C             OUTPUT = BEST VALUE FOUND).                               
C B........2-D WHOSE FIRST ROW GIVES LOWER BOUNDS ON X AND WHOSE        
C          SECOND ROW GIVES UPPER BOUNDS                                
C CALCR... SUBROUTINE FOR COMPUTING RESIDUAL VECTOR.                    
C CALCJ... SUBROUTINE FOR COMPUTING JACOBIAN MATRIX = MATRIX OF FIRST   
C             PARTIALS OF THE RESIDUAL VECTOR.                          
C MXFCAL...MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS             
C ACC .....DESIRED ACCURACY                                             
C                                                                       
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      INTEGER ISTKGT                                                    
      EXTERNAL  IVSET,   RN2GB, ISTKGT                                  
C DIVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                
C  RN2GB... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DR1, IV1, JJ, N1, N2, NF, R1, RD1                     
      INTEGER IVV1,V1,IVD,IVJ,IVNEXT,IVNFCA,IVNFGC,IVR,IVREGD           
      INTEGER IVTOOB,IVNEED,IVREG0                                      
      INTEGER IVM1,VM1                                                  
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NFCALL, NFGCAL, R, REGD, REGD0, TOOBIG, VNEED
      INTEGER ISTAK(1000)                                               
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1),ISTAK(1))                                   
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, R/61/,        
C    1     REGD/67/, REGD0/82/, TOOBIG/2/, VNEED/4/                     
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NFCALL=6, NFGCAL=7, R=61,        
     1           REGD=67, REGD0=82, TOOBIG=2, VNEED=4)                  
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24H SN2GB- N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SN2GB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SN2GB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR(' SN2GB- N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SN2GB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SN2GB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
       LIV=4*P+82                                                       
       LV=P*(N+2*P+21)+2*N+105                                          
       IVV1=ISTKGT(LIV,2)                                               
       IVM1=IVV1-1                                                      
       V1=ISTKGT(LV, 3)                                                 
       VM1=V1-1                                                         
       CALL IVSET(1,ISTAK(IVV1),LIV,LV,DSTAK(V1))                       
      ISTAK(IVM1+21)=0                                                  
      ISTAK(IVM1+17)=MXFCAL                                             
      ISTAK(IVM1+18)=MXFCAL                                             
      ISTAK(IVM1+57)=0                                                  
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      IV1 = ISTAK(IVV1)                                                 
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) ISTAK(IVV1) = 13                                 
      IVNEED=IVM1+VNEED                                                 
      IF (ISTAK(IVV1) .EQ. 13)ISTAK(IVNEED) =ISTAK(IVNEED) + P + N*(P+2)
      CALL   RN2GB(B,X, DSTAK(V1),ISTAK(IVV1), LIV, LV, N, N, N1, N2, P,
     1DSTAK(V1),DSTAK(V1),DSTAK(V1), X)                                 
      IF (ISTAK(IVV1) .NE. 14) GO TO 999                                
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IVD=IVM1+D                                                        
      IVNEXT=IVM1+NEXTV                                                 
      ISTAK(IVD) = ISTAK(IVNEXT)                                        
      IVR=IVM1+R                                                        
      ISTAK(IVR) = ISTAK(IVD) + P                                       
      IVREG0=IVM1+REGD0                                                 
      ISTAK(IVREG0) = ISTAK(IVR) + N                                    
      IVJ=IVM1+J                                                        
      ISTAK(IVJ) = ISTAK(IVREG0) + N                                    
      ISTAK(IVNEXT) = ISTAK(IVJ) + N*P                                  
      IVNFCA=IVM1+NFCALL                                                
      IVNFGC=IVM1+NFGCAL                                                
      IVREGD=IVM1+REGD                                                  
      IVTOOB=IVM1+TOOBIG                                                
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = ISTAK(IVD)+VM1                                               
      DR1 = ISTAK(IVJ)+VM1                                              
      R1 = ISTAK(IVR)+VM1                                               
      RD1 = ISTAK(IVREG0)+VM1                                           
C                                                                       
 20   CALL   RN2GB(B,DSTAK(D1), DSTAK(DR1), ISTAK(IVV1), LIV, LV, N, N, 
     1 N1, N2, P, DSTAK(R1),DSTAK(RD1),DSTAK(V1),X)                     
      IF (ISTAK(IVV1)-2) 30, 50, 999                                    
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = ISTAK(IVNFCA)                                                
      CALL CALCR(N, P, X, NF, DSTAK(R1))                                
      IF (NF .GT. 0) GO TO 40                                           
         ISTAK(IVTOOB) = 1                                              
         GO TO 20                                                       
 40   IF (ISTAK(IVV1) .GT. 0) GO TO 20                                  
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 50   CALL CALCJ(N, P, X, ISTAK(IVNFGC), DSTAK(DR1))                    
      IF (ISTAK(IVNFGC) .EQ. 0) ISTAK(IVTOOB) = 1                       
      GO TO 20                                                          
C                                                                       
C  ***  INDICATE WHETHER THE REGRESSION DIAGNOSTIC ARRAY WAS COMPUTED   
C  ***  AND PRINT IT IF SO REQUESTED...                                 
C                                                                       
C                                                                       
 999  CONTINUE                                                          
      JJ=ISTAK(IVV1)                                                    
      IF(JJ.LT.7) GO TO 80                                              
C/6S                                                                    
C     IF (JJ.EQ.82)CALL SETERR(26H SN2GB-INCONSISTENT BOUNDS,26,4,1)    
C     IF (JJ.EQ.7)CALL SETERR(27H SN2GB-SINGULAR CONVERGENCE,27,5,1)    
C     IF(JJ.EQ.8)CALL SETERR(24H SN2GB-FALSE CONVERGENCE,24,6,1)        
C     IF(JJ.EQ.9)CALL SETERR(32H SN2GB-FUNCTION EVALUATION LIMIT,32,7,1)
C     IF (JJ.EQ.63)                                                     
C    1CALL SETERR(43H SN2GB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C     IF(JJ.EQ.65)                                                      
C    1CALL SETERR(47H SN2GB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,9,1)                                                           
C/7S                                                                    
      IF (JJ.EQ.82)CALL SETERR(' SN2GB-INCONSISTENT BOUNDS',26,4,1)     
      IF (JJ.EQ.7)CALL SETERR(' SN2GB-SINGULAR CONVERGENCE',27,5,1)     
      IF(JJ.EQ.8)CALL SETERR(' SN2GB-FALSE CONVERGENCE',24,6,1)         
      IF(JJ.EQ.9)CALL SETERR(' SN2GB-FUNCTION EVALUATION LIMIT',32,7,1) 
      IF (JJ.EQ.63)                                                     
     1CALL SETERR(' SN2GB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
      IF(JJ.EQ.65)                                                      
     1CALL SETERR(' SN2GB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,9,1)                                                           
C/                                                                      
 80   CALL LEAVE                                                        
      RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    SN2GBFOLLOWS  ***                               
      END                                                               
      SUBROUTINE C6LCR(N,P,X,NF,R,IU,UR,UF)                             
      INTEGER N,P,IU                                                    
      REAL X(P),R(N),UR                                                 
      EXTERNAL UF                                                       
      CALL UF(N,P,X,NF,R)                                               
      RETURN                                                            
      END                                                               
      SUBROUTINE  DSN2F(N, P, X, CALCR,   MXFCAL, ACC )                 
C                                                                       
C ** SIMPLIED VERSION OF DN2F                                           
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCR SUBROUTINE TO EVALUATE RESIDUAL                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER N, P, MXFCAL                                              
      DOUBLE PRECISION X(N), ACC                                        
      EXTERNAL CALCR,   DC6LCR                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      DOUBLE PRECISION UR                                               
      COMMON /CSTAK/ DSTAK                                              
      DOUBLE PRECISION DSTAK(500)                                       
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24HDSN2F - N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSN2F - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSN2F -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR('DSN2F - N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSN2F - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSN2F -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV = P + 82                                                      
      LV = P*(N + 2*P + 17) + 2*N + 105                                 
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  DN2F(N, P, X,  DC6LCR,  ISTAK(IV), LIV, LV,                 
     1            DSTAK(V1), IU, UR, CALCR)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27HDSN2F -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSN2F -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSN2F -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSN2F -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR('DSN2F -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR('DSN2F -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR('DSN2F -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSN2F -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSN2F  FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DSN2FB(N, P, X,B, CALCR,   MXFCAL, ACC )              
C                                                                       
C ** SIMPLIED VERSION OF DN2FB                                          
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW CONTAINS LOWER BOUNDS ON VARIABLES AND SECOND          
C      ROW CONSTAINS UPPER BOUNDS                                       
C CALCR SUBROUTINE TO EVALUATE RESIDUAL                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER N, P, MXFCAL                                              
      DOUBLE PRECISION X(N), ACC , B(2,P)                               
      EXTERNAL CALCR,   DC6LCR                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***, B(2,P)                                    
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      DOUBLE PRECISION UR                                               
      DOUBLE PRECISION DSTAK(500)                                       
      INTEGER ISTAK(1000)                                               
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24HDSN2FB- N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSN2FB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSN2FB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR('DSN2FB- N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSN2FB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSN2FB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV = 4*P + 82                                                    
      LV = P*(N + 2*P + 21) + 2*N + 105                                 
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  DN2FB(N, P, X,B,  DC6LCR,  ISTAK(IV), LIV, LV,              
     1            DSTAK(V1), IU, UR, CALCR)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26HDSN2FB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27HDSN2FB-SINGULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSN2FB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSN2FB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSN2FB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR('DSN2FB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR('DSN2FB-SINGULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR('DSN2FB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR('DSN2FB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSN2FB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSN2FB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE    DSN2G(N, P, X, CALCR, CALCJ, MXFCAL, ACC )          
C                                                                       
C  ***  VERSION OF NL2SOL THAT CALLS  DRN2G  ***                        
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV, MXFCAL                                     
      DOUBLE PRECISION X(P), ACC                                        
      EXTERNAL CALCR, CALCJ                                             
C                                                                       
C  ***  PARAMETER USAGE  ***                                            
C                                                                       
C N....... TOTAL NUMBER OF RESIDUALS.                                   
C P....... NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.      
C X....... PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,     
C             OUTPUT = BEST VALUE FOUND).                               
C CALCR... SUBROUTINE FOR COMPUTING RESIDUAL VECTOR.                    
C CALCJ... SUBROUTINE FOR COMPUTING JACOBIAN MATRIX = MATRIX OF FIRST   
C             PARTIALS OF THE RESIDUAL VECTOR.                          
C MXFCAL...MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS             
C ACC .....DESIRED ACCURACY                                             
C                                                                       
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      INTEGER ISTKGT                                                    
      EXTERNAL  DIVSET,  DRN2G, ISTKGT                                  
C DDIVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.               
C  DRN2G... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DR1, IV1, JJ, N1, N2, NF, R1, RD1                     
      INTEGER IVV1,V1,IVD,IVJ,IVNEXT,IVNFCA,IVNFGC,IVR,IVREGD           
      INTEGER IVTOOB,IVNEED,IVREG0                                      
      INTEGER IVM1,VM1                                                  
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NFCALL, NFGCAL, R, REGD, REGD0, TOOBIG, VNEED
      INTEGER ISTAK(1000)                                               
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1),ISTAK(1))                                   
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, R/61/,        
C    1     REGD/67/, REGD0/82/, TOOBIG/2/, VNEED/4/                     
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NFCALL=6, NFGCAL=7, R=61,        
     1           REGD=67, REGD0=82, TOOBIG=2, VNEED=4)                  
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24HDSN2G - N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSN2G - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSN2G -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR('DSN2G - N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSN2G - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSN2G -ACC .LT.0.0',18,3,2)                          
C/                                                                      
       LIV=P+82                                                         
       LV=P*(N+2*P+17)+2*N+105                                          
       IVV1=ISTKGT(LIV,2)                                               
       IVM1=IVV1-1                                                      
       V1=ISTKGT(LV, 4)                                                 
       VM1=V1-1                                                         
       CALL DIVSET(1,ISTAK(IVV1),LIV,LV,DSTAK(V1))                      
      ISTAK(IVM1+21)=0                                                  
      ISTAK(IVM1+17)=MXFCAL                                             
      ISTAK(IVM1+18)=MXFCAL                                             
      ISTAK(IVM1+57)=0                                                  
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      IV1 = ISTAK(IVV1)                                                 
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) ISTAK(IVV1) = 13                                 
      IVNEED=IVM1+VNEED                                                 
      IF (ISTAK(IVV1) .EQ. 13)ISTAK(IVNEED) =ISTAK(IVNEED) + P + N*(P+2)
      CALL  DRN2G(X, DSTAK(V1),ISTAK(IVV1), LIV, LV, N, N, N1, N2, P,   
     1DSTAK(V1),DSTAK(V1),DSTAK(V1), X)                                 
      IF (ISTAK(IVV1) .NE. 14) GO TO 999                                
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IVD=IVM1+D                                                        
      IVNEXT=IVM1+NEXTV                                                 
      ISTAK(IVD) = ISTAK(IVNEXT)                                        
      IVR=IVM1+R                                                        
      ISTAK(IVR) = ISTAK(IVD) + P                                       
      IVREG0=IVM1+REGD0                                                 
      ISTAK(IVREG0) = ISTAK(IVR) + N                                    
      IVJ=IVM1+J                                                        
      ISTAK(IVJ) = ISTAK(IVREG0) + N                                    
      ISTAK(IVNEXT) = ISTAK(IVJ) + N*P                                  
      IVNFCA=IVM1+NFCALL                                                
      IVNFGC=IVM1+NFGCAL                                                
      IVREGD=IVM1+REGD                                                  
      IVTOOB=IVM1+TOOBIG                                                
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = ISTAK(IVD)+VM1                                               
      DR1 = ISTAK(IVJ)+VM1                                              
      R1 = ISTAK(IVR)+VM1                                               
      RD1 = ISTAK(IVREG0)+VM1                                           
C                                                                       
 20   CALL  DRN2G(DSTAK(D1), DSTAK(DR1), ISTAK(IVV1), LIV, LV, N, N,    
     1 N1, N2, P, DSTAK(R1),DSTAK(RD1),DSTAK(V1),X)                     
      IF (ISTAK(IVV1)-2) 30, 50, 999                                    
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = ISTAK(IVNFCA)                                                
      CALL CALCR(N, P, X, NF, DSTAK(R1))                                
      IF (NF .GT. 0) GO TO 40                                           
         ISTAK(IVTOOB) = 1                                              
         GO TO 20                                                       
 40   IF (ISTAK(IVV1) .GT. 0) GO TO 20                                  
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 50   CALL CALCJ(N, P, X, ISTAK(IVNFGC), DSTAK(DR1))                    
      IF (ISTAK(IVNFGC) .EQ. 0) ISTAK(IVTOOB) = 1                       
      GO TO 20                                                          
C                                                                       
C  ***  INDICATE WHETHER THE REGRESSION DIAGNOSTIC ARRAY WAS COMPUTED   
C  ***  AND PRINT IT IF SO REQUESTED...                                 
C                                                                       
C                                                                       
 999  CONTINUE                                                          
      JJ=ISTAK(IVV1)                                                    
      IF(JJ.LT.7) GO TO 80                                              
C/6S                                                                    
C     IF (JJ.EQ.7)CALL SETERR(27HDSN2G -SINGULAR CONVERGENCE,27,4,1)    
C     IF(JJ.EQ.8)CALL SETERR(24HDSN2G -FALSE CONVERGENCE,24,5,1)        
C     IF(JJ.EQ.9)CALL SETERR(32HDSN2G -FUNCTION EVALUATION LIMIT,32,6,1)
C     IF (JJ.EQ.63)                                                     
C    1CALL SETERR(43HDSN2G -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C     IF(JJ.EQ.65)                                                      
C    1CALL SETERR(47HDSN2G -JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,8,1)                                                           
C/7S                                                                    
      IF (JJ.EQ.7)CALL SETERR('DSN2G -SINGULAR CONVERGENCE',27,4,1)     
      IF(JJ.EQ.8)CALL SETERR('DSN2G -FALSE CONVERGENCE',24,5,1)         
      IF(JJ.EQ.9)CALL SETERR('DSN2G -FUNCTION EVALUATION LIMIT',32,6,1) 
      IF (JJ.EQ.63)                                                     
     1CALL SETERR('DSN2G -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
      IF(JJ.EQ.65)                                                      
     1CALL SETERR('DSN2G -JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,8,1)                                                           
C/                                                                      
 80   CALL LEAVE                                                        
      RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    DSN2G FOLLOWS  ***                              
      END                                                               
      SUBROUTINE DSN2GB(N, P, X, B, CALCR, CALCJ, MXFCAL, ACC)          
C                                                                       
C  ***  VERSION OF NL2SOL THAT CALLS DRN2GB ***                         
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV, MXFCAL                                     
      DOUBLE PRECISION X(P), B(2,P), ACC                                
      EXTERNAL CALCR, CALCJ                                             
C                                                                       
C  ***  PARAMETER USAGE  ***                                            
C                                                                       
C N....... TOTAL NUMBER OF RESIDUALS.                                   
C P....... NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.      
C X....... PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,     
C             OUTPUT = BEST VALUE FOUND).                               
C B........2-D WHOSE FIRST ROW GIVES LOWER BOUNDS ON X AND WHOSE        
C          SECOND ROW GIVES UPPER BOUNDS                                
C CALCR... SUBROUTINE FOR COMPUTING RESIDUAL VECTOR.                    
C CALCJ... SUBROUTINE FOR COMPUTING JACOBIAN MATRIX = MATRIX OF FIRST   
C             PARTIALS OF THE RESIDUAL VECTOR.                          
C MXFCAL...MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS             
C ACC .....DESIRED ACCURACY                                             
C                                                                       
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      INTEGER ISTKGT                                                    
      EXTERNAL  DIVSET,  DRN2GB, ISTKGT                                 
C DDIVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.               
C DRN2GB... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DR1, IV1, JJ, N1, N2, NF, R1, RD1                     
      INTEGER IVV1,V1,IVD,IVJ,IVNEXT,IVNFCA,IVNFGC,IVR,IVREGD           
      INTEGER IVTOOB,IVNEED,IVREG0                                      
      INTEGER IVM1,VM1                                                  
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NFCALL, NFGCAL, R, REGD, REGD0, TOOBIG, VNEED
      INTEGER ISTAK(1000)                                               
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1),ISTAK(1))                                   
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, R/61/,        
C    1     REGD/67/, REGD0/82/, TOOBIG/2/, VNEED/4/                     
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NFCALL=6, NFGCAL=7, R=61,        
     1           REGD=67, REGD0=82, TOOBIG=2, VNEED=4)                  
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.1)                                             
C    1CALL SETERR(24HDSN2GB- N.LT.1 OR P.LT.1,24,1,2)                   
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSN2GB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSN2GB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.1)                                             
     1CALL SETERR('DSN2GB- N.LT.1 OR P.LT.1',24,1,2)                    
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSN2GB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSN2GB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
       LIV=4*P+82                                                       
       LV=P*(N+2*P+21)+2*N+105                                          
       IVV1=ISTKGT(LIV,2)                                               
       IVM1=IVV1-1                                                      
       V1=ISTKGT(LV, 4)                                                 
       VM1=V1-1                                                         
       CALL DIVSET(1,ISTAK(IVV1),LIV,LV,DSTAK(V1))                      
      ISTAK(IVM1+21)=0                                                  
      ISTAK(IVM1+17)=MXFCAL                                             
      ISTAK(IVM1+18)=MXFCAL                                             
      ISTAK(IVM1+57)=0                                                  
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      IV1 = ISTAK(IVV1)                                                 
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) ISTAK(IVV1) = 13                                 
      IVNEED=IVM1+VNEED                                                 
      IF (ISTAK(IVV1) .EQ. 13)ISTAK(IVNEED) =ISTAK(IVNEED) + P + N*(P+2)
      CALL  DRN2GB(B,X, DSTAK(V1),ISTAK(IVV1), LIV, LV, N, N, N1, N2, P,
     1DSTAK(V1),DSTAK(V1),DSTAK(V1), X)                                 
      IF (ISTAK(IVV1) .NE. 14) GO TO 999                                
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IVD=IVM1+D                                                        
      IVNEXT=IVM1+NEXTV                                                 
      ISTAK(IVD) = ISTAK(IVNEXT)                                        
      IVR=IVM1+R                                                        
      ISTAK(IVR) = ISTAK(IVD) + P                                       
      IVREG0=IVM1+REGD0                                                 
      ISTAK(IVREG0) = ISTAK(IVR) + N                                    
      IVJ=IVM1+J                                                        
      ISTAK(IVJ) = ISTAK(IVREG0) + N                                    
      ISTAK(IVNEXT) = ISTAK(IVJ) + N*P                                  
      IVNFCA=IVM1+NFCALL                                                
      IVNFGC=IVM1+NFGCAL                                                
      IVREGD=IVM1+REGD                                                  
      IVTOOB=IVM1+TOOBIG                                                
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = ISTAK(IVD)+VM1                                               
      DR1 = ISTAK(IVJ)+VM1                                              
      R1 = ISTAK(IVR)+VM1                                               
      RD1 = ISTAK(IVREG0)+VM1                                           
C                                                                       
 20   CALL  DRN2GB(B,DSTAK(D1), DSTAK(DR1), ISTAK(IVV1), LIV, LV, N, N, 
     1 N1, N2, P, DSTAK(R1),DSTAK(RD1),DSTAK(V1),X)                     
      IF (ISTAK(IVV1)-2) 30, 50, 999                                    
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = ISTAK(IVNFCA)                                                
      CALL CALCR(N, P, X, NF, DSTAK(R1))                                
      IF (NF .GT. 0) GO TO 40                                           
         ISTAK(IVTOOB) = 1                                              
         GO TO 20                                                       
 40   IF (ISTAK(IVV1) .GT. 0) GO TO 20                                  
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 50   CALL CALCJ(N, P, X, ISTAK(IVNFGC), DSTAK(DR1))                    
      IF (ISTAK(IVNFGC) .EQ. 0) ISTAK(IVTOOB) = 1                       
      GO TO 20                                                          
C                                                                       
C  ***  INDICATE WHETHER THE REGRESSION DIAGNOSTIC ARRAY WAS COMPUTED   
C  ***  AND PRINT IT IF SO REQUESTED...                                 
C                                                                       
C                                                                       
 999  CONTINUE                                                          
      JJ=ISTAK(IVV1)                                                    
      IF(JJ.LT.7) GO TO 80                                              
C/6S                                                                    
C     IF (JJ.EQ.82)CALL SETERR(26HDSN2GB-INCONSISTENT BOUNDS,26,4,1)    
C     IF (JJ.EQ.7)CALL SETERR(27HDSN2GB-SINGULAR CONVERGENCE,27,5,1)    
C     IF(JJ.EQ.8)CALL SETERR(24HDSN2GB-FALSE CONVERGENCE,24,6,1)        
C     IF(JJ.EQ.9)CALL SETERR(32HDSN2GB-FUNCTION EVALUATION LIMIT,32,7,1)
C     IF (JJ.EQ.63)                                                     
C    1CALL SETERR(43HDSN2GB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C     IF(JJ.EQ.65)                                                      
C    1CALL SETERR(47HDSN2GB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,9,1)                                                           
C/7S                                                                    
      IF (JJ.EQ.82)CALL SETERR('DSN2GB-INCONSISTENT BOUNDS',26,4,1)     
      IF (JJ.EQ.7)CALL SETERR('DSN2GB-SINGULAR CONVERGENCE',27,5,1)     
      IF(JJ.EQ.8)CALL SETERR('DSN2GB-FALSE CONVERGENCE',24,6,1)         
      IF(JJ.EQ.9)CALL SETERR('DSN2GB-FUNCTION EVALUATION LIMIT',32,7,1) 
      IF (JJ.EQ.63)                                                     
     1CALL SETERR('DSN2GB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
      IF(JJ.EQ.65)                                                      
     1CALL SETERR('DSN2GB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,9,1)                                                           
C/                                                                      
 80   CALL LEAVE                                                        
      RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    DSN2GBFOLLOWS  ***                              
      END                                                               
      SUBROUTINE DC6LCR(N,P,X,NF,R,IU,UR,UF)                            
      INTEGER N,P,IU                                                    
      DOUBLE PRECISION X(P),R(N),UR                                     
      EXTERNAL UF                                                       
      CALL UF(N,P,X,NF,R)                                               
      RETURN                                                            
      END                                                               
      SUBROUTINE  SMNF( P, X, CALCF,   MXFCAL, ACC )                    
C                                                                       
C ** SIMPLIED VERSION OF MNF                                            
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      REAL X(P), ACC                                                    
      EXTERNAL CALCF,   C6LCF                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14H SMNF - P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SMNF - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SMNF -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR(' SMNF - P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SMNF - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SMNF -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59                                                           
      LV=77+P*(P+17)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 3)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/ABS(X(I))                       
 10   CONTINUE                                                          
      CALL  MNF( P, DSTAK(ID),X,  C6LCF,  ISTAK(IV), LIV, LV,           
     1            DSTAK(V1), IU, UR, CALCF)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27H SMNF -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24H SMNF -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32H SMNF -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SMNF -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR(' SMNF -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR(' SMNF -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR(' SMNF -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SMNF -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SMNF  FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  SMNFB( P, X,B, CALCF,   MXFCAL, ACC )                 
C                                                                       
C ** SIMPLIED VERSION OF MNF                                            
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW OF B GIVES LOWER BOUNDS ON X AND SECOND GIVES UPPER    
C      BOUNDS                                                           
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      REAL X(P), ACC ,B(2,P)                                            
      EXTERNAL CALCF,   C6LCF                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14H SMNFB- P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SMNFB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SMNFB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR(' SMNFB- P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SMNFB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SMNFB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59+P                                                         
      LV=77+P*(P+23)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 3)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/ABS(X(I))                       
 10   CONTINUE                                                          
      CALL  MNFB( P, DSTAK(ID),X,B,  C6LCF,  ISTAK(IV), LIV, LV,        
     1            DSTAK(V1), IU, UR, CALCF)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26H SMNFB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27H SMNFB-SINGULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24H SMNFB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32H SMNFB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SMNFB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR(' SMNFB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR(' SMNFB-SINGULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR(' SMNFB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR(' SMNFB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SMNFB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SMNFB FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE C6LCF(P,X,NF,F,IU,UR,UF)                               
      INTEGER P,IU                                                      
      REAL X(P),F,UR                                                    
      EXTERNAL UF                                                       
      CALL UF(P,X,NF,F)                                                 
      RETURN                                                            
      END                                                               
      SUBROUTINE  SMNG( P, X, CALCF, CALCG,   MXFCAL, ACC )             
C                                                                       
C ** SIMPLIED VERSION OF MNG                                            
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCG SUBROUTINE TO EVALUATE THE GRADIENT                             
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      REAL X(P), ACC                                                    
      EXTERNAL CALCF, CALCG                                             
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14H SMNG - P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SMNG - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SMNG -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR(' SMNG - P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SMNG - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SMNG -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59                                                           
      LV=71+P*(P+15)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 3)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/ABS(X(I))                       
 10   CONTINUE                                                          
      CALL  J6MNG( P, DSTAK(ID),X,  CALCF,CALCG,  ISTAK(IV), LIV, LV,   
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27H SMNG -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24H SMNG -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32H SMNG -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SMNG -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C     IF (J.EQ.65)                                                      
C    1CALL SETERR(47H SMNG -GRADIENT CANNOT BE COMPUTED AT INITIAL X,   
C    247,8,1)                                                           
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR(' SMNG -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR(' SMNG -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR(' SMNG -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SMNG -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
      IF (J.EQ.65)                                                      
     1CALL SETERR(' SMNG -GRADIENT CANNOT BE COMPUTED AT INITIAL X',    
     247,8,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SMNG  FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  J6MNG(N, D, X, CALCF, CALCG, IV, LIV, LV, V)          
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING   ***   
C  ***  ANALYTIC GRADIENT AND HESSIAN APPROX. FROM SECANT UPDATE  ***   
C                                                                       
      INTEGER N, LIV, LV                                                
      INTEGER IV(LIV)                                                   
      REAL D(N), X(N), V(LV)                                            
C     DIMENSION V(71 + N*(N+15)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF,CALCG                                              
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL IVSET,  RMNG                                             
C                                                                       
C IVSET... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                  
C  RMNG... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT  J6MNG ALGO-  
C             RITHM.                                                    
C                                                                       
      INTEGER G1, IV1, NF                                               
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NEXTV, NFCALL, NFGCAL, G, TOOBIG, VNEED                   
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, TOOBIG/2/, VNEED/4/  
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, TOOBIG=2, VNEED=4) 
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 12 .OR. IV1 .EQ. 13) IV(VNEED) = IV(VNEED) + N       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  RMNG(D, F, V(G1), IV, LIV, LV, N, V, X)                     
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCG(N, X, NF, V(G1))                                       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   IF (IV(1) .NE. 14) GO TO 60                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(NEXTV) = IV(G) + N                                             
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 60   RETURN                                                            
C  ***  LAST CARD OF  J6MNG FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  SMNGB( P, X,B, CALCF,CALCG,   MXFCAL, ACC )           
C                                                                       
C ** SIMPLIED VERSION OF MNGB                                           
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW OF B GIVES LOWER BOUNDS ON X AND SECOND GIVES UPPER    
C      BOUNDS                                                           
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCG SUBROUTINE TO EVALUATE DERIVATIVE                               
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      REAL X(P), ACC ,B(2,P)                                            
      EXTERNAL CALCF,   CALCG                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14H SMNGB- P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SMNGB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SMNGB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR(' SMNGB- P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SMNGB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SMNGB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59+P                                                         
      LV=71+P*(P+21)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 3)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/ABS(X(I))                       
 10   CONTINUE                                                          
      CALL  M6NGB( P, DSTAK(ID),X,B,  CALCF,CALCG,  ISTAK(IV), LIV, LV, 
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26H SMNGB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27H SMNGB-SINGULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24H SMNGB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32H SMNGB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SMNGB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47H SMNGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,9,1)                                                           
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR(' SMNGB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR(' SMNGB-SINGULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR(' SMNGB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR(' SMNGB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SMNGB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
      IF(J.EQ.65)                                                       
     1CALL SETERR(' SMNGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,9,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SMNGB FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  M6NGB(N, D, X, B, CALCF, CALCG, IV, LIV, LV, V)       
C                                                                       
C  ***  MINIMIZE GENERAL SIMPLY BOUNDED OBJECTIVE FUNCTION USING  ***   
C  ***  ANALYTIC GRADIENT AND HESSIAN APPROX. FROM SECANT UPDATE  ***   
C                                                                       
      INTEGER N, LIV, LV                                                
      INTEGER IV(LIV)                                                   
      REAL D(N), X(N), B(2,N), V(LV)                                    
C     DIMENSION V(71 + N*(N+15)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF, CALCG                                             
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        THIS ROUTINE IS LIKE   MNG, EXCEPT FOR THE EXTRA PARAMETER B,  
C     AN ARRAY OF LOWER AND UPPER BOUNDS ON X...   MNGB ENFORCES THE    
C     CONSTRAINTS THAT  B(1,I) .LE. X(I) .LE. B(2,I), I = 1(1)N.        
C     (INSTEAD OF CALLING  RMNG,   MNGB CALLS  RMNGB.)                  
C.                                                                      
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL IVSET,  RMNGB                                            
C                                                                       
C IVSET.... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                 
C  RMNGB... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT   MNG ALGO-  
C             RITHM.                                                    
C                                                                       
      INTEGER G1, IV1, NF                                               
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NEXTV, NFCALL, NFGCAL, G, TOOBIG, VNEED                   
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, TOOBIG/2/, VNEED/4/  
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, TOOBIG=2, VNEED=4) 
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + N                      
      CALL  RMNGB(B, D, F, V, IV, LIV, LV, N, V, X)                     
      IF (IV(1) .NE. 14) GO TO 50                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(NEXTV) = IV(G) + N                                             
      IF (IV1 .EQ. 13) GO TO 50                                         
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  RMNGB(B, D, F, V(G1), IV, LIV, LV, N, V, X)                 
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCG(N, X, NF, V(G1))                                       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   RETURN                                                            
C  ***  LAST CARD OF  M6NGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  SMNH( P, X, CALCF, CALCGH,   MXFCAL, ACC )            
C                                                                       
C ** SIMPLIED VERSION OF MNH                                            
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCGH SUBROUTINE TO EVALUATE THE GRADIENTAND THE HESSIAN             
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      REAL X(P), ACC                                                    
      EXTERNAL CALCF, CALCGH                                            
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14H SMNH - P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SMNH - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SMNH -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR(' SMNH - P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SMNH - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SMNH -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59                                                           
      LV=78+P*(P+12)                                                    
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 3)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/ABS(X(I))                       
 10   CONTINUE                                                          
      CALL  J6MNH( P, DSTAK(ID),X,  CALCF,CALCGH,  ISTAK(IV), LIV, LV,  
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27H SMNH -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24H SMNH -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32H SMNH -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SMNH -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C     IF (J.EQ.65)                                                      
C    1CALL SETERR(47H SMNH -GRADIENT CANNOT BE COMPUTED AT INITIAL X,   
C    247,8,1)                                                           
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR(' SMNH -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR(' SMNH -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR(' SMNH -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SMNH -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
      IF (J.EQ.65)                                                      
     1CALL SETERR(' SMNH -GRADIENT CANNOT BE COMPUTED AT INITIAL X',    
     247,8,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SMNH  FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE   J6MNH(N, D, X, CALCF, CALCGH, IV, LIV, LV, V)        
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING   ***   
C  ***  (ANALYTIC) GRADIENT AND HESSIAN PROVIDED BY THE CALLER.   ***   
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      REAL D(N), X(N), V(LV)                                            
C     DIMENSION V(78 + N*(N+12)), UIPARM(*), URPARM(*)                  
      EXTERNAL CALCF, CALCGH                                            
C                                                                       
C                                                                       
      EXTERNAL IVSET,  RMNH                                             
C                                                                       
C IVSET... PROVIDES DEFAULT INPUT VALUES FOR IV AND V.                  
C  RMNH... REVERSE-COMMUNICATION ROUTINE THAT DOES   MNH ALGORITHM.     
C                                                                       
      INTEGER G1, H1, IV1, LH, NF                                       
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER G, H, NEXTV, NFCALL, NFGCAL, TOOBIG, VNEED                
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, H/56/, TOOBIG/2/,    
C    1     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, H=56, TOOBIG=2,    
     1           VNEED=4)                                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = N * (N + 1) / 2                                              
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IF (IV(1) .EQ. 12 .OR. IV(1) .EQ. 13)                             
     1     IV(VNEED) = IV(VNEED) + N*(N+3)/2                            
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      H1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
      H1 = IV(H)                                                        
C                                                                       
 20   CALL  RMNH(D, F, V(G1), V(H1), IV, LH, LIV, LV, N, V, X)          
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCGH(N, X, NF, V(G1), V(H1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   IF (IV(1) .NE. 14) GO TO 60                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(H) = IV(G) + N                                                 
      IV(NEXTV) = IV(H) + N*(N+1)/2                                     
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 60   RETURN                                                            
C  ***  LAST CARD OF   J6MNH FOLLOWS  ***                               
      END                                                               
      SUBROUTINE  SMNHB( P, X,B, CALCF,CALCGH,   MXFCAL, ACC )          
C                                                                       
C ** SIMPLIED VERSION OF MNHB                                           
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW OF B GIVES LOWER BOUNDS ON X AND SECOND GIVES UPPER    
C      BOUNDS                                                           
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCGH SUBROUTINE TO EVALUATE FIRST AND SECOND DERIVATIVES            
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      REAL X(P), ACC ,B(2,P)                                            
      EXTERNAL CALCF,   CALCGH                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      REAL DSTAK(1000)                                                  
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14H SMNHB- P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19H SMNHB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SMNHB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR(' SMNHB- P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR(' SMNHB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SMNHB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59+3*P                                                       
      LV=78+P*(P+15)                                                    
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 3)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/ABS(X(I))                       
 10   CONTINUE                                                          
      CALL  M6NHB( P, DSTAK(ID),X,B,  CALCF,CALCGH, ISTAK(IV), LIV, LV, 
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26H SMNHB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27H SMNHB-SINHULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24H SMNHB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32H SMNHB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SMNHB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47H SMNHB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,9,1)                                                           
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR(' SMNHB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR(' SMNHB-SINHULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR(' SMNHB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR(' SMNHB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SMNHB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
      IF(J.EQ.65)                                                       
     1CALL SETERR(' SMNHB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,9,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SMNHB FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  M6NHB(N, D, X, B, CALCF, CALCGH, IV, LIV, LV, V)      
C                                                                       
C  ***  MINIMIZE GENERAL SIMPLY BOUNDED OBJECTIVE FUNCTION USING   ***  
C  ***  (ANALYTIC) GRADIENT AND HESSIAN PROVIDED BY THE CALLER.    ***  
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      REAL B(2,N), D(N), X(N), V(LV)                                    
C     DIMENSION V(78 + N*(N+12))                                        
      EXTERNAL CALCF, CALCGH                                            
C                                                                       
C------------------------------  DISCUSSION  ---------------------------
C                                                                       
C        THIS ROUTINE IS LIKE   MNGB, EXCEPT THAT THE SUBROUTINE PARA-  
C     METER CALCG OF   MNGB (WHICH COMPUTES THE GRADIENT OF THE OBJEC-  
C     TIVE FUNCTION) IS REPLACED BY THE SUBROUTINE PARAMETER CALCGH,    
C     WHICH COMPUTES BOTH THE GRADIENT AND (LOWER TRIANGLE OF THE)      
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL IVSET,  RMNHB                                            
C                                                                       
C IVSET.... PROVIDES DEFAULT INPUT VALUES FOR IV AND V.                 
C  RMNHB... REVERSE-COMMUNICATION ROUTINE THAT DOES   MNHB ALGORITHM.   
C                                                                       
      INTEGER G1, H1, IV1, LH, NF                                       
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER G, H, NEXTV, NFCALL, NFGCAL, TOOBIG, VNEED                
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, H/56/, TOOBIG/2/,    
C    1     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, H=56, TOOBIG=2,    
     1           VNEED=4)                                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = N * (N + 1) / 2                                              
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + N*(N+3)/2              
      CALL  RMNHB(B, D, F, V, V, IV, LH, LIV, LV, N, V, X)              
      IF (IV(1) .NE. 14) GO TO 50                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(H) = IV(G) + N                                                 
      IV(NEXTV) = IV(H) + N*(N+1)/2                                     
      IF (IV1 .EQ. 13) GO TO 50                                         
C                                                                       
 10   G1 = IV(G)                                                        
      H1 = IV(H)                                                        
C                                                                       
 20   CALL  RMNHB(B, D, F, V(G1), V(H1), IV, LH, LIV, LV, N, V, X)      
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCGH(N, X, NF, V(G1), V(H1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   RETURN                                                            
C  ***  LAST CARD OF  M6NHB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  SNSF(N, P,L, X,C,Y, CALCA,INC,IINC,   MXFCAL, ACC )   
C                                                                       
C ** SIMPLIED VERSION OF  NSF                                           
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE RESIDUAL                                 
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      REAL X(P), ACC  ,Y(N), C(L)                                       
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA,   C6LCA                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      REAL DSTAK(1000)                                                  
      INTEGER ISTAK(1000)                                               
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34H SNSF - N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16H SNSF -IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19H SNSF - MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SNSF -ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR(' SNSF - N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR(' SNSF -IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR(' SNSF - MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SNSF -ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33H SNSF - INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR(' SNSF - INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 122+2*M+4*P+2*L+MAX0(LP1,6*P)                               
      LV = 105+P*(2*P+18)+2*N*(L+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  NSF(N, P,L, X,C,Y,  C6LCA,INC,IINC,                         
     1  ISTAK(IV), LIV, LV,                                             
     1            DSTAK(V1), IU, UR, CALCA)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27H SNSF -SINGULAR CONVERGENCE,27,6,1)     
C     IF(J.EQ.8)CALL SETERR(24H SNSF -FALSE CONVERGENCE,24,7,1)         
C     IF(J.EQ.9)CALL SETERR(32H SNSF -FUNCTION EVALUATION LIMIT,32,8,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SNSF -F(X) CANNOT BE COMPUTED AT INITIAL X,43,9,1)
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR(' SNSF -SINGULAR CONVERGENCE',27,6,1)      
      IF(J.EQ.8)CALL SETERR(' SNSF -FALSE CONVERGENCE',24,7,1)          
      IF(J.EQ.9)CALL SETERR(' SNSF -FUNCTION EVALUATION LIMIT',32,8,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SNSF -F(X) CANNOT BE COMPUTED AT INITIAL X',43,9,1) 
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SNSF  FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  SNSG(N, P,L, X,C,Y, CALCA,CALCB,                      
     1INC,IINC,   MXFCAL, ACC )                                         
C                                                                       
C ** SIMPLIED VERSION OF  NSG                                           
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE  THE A MATRIX                            
C CALCB SUBROUTINE TO COMPUTE THE DERIVATIVES OF A                      
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      REAL X(P), ACC , C(L), Y(N)                                       
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA                                                    
      EXTERNAL CALCB                                                    
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      REAL DSTAK(1000)                                                  
      INTEGER ISTAK(1000)                                               
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34H SNSG - N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16H SNSG -IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19H SNSG - MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SNSG -ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR(' SNSG - N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR(' SNSG -IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR(' SNSG - MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SNSG -ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33H SNSG - INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR(' SNSG - INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 115+P+L+2*M                                                 
      LV = 105+P*(2*P+17)+N*(L+M+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  J6NSG(N, P,L, X,C,Y,  CALCA,CALCB,INC,IINC,                 
     1  ISTAK(IV), LIV, LV,DSTAK(V1))                                   
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27H SNSG -SINGULAR CONVERGENCE,27,6,1)     
C     IF(J.EQ.8)CALL SETERR(24H SNSG -FALSE CONVERGENCE,24,7,1)         
C     IF(J.EQ.9)CALL SETERR(32H SNSG -FUNCTION EVALUATION LIMIT,32,8,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SNSG -A(X) CANNOT BE COMPUTED AT INITIAL X,43,9,1)
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47H SNSG -JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    2 47,10,1)                                                         
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR(' SNSG -SINGULAR CONVERGENCE',27,6,1)      
      IF(J.EQ.8)CALL SETERR(' SNSG -FALSE CONVERGENCE',24,7,1)          
      IF(J.EQ.9)CALL SETERR(' SNSG -FUNCTION EVALUATION LIMIT',32,8,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SNSG -A(X) CANNOT BE COMPUTED AT INITIAL X',43,9,1) 
      IF(J.EQ.65)                                                       
     1CALL SETERR(' SNSG -JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     2 47,10,1)                                                         
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SNSG  FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  J6NSG(N, P, L, ALF, C, Y, CALCA, CALCB, INC, IINC, IV,
     1                  LIV, LV, V)                                     
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING  ***              
C  ***  ANALYTICALLY COMPUTED DERIVATIVES.             ***              
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
      INTEGER INC(IINC,P), IV(LIV)                                      
      REAL ALF(P), C(L), V(LV), Y(N)                                    
      EXTERNAL CALCA, CALCB                                             
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),    NSG ATTEMPTS TO COMPUTE A LEAST SQUARES FIT           
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )).                       
C                       I=1    I             I                          
C                                                                       
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,   RNSG                                            
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V VALUES.                           
C   RNSG... CARRIES OUT NL2SOL ALGORITHM.                               
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER A1, DA1, I, IN1, IV1, K, L1, LP1, M, M0, NF               
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, D, DAMAT, IN, IVNEED, J, L1SAV, MSAVE, NEXTIV,      
     1        NEXTV, NFCALL, NFGCAL, PERM, R, TOOBIG, VNEED             
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, D/27/, DAMAT/114/, IN/112/, IVNEED/3/, J/70/,     
C    1     L1SAV/111/, MSAVE/115/, NEXTIV/46/, NEXTV/47/, NFCALL/6/,    
C    2     NFGCAL/7/, PERM/58/, R/61/, TOOBIG/2/, VNEED/4/              
C/7                                                                     
      PARAMETER (AMAT=113, D=27, DAMAT=114, IN=112, IVNEED=3, J=70,     
     1           L1SAV=111, MSAVE=115, NEXTIV=46, NEXTV=47, NFCALL=6,   
     2           NFGCAL=7, PERM=58, R=61, TOOBIG=2, VNEED=4)            
C/                                                                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 50             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 90                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 90                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 60                                       
      IF (IV(PERM) .LE. MSAVE) IV(PERM) = MSAVE + 1                     
      LP1 = L + 1                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
C                                                                       
      IV(IVNEED) = IV(IVNEED) + 2*M                                     
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + N*(L1+M)                                  
      GO TO 60                                                          
C                                                                       
 50   IV(1) = 66                                                        
C                                                                       
 60   CALL   RNSG(V, ALF, C, V, IV, IV, L, 1, N, LIV, LV, N, M, P, V, Y)
      IF (IV(1) .NE. 14) GO TO 130                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(NEXTIV) = IV(IN) + 2*M                                         
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(NEXTV) = IV(DAMAT) + N*M                                       
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  SET UP IN ARRAY  ***                                            
C                                                                       
      IN1 = IV(IN)                                                      
      DO 80 I = 1, P                                                    
         DO 70 K = 1, LP1                                               
            IF (INC(K,I) .EQ. 0) GO TO 70                               
               IV(IN1) = I                                              
               IV(IN1+1) = K                                            
               IN1 = IN1 + 2                                            
 70         CONTINUE                                                    
 80      CONTINUE                                                       
      IF (IV1 .EQ. 13) GO TO 130                                        
C                                                                       
 90   A1 = IV(AMAT)                                                     
      DA1 = IV(DAMAT)                                                   
      IN1 = IV(IN)                                                      
      L1 = IV(L1SAV)                                                    
      M = IV(MSAVE)                                                     
C                                                                       
 100  CALL   RNSG(V(A1), ALF, C, V(DA1), IV(IN1), IV, L, L1, N, LIV, LV,
     1            N, M, P, V, Y)                                        
      IF (IV(1)-2) 110, 120, 130                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 110  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF, NF, V(A1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 100                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 120  CALL CALCB(N, P, L, ALF,  IV(NFGCAL),V(DA1))                      
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 100                                                         
C                                                                       
 130  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    NSG FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  SNSFB(N, P,L, X,B,C,Y, CALCA,INC,IINC,MXFCAL, ACC )   
C                                                                       
C ** SIMPLIED VERSION OF  NSFB                                          
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C B    FIRST ROW GIVES LOWER BOUNDS ON X, SECOND ROW GIVES UPPOER BOUNDS
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE RESIDUAL                                 
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      REAL X(P), ACC , B(2,P), C(L), Y(N)                               
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA,   C6LCA                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      REAL DSTAK(1000)                                                  
      INTEGER ISTAK(1000)                                               
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34H SNSFB- N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16H SNSFB-IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19H SNSFB- MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SNSFB-ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR(' SNSFB- N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR(' SNSFB-IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR(' SNSFB- MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SNSFB-ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33H SNSFB- INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR(' SNSFB- INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 122+2*M+4*P+2*L+MAX0(LP1,6*P)+3*P                           
      LV = 105+P*(2*P+22)+2*N*(L+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  NSFB(N, P,L, X,B,C,Y,  C6LCA,INC,IINC,                      
     1  ISTAK(IV), LIV, LV,                                             
     1            DSTAK(V1), IU, UR, CALCA)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26H SNSFB-INCONSISTENT BOUNDS,26,6,1)     
C     IF (J.EQ.7)CALL SETERR(27H SNSFB-SINGULAR CONVERGENCE,27,7,1)     
C     IF(J.EQ.8)CALL SETERR(24H SNSFB-FALSE CONVERGENCE,24,8,1)         
C     IF(J.EQ.9)CALL SETERR(32H SNSFB-FUNCTION EVALUATION LIMIT,32,9,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SNSFB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,10, 
C    21)                                                                
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR(' SNSFB-INCONSISTENT BOUNDS',26,6,1)      
      IF (J.EQ.7)CALL SETERR(' SNSFB-SINGULAR CONVERGENCE',27,7,1)      
      IF(J.EQ.8)CALL SETERR(' SNSFB-FALSE CONVERGENCE',24,8,1)          
      IF(J.EQ.9)CALL SETERR(' SNSFB-FUNCTION EVALUATION LIMIT',32,9,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SNSFB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,10,  
     21)                                                                
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SNSFB FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE C6LCA(N,P,L,X,NF,A,IU,UR,UF)                           
      INTEGER N,P,IU                                                    
      REAL X(P),A(N,L),UR                                               
      EXTERNAL UF                                                       
      CALL UF(N,P,L,X,NF,A)                                             
      RETURN                                                            
      END                                                               
      SUBROUTINE  SNSGB(N, P,L, X,B,C,Y, CALCA,CALCB,                   
     1INC,IINC,   MXFCAL, ACC )                                         
C                                                                       
C ** SIMPLIED VERSION OF  NSGB                                          
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C B    FIRST ROW GIVES LOWER BOUNDS ON X. THE SECOND GIVES UPPER BOUNDS 
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE  THE A MATRIX                            
C CALCB SUBROUTINE TO COMPUTE THE DERIVATIVES OF A                      
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      REAL X(P), ACC ,B(2,P), C(L), Y(N)                                
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA                                                    
      EXTERNAL CALCB                                                    
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      REAL DSTAK(1000)                                                  
      INTEGER ISTAK(1000)                                               
      COMMON /CSTAK/ DSTAK                                              
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34H SNSGB- N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16H SNSGB-IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19H SNSGB- MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0)                                                   
C    1CALL SETERR(18H SNSGB-ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR(' SNSGB- N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR(' SNSGB-IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR(' SNSGB- MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0)                                                   
     1CALL SETERR(' SNSGB-ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33H SNSGB- INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR(' SNSGB- INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 115+P+L+2*M+3*P                                             
      LV = 105+P*(2*P+21)+N*(L+M+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 3)                                                  
      CALL IVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                          
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56) =0                                                   
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  N6SGB(N, P,L, X,B,C,Y,  CALCA,CALCB,INC,IINC,               
     1  ISTAK(IV), LIV, LV,DSTAK(V1))                                   
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26H SNSGB-INCONSISTENT BOUNDS,26,6,1)     
C     IF (J.EQ.7)CALL SETERR(27H SNSGB-SINGULAR CONVERGENCE,27,7,1)     
C     IF(J.EQ.8)CALL SETERR(24H SNSGB-FALSE CONVERGENCE,24,8,1)         
C     IF(J.EQ.9)CALL SETERR(32H SNSGB-FUNCTION EVALUATION LIMIT,32,9,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43H SNSGB-A(X) CANNOT BE COMPUTED AT INITIAL X,43,10, 
C    21)                                                                
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47H SNSGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    2 47,11,1)                                                         
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR(' SNSGB-INCONSISTENT BOUNDS',26,6,1)      
      IF (J.EQ.7)CALL SETERR(' SNSGB-SINGULAR CONVERGENCE',27,7,1)      
      IF(J.EQ.8)CALL SETERR(' SNSGB-FALSE CONVERGENCE',24,8,1)          
      IF(J.EQ.9)CALL SETERR(' SNSGB-FUNCTION EVALUATION LIMIT',32,9,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR(' SNSGB-A(X) CANNOT BE COMPUTED AT INITIAL X',43,10,  
     21)                                                                
      IF(J.EQ.65)                                                       
     1CALL SETERR(' SNSGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     2 47,11,1)                                                         
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  SNSGB FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  N6SGB(N,P,L,ALF,B,C,Y,CALCA,CALCB,INC,IINC,IV,        
     1                  LIV, LV, V)                                     
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING  ***              
C  ***  ANALYTICALLY COMPUTED DERIVATIVES.             ***              
C *** BOUNDS ON NONLINEAR PARAMETERS                                    
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
      INTEGER INC(IINC,P), IV(LIV)                                      
      REAL ALF(P), C(L), V(LV), Y(N), B(2,P)                            
      EXTERNAL CALCA, CALCB                                             
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),    NSGBATTEMPTS TO COMPUTE A LEAST SQUARES FIT           
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )).                       
C                       I=1    I             I                          
C                                                                       
C SUBJECT TO SIMPLE BOUND CONSTRAINTS B(1,I).LE.X(I).LE.B(2,I)          
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,   RNSGB                                           
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V VALUES.                           
C   RNSG... CARRIES OUT NL2SOL ALGORITHM.                               
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER A1, DA1, I, IN1, IV1, K, L1, LP1, M, M0, NF               
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, D, DAMAT, IN, IVNEED, J, L1SAV, MSAVE, NEXTIV,      
     1        NEXTV, NFCALL, NFGCAL, PERM, R, TOOBIG, VNEED             
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, D/27/, DAMAT/114/, IN/112/, IVNEED/3/, J/70/,     
C    1     L1SAV/111/, MSAVE/115/, NEXTIV/46/, NEXTV/47/, NFCALL/6/,    
C    2     NFGCAL/7/, PERM/58/, R/61/, TOOBIG/2/, VNEED/4/              
C/7                                                                     
      PARAMETER (AMAT=113, D=27, DAMAT=114, IN=112, IVNEED=3, J=70,     
     1           L1SAV=111, MSAVE=115, NEXTIV=46, NEXTV=47, NFCALL=6,   
     2           NFGCAL=7, PERM=58, R=61, TOOBIG=2, VNEED=4)            
C/                                                                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 50             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 90                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 90                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 60                                       
      IF (IV(PERM) .LE. MSAVE) IV(PERM) = MSAVE + 1                     
      LP1 = L + 1                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
C                                                                       
      IV(IVNEED) = IV(IVNEED) + 2*M                                     
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + N*(L1+M)                                  
      GO TO 60                                                          
C                                                                       
 50   IV(1) = 66                                                        
C                                                                       
 60   CALL   RNSGB(V,ALF,B,C,V,IV,IV,L,1,N,LIV,LV,N,M,P,V,Y)            
      IF (IV(1) .NE. 14) GO TO 130                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(NEXTIV) = IV(IN) + 2*M                                         
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(NEXTV) = IV(DAMAT) + N*M                                       
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  SET UP IN ARRAY  ***                                            
C                                                                       
      IN1 = IV(IN)                                                      
      DO 80 I = 1, P                                                    
         DO 70 K = 1, LP1                                               
            IF (INC(K,I) .EQ. 0) GO TO 70                               
               IV(IN1) = I                                              
               IV(IN1+1) = K                                            
               IN1 = IN1 + 2                                            
 70         CONTINUE                                                    
 80      CONTINUE                                                       
      IF (IV1 .EQ. 13) GO TO 130                                        
C                                                                       
 90   A1 = IV(AMAT)                                                     
      DA1 = IV(DAMAT)                                                   
      IN1 = IV(IN)                                                      
      L1 = IV(L1SAV)                                                    
      M = IV(MSAVE)                                                     
C                                                                       
 100  CALL   RNSGB(V(A1),ALF,B,C,V(DA1),IV(IN1),IV,L,L1,N,LIV,LV,       
     1            N, M, P, V, Y)                                        
      IF (IV(1)-2) 110, 120, 130                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 110  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF,  NF,V(A1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 100                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 120  CALL CALCB(N, P, L, ALF, IV(NFGCAL), V(DA1))                      
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 100                                                         
C                                                                       
 130  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    NSGBFOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DSMNF( P, X, CALCF,   MXFCAL, ACC )                   
C                                                                       
C ** SIMPLIED VERSION OF DMNF                                           
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      DOUBLE PRECISION X(P), ACC                                        
      EXTERNAL CALCF,   DC6LCF                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      DOUBLE PRECISION UR                                               
      INTEGER IDI,IDM1,ID,J                                             
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14HDSMNF - P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSMNF - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSMNF -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR('DSMNF - P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSMNF - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSMNF -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59                                                           
      LV=77+P*(P+17)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 4)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/DABS(X(I))                      
 10   CONTINUE                                                          
      CALL DMNF( P, DSTAK(ID),X,  DC6LCF,  ISTAK(IV), LIV, LV,          
     1            DSTAK(V1), IU, UR, CALCF)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27HDSMNF -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSMNF -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSMNF -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSMNF -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR('DSMNF -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR('DSMNF -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR('DSMNF -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSMNF -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSMNF  FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DSMNFB( P, X,B, CALCF,   MXFCAL, ACC )                
C                                                                       
C ** SIMPLIED VERSION OF DMNF                                           
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW OF B GIVES LOWER BOUNDS ON X AND SECOND GIVES UPPER    
C      BOUNDS                                                           
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      DOUBLE PRECISION X(P), ACC ,B(2,P)                                
      EXTERNAL CALCF,   DC6LCF                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      DOUBLE PRECISION UR                                               
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14HDSMNFB- P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSMNFB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSMNFB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR('DSMNFB- P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSMNFB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSMNFB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59+P                                                         
      LV=77+P*(P+23)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 4)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/DABS(X(I))                      
 10   CONTINUE                                                          
      CALL DMNFB( P, DSTAK(ID),X,B,  DC6LCF,  ISTAK(IV), LIV, LV,       
     1            DSTAK(V1), IU, UR, CALCF)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26HDSMNFB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27HDSMNFB-SINGULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSMNFB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSMNFB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSMNFB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR('DSMNFB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR('DSMNFB-SINGULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR('DSMNFB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR('DSMNFB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSMNFB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSMNFB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE DC6LCF(P,X,NF,F,IU,UR,UF)                              
      INTEGER P,IU                                                      
      DOUBLE PRECISION X(P),F,UR                                        
      EXTERNAL UF                                                       
      CALL UF(P,X,NF,F)                                                 
      RETURN                                                            
      END                                                               
      SUBROUTINE  DSMNG( P, X, CALCF, CALCG,   MXFCAL, ACC )            
C                                                                       
C ** SIMPLIED VERSION OF DMNG                                           
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCG SUBROUTINE TO EVALUATE THE GRADIENT                             
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      DOUBLE PRECISION X(P), ACC                                        
      EXTERNAL CALCF, CALCG                                             
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14HDSMNG - P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSMNG - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSMNG -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR('DSMNG - P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSMNG - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSMNG -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59                                                           
      LV=71+P*(P+15)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 4)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/DABS(X(I))                      
 10   CONTINUE                                                          
      CALL DJ6MNG( P, DSTAK(ID),X,  CALCF,CALCG,  ISTAK(IV), LIV, LV,   
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27HDSMNG -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSMNG -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSMNG -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSMNG -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C     IF (J.EQ.65)                                                      
C    1CALL SETERR(47HDSMNG -GRADIENT CANNOT BE COMPUTED AT INITIAL X,   
C    247,8,1)                                                           
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR('DSMNG -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR('DSMNG -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR('DSMNG -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSMNG -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
      IF (J.EQ.65)                                                      
     1CALL SETERR('DSMNG -GRADIENT CANNOT BE COMPUTED AT INITIAL X',    
     247,8,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSMNG  FOLLOWS  ***                                
      END                                                               
      SUBROUTINE DJ6MNG(N, D, X, CALCF, CALCG, IV, LIV, LV, V)          
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING   ***   
C  ***  ANALYTIC GRADIENT AND HESSIAN APPROX. FROM SECANT UPDATE  ***   
C                                                                       
      INTEGER N, LIV, LV                                                
      INTEGER IV(LIV)                                                   
      DOUBLE PRECISION D(N), X(N), V(LV)                                
C     DIMENSION V(71 + N*(N+15)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF,CALCG                                              
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL DIVSET,  DRMNG                                           
C                                                                       
C DIVSET... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                 
C  DRMNG... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT DJ6MNG ALGO- 
C             RITHM.                                                    
C                                                                       
      INTEGER G1, IV1, NF                                               
      DOUBLE PRECISION F                                                
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NEXTV, NFCALL, NFGCAL, G, TOOBIG, VNEED                   
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, TOOBIG/2/, VNEED/4/  
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, TOOBIG=2, VNEED=4) 
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IF (IV(1) .EQ. 0) CALL DIVSET(2, IV, LIV, LV, V)                  
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 12 .OR. IV1 .EQ. 13) IV(VNEED) = IV(VNEED) + N       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  DRMNG(D, F, V(G1), IV, LIV, LV, N, V, X)                    
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCG(N, X, NF, V(G1))                                       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   IF (IV(1) .NE. 14) GO TO 60                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(NEXTV) = IV(G) + N                                             
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 60   RETURN                                                            
C  ***  LAST CARD OF DJ6MNG FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DSMNGB( P, X,B, CALCF,CALCG,   MXFCAL, ACC )          
C                                                                       
C ** SIMPLIED VERSION OF DMNGB                                          
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW OF B GIVES LOWER BOUNDS ON X AND SECOND GIVES UPPER    
C      BOUNDS                                                           
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCG SUBROUTINE TO EVALUATE DERIVATIVE                               
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      DOUBLE PRECISION X(P), ACC ,B(2,P)                                
      EXTERNAL CALCF,   CALCG                                           
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14HDSMNGB- P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSMNGB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSMNGB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR('DSMNGB- P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSMNGB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSMNGB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59+P                                                         
      LV=71+P*(P+21)/2                                                  
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 4)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/DABS(X(I))                      
 10   CONTINUE                                                          
      CALL DM6NGB( P, DSTAK(ID),X,B,  CALCF,CALCG,  ISTAK(IV), LIV, LV, 
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26HDSMNGB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27HDSMNGB-SINGULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSMNGB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSMNGB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSMNGB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47HDSMNGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,9,1)                                                           
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR('DSMNGB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR('DSMNGB-SINGULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR('DSMNGB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR('DSMNGB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSMNGB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
      IF(J.EQ.65)                                                       
     1CALL SETERR('DSMNGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,9,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSMNGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE DM6NGB(N, D, X, B, CALCF, CALCG, IV, LIV, LV, V)       
C                                                                       
C  ***  MINIMIZE GENERAL SIMPLY BOUNDED OBJECTIVE FUNCTION USING  ***   
C  ***  ANALYTIC GRADIENT AND HESSIAN APPROX. FROM SECANT UPDATE  ***   
C                                                                       
      INTEGER N, LIV, LV                                                
      INTEGER IV(LIV)                                                   
      DOUBLE PRECISION D(N), X(N), B(2,N), V(LV)                        
C     DIMENSION V(71 + N*(N+15)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF, CALCG                                             
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        THIS ROUTINE IS LIKE  DMNG, EXCEPT FOR THE EXTRA PARAMETER B,  
C     AN ARRAY OF LOWER AND UPPER BOUNDS ON X...  DMNGB ENFORCES THE    
C     CONSTRAINTS THAT  B(1,I) .LE. X(I) .LE. B(2,I), I = 1(1)N.        
C     (INSTEAD OF CALLING  DRMNG,  DMNGB CALLS  DRMNGB.)                
C.                                                                      
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL DIVSET,  DRMNGB                                          
C                                                                       
C DIVSET.... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                
C  DRMNGB... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT  DMNG ALGO- 
C             RITHM.                                                    
C                                                                       
      INTEGER G1, IV1, NF                                               
      DOUBLE PRECISION F                                                
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NEXTV, NFCALL, NFGCAL, G, TOOBIG, VNEED                   
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, TOOBIG/2/, VNEED/4/  
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, TOOBIG=2, VNEED=4) 
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IF (IV(1) .EQ. 0) CALL DIVSET(2, IV, LIV, LV, V)                  
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + N                      
      CALL  DRMNGB(B, D, F, V, IV, LIV, LV, N, V, X)                    
      IF (IV(1) .NE. 14) GO TO 50                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(NEXTV) = IV(G) + N                                             
      IF (IV1 .EQ. 13) GO TO 50                                         
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  DRMNGB(B, D, F, V(G1), IV, LIV, LV, N, V, X)                
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCG(N, X, NF, V(G1))                                       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   RETURN                                                            
C  ***  LAST CARD OF DM6NGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DSMNH( P, X, CALCF, CALCGH,   MXFCAL, ACC )           
C                                                                       
C ** SIMPLIED VERSION OF DMNH                                           
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCGH SUBROUTINE TO EVALUATE THE GRADIENTAND THE HESSIAN             
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      DOUBLE PRECISION X(P), ACC                                        
      EXTERNAL CALCF, CALCGH                                            
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14HDSMNH - P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSMNH - MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSMNH -ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR('DSMNH - P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSMNH - MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSMNH -ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59                                                           
      LV=78+P*(P+12)                                                    
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 4)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/DABS(X(I))                      
 10   CONTINUE                                                          
      CALL DJ6MNH( P, DSTAK(ID),X,  CALCF,CALCGH,  ISTAK(IV), LIV, LV,  
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27HDSMNH -SINGULAR CONVERGENCE,27,4,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSMNH -FALSE CONVERGENCE,24,5,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSMNH -FUNCTION EVALUATION LIMIT,32,6,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSMNH -F(X) CANNOT BE COMPUTED AT INITIAL X,43,7,1)
C     IF (J.EQ.65)                                                      
C    1CALL SETERR(47HDSMNH -GRADIENT CANNOT BE COMPUTED AT INITIAL X,   
C    247,8,1)                                                           
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR('DSMNH -SINGULAR CONVERGENCE',27,4,1)      
      IF(J.EQ.8)CALL SETERR('DSMNH -FALSE CONVERGENCE',24,5,1)          
      IF(J.EQ.9)CALL SETERR('DSMNH -FUNCTION EVALUATION LIMIT',32,6,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSMNH -F(X) CANNOT BE COMPUTED AT INITIAL X',43,7,1) 
      IF (J.EQ.65)                                                      
     1CALL SETERR('DSMNH -GRADIENT CANNOT BE COMPUTED AT INITIAL X',    
     247,8,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSMNH  FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DJ6MNH(N, D, X, CALCF, CALCGH, IV, LIV, LV, V)        
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING   ***   
C  ***  (ANALYTIC) GRADIENT AND HESSIAN PROVIDED BY THE CALLER.   ***   
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      DOUBLE PRECISION D(N), X(N), V(LV)                                
C     DIMENSION V(78 + N*(N+12)), UIPARM(*), URPARM(*)                  
      EXTERNAL CALCF, CALCGH                                            
C                                                                       
C                                                                       
      EXTERNAL DIVSET,  DRMNH                                           
C                                                                       
C DIVSET... PROVIDES DEFAULT INPUT VALUES FOR IV AND V.                 
C  DRMNH... REVERSE-COMMUNICATION ROUTINE THAT DOES  DMNH ALGORITHM.    
C                                                                       
      INTEGER G1, H1, IV1, LH, NF                                       
      DOUBLE PRECISION F                                                
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER G, H, NEXTV, NFCALL, NFGCAL, TOOBIG, VNEED                
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, H/56/, TOOBIG/2/,    
C    1     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, H=56, TOOBIG=2,    
     1           VNEED=4)                                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = N * (N + 1) / 2                                              
      IF (IV(1) .EQ. 0) CALL DIVSET(2, IV, LIV, LV, V)                  
      IF (IV(1) .EQ. 12 .OR. IV(1) .EQ. 13)                             
     1     IV(VNEED) = IV(VNEED) + N*(N+3)/2                            
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      H1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
      H1 = IV(H)                                                        
C                                                                       
 20   CALL  DRMNH(D, F, V(G1), V(H1), IV, LH, LIV, LV, N, V, X)         
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCGH(N, X, NF, V(G1), V(H1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   IF (IV(1) .NE. 14) GO TO 60                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(H) = IV(G) + N                                                 
      IV(NEXTV) = IV(H) + N*(N+1)/2                                     
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 60   RETURN                                                            
C  ***  LAST CARD OF  DJ6MNH FOLLOWS  ***                               
      END                                                               
      SUBROUTINE  DSMNHB( P, X,B, CALCF,CALCGH,   MXFCAL, ACC )         
C                                                                       
C ** SIMPLIED VERSION OF DMNHB                                          
C                                                                       
C INPUT PARAMETERS                                                      
C P    NUMBER OF UNKNOWNS                                               
C X    APPROXIMATE SOLUTION                                             
C B    FIRST ROW OF B GIVES LOWER BOUNDS ON X AND SECOND GIVES UPPER    
C      BOUNDS                                                           
C CALCF SUBROUTINE TO EVALUATE FUNCTION                                 
C CALCGH SUBROUTINE TO EVALUATE FIRST AND SECOND DERIVATIVES            
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
      INTEGER  P, MXFCAL                                                
      DOUBLE PRECISION X(P), ACC ,B(2,P)                                
      EXTERNAL CALCF,   CALCGH                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      INTEGER IDI,IDM1,ID,J                                             
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (P.LT.1)                                                       
C    1CALL SETERR(14HDSMNHB- P.LT.1,14,1,2)                             
C     IF (MXFCAL.LT.1)                                                  
C    1CALL SETERR(19HDSMNHB- MXFCAL.LT.1,19,2,2)                        
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSMNHB-ACC .LT.0.0,18,3,2)                         
C/7S                                                                    
      IF (P.LT.1)                                                       
     1CALL SETERR('DSMNHB- P.LT.1',14,1,2)                              
      IF (MXFCAL.LT.1)                                                  
     1CALL SETERR('DSMNHB- MXFCAL.LT.1',19,2,2)                         
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSMNHB-ACC .LT.0.0',18,3,2)                          
C/                                                                      
      LIV =59+3*P                                                       
      LV=78+P*(P+15)                                                    
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(2,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      ID=ISTKGT(P, 4)                                                   
      IDM1=ID-1                                                         
      DO 10 I=1,P                                                       
         IDI=IDM1+I                                                     
         DSTAK(IDI)=1.0                                                 
         IF (X(I).NE.0.0)DSTAK(IDI)=1.0/DABS(X(I))                      
 10   CONTINUE                                                          
      CALL DM6NHB( P, DSTAK(ID),X,B,  CALCF,CALCGH, ISTAK(IV), LIV, LV, 
     1            DSTAK(V1))                                            
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 20                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26HDSMNHB-INCONSISTENT BOUNDS,26,4,1)     
C     IF (J.EQ.7)CALL SETERR(27HDSMNHB-SINHULAR CONVERGENCE,27,5,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSMNHB-FALSE CONVERGENCE,24,6,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSMNHB-FUNCTION EVALUATION LIMIT,32,7,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSMNHB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,8,1)
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47HDSMNHB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    247,9,1)                                                           
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR('DSMNHB-INCONSISTENT BOUNDS',26,4,1)      
      IF (J.EQ.7)CALL SETERR('DSMNHB-SINHULAR CONVERGENCE',27,5,1)      
      IF(J.EQ.8)CALL SETERR('DSMNHB-FALSE CONVERGENCE',24,6,1)          
      IF(J.EQ.9)CALL SETERR('DSMNHB-FUNCTION EVALUATION LIMIT',32,7,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSMNHB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,8,1) 
      IF(J.EQ.65)                                                       
     1CALL SETERR('DSMNHB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     247,9,1)                                                           
C/                                                                      
 20   CALL LEAVE                                                        
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSMNHB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE DM6NHB(N, D, X, B, CALCF, CALCGH, IV, LIV, LV, V)      
C                                                                       
C  ***  MINIMIZE GENERAL SIMPLY BOUNDED OBJECTIVE FUNCTION USING   ***  
C  ***  (ANALYTIC) GRADIENT AND HESSIAN PROVIDED BY THE CALLER.    ***  
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      DOUBLE PRECISION B(2,N), D(N), X(N), V(LV)                        
C     DIMENSION V(78 + N*(N+12))                                        
      EXTERNAL CALCF, CALCGH                                            
C                                                                       
C------------------------------  DISCUSSION  ---------------------------
C                                                                       
C        THIS ROUTINE IS LIKE  DMNGB, EXCEPT THAT THE SUBROUTINE PARA-  
C     METER CALCG OF  DMNGB (WHICH COMPUTES THE GRADIENT OF THE OBJEC-  
C     TIVE FUNCTION) IS REPLACED BY THE SUBROUTINE PARAMETER CALCGH,    
C     WHICH COMPUTES BOTH THE GRADIENT AND (LOWER TRIANGLE OF THE)      
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL DIVSET,  DRMNHB                                          
C                                                                       
C DIVSET.... PROVIDES DEFAULT INPUT VALUES FOR IV AND V.                
C  DRMNHB... REVERSE-COMMUNICATION ROUTINE THAT DOES  DMNHB ALGORITHM.  
C                                                                       
      INTEGER G1, H1, IV1, LH, NF                                       
      DOUBLE PRECISION F                                                
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER G, H, NEXTV, NFCALL, NFGCAL, TOOBIG, VNEED                
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, H/56/, TOOBIG/2/,    
C    1     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, H=56, TOOBIG=2,    
     1           VNEED=4)                                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = N * (N + 1) / 2                                              
      IF (IV(1) .EQ. 0) CALL DIVSET(2, IV, LIV, LV, V)                  
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + N*(N+3)/2              
      CALL  DRMNHB(B, D, F, V, V, IV, LH, LIV, LV, N, V, X)             
      IF (IV(1) .NE. 14) GO TO 50                                       
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(H) = IV(G) + N                                                 
      IV(NEXTV) = IV(H) + N*(N+1)/2                                     
      IF (IV1 .EQ. 13) GO TO 50                                         
C                                                                       
 10   G1 = IV(G)                                                        
      H1 = IV(H)                                                        
C                                                                       
 20   CALL  DRMNHB(B, D, F, V(G1), V(H1), IV, LH, LIV, LV, N, V, X)     
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F)                                           
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCGH(N, X, NF, V(G1), V(H1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   RETURN                                                            
C  ***  LAST CARD OF DM6NHB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DSNSF(N, P,L, X,C,Y, CALCA,INC,IINC,   MXFCAL, ACC )  
C                                                                       
C ** SIMPLIED VERSION OF  DNSF                                          
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE RESIDUAL                                 
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      DOUBLE PRECISION X(P),Y(N), C(L), ACC                             
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA,   DC6LCA                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      DOUBLE PRECISION UR                                               
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34HDSNSF - N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16HDSNSF -IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19HDSNSF - MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSNSF -ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR('DSNSF - N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR('DSNSF -IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR('DSNSF - MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSNSF -ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33HDSNSF - INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR('DSNSF - INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 122+2*M+4*P+2*L+MAX0(LP1,6*P)                               
      LV = 105+P*(2*P+18)+2*N*(L+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  DNSF(N, P,L, X,C,Y,  DC6LCA,INC,IINC,                       
     1  ISTAK(IV), LIV, LV,                                             
     1            DSTAK(V1), IU, UR, CALCA)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27HDSNSF -SINGULAR CONVERGENCE,27,6,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSNSF -FALSE CONVERGENCE,24,7,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSNSF -FUNCTION EVALUATION LIMIT,32,8,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSNSF -F(X) CANNOT BE COMPUTED AT INITIAL X,43,9,1)
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR('DSNSF -SINGULAR CONVERGENCE',27,6,1)      
      IF(J.EQ.8)CALL SETERR('DSNSF -FALSE CONVERGENCE',24,7,1)          
      IF(J.EQ.9)CALL SETERR('DSNSF -FUNCTION EVALUATION LIMIT',32,8,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSNSF -F(X) CANNOT BE COMPUTED AT INITIAL X',43,9,1) 
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSNSF  FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DSNSG(N, P,L, X,C,Y, CALCA,CALCB,                     
     1INC,IINC,   MXFCAL, ACC )                                         
C                                                                       
C ** SIMPLIED VERSION OF  DNSG                                          
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE  THE A MATRIX                            
C CALCB SUBROUTINE TO COMPUTE THE DERIVATIVES OF A                      
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      DOUBLE PRECISION X(P), ACC ,C(L),Y(N)                             
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA                                                    
      EXTERNAL CALCB                                                    
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34HDSNSG - N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16HDSNSG -IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19HDSNSG - MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSNSG -ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR('DSNSG - N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR('DSNSG -IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR('DSNSG - MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSNSG -ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33HDSNSG - INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR('DSNSG - INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 115+P+L+2*M                                                 
      LV = 105+P*(2*P+17)+N*(L+M+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  DJ6NSG(N, P,L, X,C,Y,  CALCA,CALCB,INC,IINC,                
     1  ISTAK(IV), LIV, LV,DSTAK(V1))                                   
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.7)CALL SETERR(27HDSNSG -SINGULAR CONVERGENCE,27,6,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSNSG -FALSE CONVERGENCE,24,7,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSNSG -FUNCTION EVALUATION LIMIT,32,8,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSNSG -A(X) CANNOT BE COMPUTED AT INITIAL X,43,9,1)
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47HDSNSG -JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    2 47,10,1)                                                         
C/7S                                                                    
      IF (J.EQ.7)CALL SETERR('DSNSG -SINGULAR CONVERGENCE',27,6,1)      
      IF(J.EQ.8)CALL SETERR('DSNSG -FALSE CONVERGENCE',24,7,1)          
      IF(J.EQ.9)CALL SETERR('DSNSG -FUNCTION EVALUATION LIMIT',32,8,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSNSG -A(X) CANNOT BE COMPUTED AT INITIAL X',43,9,1) 
      IF(J.EQ.65)                                                       
     1CALL SETERR('DSNSG -JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     2 47,10,1)                                                         
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSNSG  FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DJ6NSG(N,P,L,ALF,C,Y,CALCA,CALCB,INC,IINC,IV,         
     1                  LIV, LV, V)                                     
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING  ***              
C  ***  ANALYTICALLY COMPUTED DERIVATIVES.             ***              
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
      INTEGER INC(IINC,P), IV(LIV)                                      
      DOUBLE PRECISION ALF(P), C(L), V(LV), Y(N)                        
      EXTERNAL CALCA, CALCB                                             
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),    DNSG ATTEMPTS TO COMPUTE A LEAST SQUARES FIT          
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )).                       
C                       I=1    I             I                          
C                                                                       
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL DIVSET,   DRNSG                                          
C                                                                       
C DIVSET.... PROVIDES DEFAULT IV AND V VALUES.                          
C   DRNSG... CARRIES OUT NL2SOL ALGORITHM.                              
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER A1, DA1, I, IN1, IV1, K, L1, LP1, M, M0, NF               
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, D, DAMAT, IN, IVNEED, J, L1SAV, MSAVE, NEXTIV,      
     1        NEXTV, NFCALL, NFGCAL, PERM, R, TOOBIG, VNEED             
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, D/27/, DAMAT/114/, IN/112/, IVNEED/3/, J/70/,     
C    1     L1SAV/111/, MSAVE/115/, NEXTIV/46/, NEXTV/47/, NFCALL/6/,    
C    2     NFGCAL/7/, PERM/58/, R/61/, TOOBIG/2/, VNEED/4/              
C/7                                                                     
      PARAMETER (AMAT=113, D=27, DAMAT=114, IN=112, IVNEED=3, J=70,     
     1           L1SAV=111, MSAVE=115, NEXTIV=46, NEXTV=47, NFCALL=6,   
     2           NFGCAL=7, PERM=58, R=61, TOOBIG=2, VNEED=4)            
C/                                                                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      IF (IV(1) .EQ. 0) CALL DIVSET(1, IV, LIV, LV, V)                  
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 50             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 90                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 90                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 60                                       
      IF (IV(PERM) .LE. MSAVE) IV(PERM) = MSAVE + 1                     
      LP1 = L + 1                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
C                                                                       
      IV(IVNEED) = IV(IVNEED) + 2*M                                     
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + N*(L1+M)                                  
      GO TO 60                                                          
C                                                                       
 50   IV(1) = 66                                                        
C                                                                       
 60   CALL DRNSG(V, ALF, C, V, IV, IV, L, 1, N, LIV, LV, N, M, P, V, Y) 
      IF (IV(1) .NE. 14) GO TO 130                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(NEXTIV) = IV(IN) + 2*M                                         
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(NEXTV) = IV(DAMAT) + N*M                                       
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  SET UP IN ARRAY  ***                                            
C                                                                       
      IN1 = IV(IN)                                                      
      DO 80 I = 1, P                                                    
         DO 70 K = 1, LP1                                               
            IF (INC(K,I) .EQ. 0) GO TO 70                               
               IV(IN1) = I                                              
               IV(IN1+1) = K                                            
               IN1 = IN1 + 2                                            
 70         CONTINUE                                                    
 80      CONTINUE                                                       
      IF (IV1 .EQ. 13) GO TO 130                                        
C                                                                       
 90   A1 = IV(AMAT)                                                     
      DA1 = IV(DAMAT)                                                   
      IN1 = IV(IN)                                                      
      L1 = IV(L1SAV)                                                    
      M = IV(MSAVE)                                                     
C                                                                       
 100  CALL DRNSG(V(A1), ALF, C, V(DA1), IV(IN1), IV, L, L1, N, LIV, LV, 
     1            N, M, P, V, Y)                                        
      IF (IV(1)-2) 110, 120, 130                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 110  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF, NF, V(A1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 100                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 120  CALL CALCB(N, P, L, ALF,  IV(NFGCAL),V(DA1))                      
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 100                                                         
C                                                                       
 130  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    DNSG FOLLOWS  ***                               
      END                                                               
      SUBROUTINE  DSNSFB(N, P,L, X,B,C,Y, CALCA,INC,IINC,MXFCAL, ACC )  
C                                                                       
C ** SIMPLIED VERSION OF  DNSFB                                         
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C B    FIRST ROW GIVES LOWER BOUNDS ON X, SECOND ROW GIVES UPPOER BOUNDS
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE RESIDUAL                                 
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      DOUBLE PRECISION X(P), ACC , B(2,P)                               
      DOUBLE PRECISION C(L), Y(N)                                       
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA,   DC6LCA                                          
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      DOUBLE PRECISION UR                                               
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34HDSNSFB- N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16HDSNSFB-IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19HDSNSFB- MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSNSFB-ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR('DSNSFB- N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR('DSNSFB-IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR('DSNSFB- MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSNSFB-ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33HDSNSFB- INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR('DSNSFB- INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 122+2*M+4*P+2*L+MAX0(LP1,6*P)+3*P                           
      LV = 105+P*(2*P+22)+2*N*(L+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56)=0                                                    
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  DNSFB(N, P,L, X,B,C,Y,  DC6LCA,INC,IINC,                    
     1  ISTAK(IV), LIV, LV,                                             
     1            DSTAK(V1), IU, UR, CALCA)                             
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26HDSNSFB-INCONSISTENT BOUNDS,26,6,1)     
C     IF (J.EQ.7)CALL SETERR(27HDSNSFB-SINGULAR CONVERGENCE,27,7,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSNSFB-FALSE CONVERGENCE,24,8,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSNSFB-FUNCTION EVALUATION LIMIT,32,9,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSNSFB-F(X) CANNOT BE COMPUTED AT INITIAL X,43,10, 
C    21)                                                                
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR('DSNSFB-INCONSISTENT BOUNDS',26,6,1)      
      IF (J.EQ.7)CALL SETERR('DSNSFB-SINGULAR CONVERGENCE',27,7,1)      
      IF(J.EQ.8)CALL SETERR('DSNSFB-FALSE CONVERGENCE',24,8,1)          
      IF(J.EQ.9)CALL SETERR('DSNSFB-FUNCTION EVALUATION LIMIT',32,9,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSNSFB-F(X) CANNOT BE COMPUTED AT INITIAL X',43,10,  
     21)                                                                
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSNSFB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE DC6LCA(N,P,L,X,NF,A,IU,UR,UF)                          
      INTEGER N,P,IU                                                    
      DOUBLE PRECISION X(P),A(N,L),UR                                   
      EXTERNAL UF                                                       
      CALL UF(N,P,L,X,NF,A)                                             
      RETURN                                                            
      END                                                               
      SUBROUTINE  DSNSGB(N, P,L, X,B,C,Y, CALCA,CALCB,                  
     1INC,IINC,   MXFCAL, ACC )                                         
C                                                                       
C ** SIMPLIED VERSION OF  DNSGB                                         
C                                                                       
C INPUT PARAMETERS                                                      
C N    NUMBER OF OBSERVATIONS                                           
C P    NUMBER OF NONLINEAR UNKNOWNS                                     
C L    NUMBER OF LINEAR UNKNOWNS                                        
C X    APPROXIMATE SOLUTION NONLINEAR PARAMETERS                        
C B    FIRST ROW GIVES LOWER BOUNDS ON X. THE SECOND GIVES UPPER BOUNDS 
C Y    OBSERVATIONS                                                     
C CALCA SUBROUTINE TO EVALUATE  THE A MATRIX                            
C CALCB SUBROUTINE TO COMPUTE THE DERIVATIVES OF A                      
C INC  INCIDENCE ARRAY IF INC(I,J)=1 THEN COLUMN I DEPENDS ON X(J)      
C IINC ROW DIMENSIONOF INC MUST BE AT LEAST L+1                         
C MXFCAL MAXIMUM NUMBER OF PERMITTED FUNCTION EVALUATIONS               
C ACC   ACCURACY IN X                                                   
C OUTPUT PARAMETERS                                                     
C X     SOLUTION                                                        
C C     LINEAR PARAMETERS                                               
      INTEGER N, P, MXFCAL, L, IINC                                     
      DOUBLE PRECISION X(P), ACC ,B(2,P)                                
      DOUBLE PRECISION C(L), Y(N)                                       
      INTEGER INC(IINC,P)                                               
      EXTERNAL CALCA                                                    
      EXTERNAL CALCB                                                    
C                                                                       
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER IV, LIV, LV, V1                                           
      DOUBLE PRECISION DSTAK(500)                                       
      COMMON /CSTAK/ DSTAK                                              
      INTEGER ISTAK(1000)                                               
      EQUIVALENCE (DSTAK(1), ISTAK(1))                                  
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      CALL ENTER(0)                                                     
C/6S                                                                    
C     IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
C    1CALL SETERR(34HDSNSGB- N.LT.1 OR P.LT.0 OR L.LT.0,34,1,2)         
C     IF(IINC.LE.L)                                                     
C    1CALL SETERR(16HDSNSGB-IINC.LE.L,16,2,2)                           
C     IF (MXFCAL.LT.1)                                                  
C    1CALLSETERR(19HDSNSGB- MXFCAL.LT.1,19,4,2)                         
C     IF (ACC.LT.0.0D0)                                                 
C    1CALL SETERR(18HDSNSGB-ACC .LT.0.0,18,5,2)                         
C/7S                                                                    
      IF (N.LT.1.OR.P.LT.0.OR.L.LT.0)                                   
     1CALL SETERR('DSNSGB- N.LT.1 OR P.LT.0 OR L.LT.0',34,1,2)          
      IF(IINC.LE.L)                                                     
     1CALL SETERR('DSNSGB-IINC.LE.L',16,2,2)                            
      IF (MXFCAL.LT.1)                                                  
     1CALLSETERR('DSNSGB- MXFCAL.LT.1',19,4,2)                          
      IF (ACC.LT.0.0D0)                                                 
     1CALL SETERR('DSNSGB-ACC .LT.0.0',18,5,2)                          
C/                                                                      
      LP1=L+1                                                           
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
      GO TO 60                                                          
C/6S                                                                    
C50   CALL SETERR(33HDSNSGB- INCIDENCE ARRAY INCORRECT,33,3,2)          
C/7S                                                                    
 50   CALL SETERR('DSNSGB- INCIDENCE ARRAY INCORRECT',33,3,2)           
C/                                                                      
 60   CONTINUE                                                          
      LIV = 115+P+L+2*M+3*P                                             
      LV = 105+P*(2*P+21)+N*(L+M+3)+L*(L+3)/2+N*P                       
      IV=ISTKGT(LIV,2)                                                  
      V1=ISTKGT(LV, 4)                                                  
      CALL DIVSET(1,ISTAK(IV),LIV,LV,DSTAK(V1))                         
      ISTAK(IV+20)=0                                                    
      ISTAK(IV+16)=MXFCAL                                               
      ISTAK(IV+17)=MXFCAL                                               
      ISTAK(IV+56) =0                                                   
      DSTAK(V1+32)=ACC                                                  
      DSTAK(V1+31)=ACC                                                  
      CALL  DN6SGB(N, P,L, X,B,C,Y,  CALCA,CALCB,INC,IINC,              
     1  ISTAK(IV), LIV, LV,DSTAK(V1))                                   
      J=ISTAK(IV)                                                       
      IF(J.LT.7) GO TO 70                                               
C/6S                                                                    
C     IF (J.EQ.82)CALL SETERR(26HDSNSGB-INCONSISTENT BOUNDS,26,6,1)     
C     IF (J.EQ.7)CALL SETERR(27HDSNSGB-SINGULAR CONVERGENCE,27,7,1)     
C     IF(J.EQ.8)CALL SETERR(24HDSNSGB-FALSE CONVERGENCE,24,8,1)         
C     IF(J.EQ.9)CALL SETERR(32HDSNSGB-FUNCTION EVALUATION LIMIT,32,9,1) 
C     IF (J.EQ.63)                                                      
C    1CALL SETERR(43HDSNSGB-A(X) CANNOT BE COMPUTED AT INITIAL X,43,10, 
C    21)                                                                
C     IF(J.EQ.65)                                                       
C    1CALL SETERR(47HDSNSGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X,   
C    2 47,11,1)                                                         
C/7S                                                                    
      IF (J.EQ.82)CALL SETERR('DSNSGB-INCONSISTENT BOUNDS',26,6,1)      
      IF (J.EQ.7)CALL SETERR('DSNSGB-SINGULAR CONVERGENCE',27,7,1)      
      IF(J.EQ.8)CALL SETERR('DSNSGB-FALSE CONVERGENCE',24,8,1)          
      IF(J.EQ.9)CALL SETERR('DSNSGB-FUNCTION EVALUATION LIMIT',32,9,1)  
      IF (J.EQ.63)                                                      
     1CALL SETERR('DSNSGB-A(X) CANNOT BE COMPUTED AT INITIAL X',43,10,  
     21)                                                                
      IF(J.EQ.65)                                                       
     1CALL SETERR('DSNSGB-JACOBIAN CANNOT BE COMPUTED AT INITIAL X',    
     2 47,11,1)                                                         
C/                                                                      
 70    CALL LEAVE                                                       
C                                                                       
      RETURN                                                            
C  *** LAST LINE OF  DSNSGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  DN6SGB(N,P,L,ALF,B,C,Y,CALCA,CALCB,INC,IINC,IV,       
     1                  LIV, LV, V)                                     
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING  ***              
C  ***  ANALYTICALLY COMPUTED DERIVATIVES.             ***              
C *** BOUNDS ON NONLINEAR PARAMETERS                                    
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
      INTEGER INC(IINC,P), IV(LIV)                                      
      DOUBLE PRECISION ALF(P), C(L), V(LV), Y(N), B(2,P)                
      EXTERNAL CALCA, CALCB                                             
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),    DNSGBATTEMPTS TO COMPUTE A LEAST SQUARES FIT          
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )).                       
C                       I=1    I             I                          
C                                                                       
C SUBJECT TO SIMPLE BOUND CONSTRAINTS B(1,I).LE.X(I).LE.B(2,I)          
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL DIVSET,   DRNSGB                                         
C                                                                       
C DIVSET.... PROVIDES DEFAULT IV AND V VALUES.                          
C   DRNSG... CARRIES OUT NL2SOL ALGORITHM.                              
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER A1, DA1, I, IN1, IV1, K, L1, LP1, M, M0, NF               
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, D, DAMAT, IN, IVNEED, J, L1SAV, MSAVE, NEXTIV,      
     1        NEXTV, NFCALL, NFGCAL, PERM, R, TOOBIG, VNEED             
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, D/27/, DAMAT/114/, IN/112/, IVNEED/3/, J/70/,     
C    1     L1SAV/111/, MSAVE/115/, NEXTIV/46/, NEXTV/47/, NFCALL/6/,    
C    2     NFGCAL/7/, PERM/58/, R/61/, TOOBIG/2/, VNEED/4/              
C/7                                                                     
      PARAMETER (AMAT=113, D=27, DAMAT=114, IN=112, IVNEED=3, J=70,     
     1           L1SAV=111, MSAVE=115, NEXTIV=46, NEXTV=47, NFCALL=6,   
     2           NFGCAL=7, PERM=58, R=61, TOOBIG=2, VNEED=4)            
C/                                                                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      IF (IV(1) .EQ. 0) CALL DIVSET(1, IV, LIV, LV, V)                  
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 50             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 90                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 90                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 60                                       
      IF (IV(PERM) .LE. MSAVE) IV(PERM) = MSAVE + 1                     
      LP1 = L + 1                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
C                                                                       
      IV(IVNEED) = IV(IVNEED) + 2*M                                     
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + N*(L1+M)                                  
      GO TO 60                                                          
C                                                                       
 50   IV(1) = 66                                                        
C                                                                       
 60   CALL   DRNSGB(V,ALF,B,C,V,IV,IV,L,1,N,LIV,LV,N,M,P,V,Y)           
      IF (IV(1) .NE. 14) GO TO 130                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(NEXTIV) = IV(IN) + 2*M                                         
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(NEXTV) = IV(DAMAT) + N*M                                       
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  SET UP IN ARRAY  ***                                            
C                                                                       
      IN1 = IV(IN)                                                      
      DO 80 I = 1, P                                                    
         DO 70 K = 1, LP1                                               
            IF (INC(K,I) .EQ. 0) GO TO 70                               
               IV(IN1) = I                                              
               IV(IN1+1) = K                                            
               IN1 = IN1 + 2                                            
 70         CONTINUE                                                    
 80      CONTINUE                                                       
      IF (IV1 .EQ. 13) GO TO 130                                        
C                                                                       
 90   A1 = IV(AMAT)                                                     
      DA1 = IV(DAMAT)                                                   
      IN1 = IV(IN)                                                      
      L1 = IV(L1SAV)                                                    
      M = IV(MSAVE)                                                     
C                                                                       
 100  CALL   DRNSGB(V(A1),ALF,B,C,V(DA1),IV(IN1),IV,L,L1,N,LIV,LV,      
     1            N, M, P, V, Y)                                        
      IF (IV(1)-2) 110, 120, 130                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 110  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF,  NF,V(A1))                               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 100                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 120  CALL CALCB(N, P, L, ALF, IV(NFGCAL), V(DA1))                      
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 100                                                         
C                                                                       
 130  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    DNSGBFOLLOWS  ***                               
      END                                                               
      SUBROUTINE   MNF(N, D, X, CALCF, IV, LIV, LV, V,                  
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING         
C  ***  FINITE-DIFFERENCE GRADIENTS AND SECANT HESSIAN APPROXIMATIONS.  
C                                                                       
      INTEGER N, LIV, LV                                                
      INTEGER IV(LIV), UIPARM(1)                                        
      REAL D(N), X(N), V(LV), URPARM(1)                                 
C     DIMENSION V(77 + N*(N+17)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF, UFPARM                                            
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        THIS ROUTINE INTERACTS WITH SUBROUTINE   RMNF  IN AN ATTEMPT   
C     TO FIND AN N-VECTOR  X*  THAT MINIMIZES THE (UNCONSTRAINED)       
C     OBJECTIVE FUNCTION COMPUTED BY  CALCF.  (OFTEN THE  X*  FOUND IS  
C     A LOCAL MINIMIZER RATHER THAN A GLOBAL ONE.)                      
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C        THE PARAMETERS FOR   MNF ARE THE SAME AS THOSE FOR   MNG       
C     (WHICH SEE), EXCEPT THAT CALCG IS OMITTED.  INSTEAD OF CALLING    
C     CALCG TO OBTAIN THE GRADIENT OF THE OBJECTIVE FUNCTION AT X,      
C       MNF CALLS  S7GRD, WHICH COMPUTES AN APPROXIMATION TO THE        
C     GRADIENT BY FINITE (FORWARD AND CENTRAL) DIFFERENCES USING THE    
C     METHOD OF REF. 1.  THE FOLLOWING INPUT COMPONENT IS OF INTEREST   
C     IN THIS REGARD (AND IS NOT DESCRIBED IN   MNG).                   
C                                                                       
C V(ETA0)..... V(42) IS AN ESTIMATED BOUND ON THE RELATIVE ERROR IN THE 
C             OBJECTIVE FUNCTION VALUE COMPUTED BY CALCF...             
C                  (TRUE VALUE) = (COMPUTED VALUE) * (1 + E),           
C             WHERE ABS(E) .LE. V(ETA0).  DEFAULT = MACHEP * 10**3,     
C             WHERE MACHEP IS THE UNIT ROUNDOFF.                        
C                                                                       
C        THE OUTPUT VALUES IV(NFCALL) AND IV(NGCALL) HAVE DIFFERENT     
C     MEANINGS FOR   MNF THAN FOR   MNG...                              
C                                                                       
C IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCF (I.E.,
C             FUNCTION EVALUATIONS) EXCLUDING THOSE MADE ONLY FOR       
C             COMPUTING GRADIENTS.  THE INPUT VALUE IV(MXFCAL) IS A     
C             LIMIT ON IV(NFCALL).                                      
C IV(NGCALL)... IV(30) IS THE NUMBER OF FUNCTION EVALUATIONS MADE ONLY  
C             FOR COMPUTING GRADIENTS.  THE TOTAL NUMBER OF FUNCTION    
C             EVALUATIONS IS THUS  IV(NFCALL) + IV(NGCALL).             
C                                                                       
C  ***  REFERENCE  ***                                                  
C                                                                       
C 1. STEWART, G.W. (1967), A MODIFICATION OF DAVIDON*S MINIMIZATION     
C        METHOD TO ACCEPT DIFFERENCE APPROXIMATIONS OF DERIVATIVES,     
C        J. ASSOC. COMPUT. MACH. 14, PP. 72-83.                         
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (WINTER 1980).  REVISED SEPT. 1982.         
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH           
C     SUPPORTED IN PART BY THE NATIONAL SCIENCE FOUNDATION UNDER        
C     GRANTS MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989,        
C     AND MCS-7906671.                                                  
C                                                                       
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL  RMNF                                                    
C                                                                       
C  RMNF.... OVERSEES COMPUTATION OF FINITE-DIFFERENCE GRADIENT AND      
C         CALLS  RMNG TO CARRY OUT   MNG ALGORITHM.                     
C                                                                       
      INTEGER NF                                                        
      REAL FX                                                           
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NFCALL, TOOBIG                                            
C                                                                       
C/6                                                                     
C     DATA NFCALL/6/, TOOBIG/2/                                         
C/7                                                                     
      PARAMETER (NFCALL=6, TOOBIG=2)                                    
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
 10   CALL  RMNF(D, FX, IV, LIV, LV, N, V, X)                           
      IF (IV(1) .GT. 2) GO TO 999                                       
C                                                                       
C     ***  COMPUTE FUNCTION  ***                                        
C                                                                       
      NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, FX, UIPARM, URPARM, UFPARM)                  
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 10                                                          
C                                                                       
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF   MNF FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE   MNFB(P, D, X, B, CALCF, IV, LIV, LV, V,              
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING         
C  ***  FINITE-DIFFERENCE GRADIENTS AND SECANT HESSIAN APPROXIMATIONS.  
C                                                                       
      INTEGER P, LIV, LV                                                
      INTEGER IV(LIV), UIPARM(1)                                        
      REAL B(2,P), D(P), X(P), V(LV), URPARM(1)                         
C     DIMENSION V(77 + P*(P+17)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF, UFPARM                                            
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        THIS ROUTINE INTERACTS WITH SUBROUTINE   RMNF  IN AN ATTEMPT   
C     TO FIND AN P-VECTOR  X*  THAT MINIMIZES THE (UNCONSTRAINED)       
C     OBJECTIVE FUNCTION COMPUTED BY  CALCF.  (OFTEN THE  X*  FOUND IS  
C     A LOCAL MINIMIZER RATHER THAN A GLOBAL ONE.)                      
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C        THE PARAMETERS FOR   MNFB ARE THE SAME AS THOSE FOR   MNGB     
C     (WHICH SEE), EXCEPT THAT CALCG IS OMITTED.  INSTEAD OF CALLING    
C     CALCG TO OBTAIN THE GRADIENT OF THE OBJECTIVE FUNCTION AT X,      
C       MNFB CALLS  S7GRD, WHICH COMPUTES AN APPROXIMATION TO THE       
C     GRADIENT BY FINITE (FORWARD AND CENTRAL) DIFFERENCES USING THE    
C     METHOD OF REF. 1.  THE FOLLOWING INPUT COMPONENT IS OF INTEREST   
C     IN THIS REGARD (AND IS NOT DESCRIBED IN   MNG OR   MNGB).         
C                                                                       
C V(ETA0)..... V(42) IS AN ESTIMATED BOUND ON THE RELATIVE ERROR IN THE 
C             OBJECTIVE FUNCTION VALUE COMPUTED BY CALCF...             
C                  (TRUE VALUE) = (COMPUTED VALUE) * (1 + E),           
C             WHERE ABS(E) .LE. V(ETA0).  DEFAULT = MACHEP * 10**3,     
C             WHERE MACHEP IS THE UNIT ROUNDOFF.                        
C                                                                       
C        THE OUTPUT VALUES IV(NFCALL) AND IV(NGCALL) HAVE DIFFERENT     
C     MEANINGS FOR   MNFB THAN FOR   MNG...                             
C                                                                       
C IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCF (I.E.,
C             FUNCTION EVALUATIONS) EXCLUDING THOSE MADE ONLY FOR       
C             COMPUTING GRADIENTS.  THE INPUT VALUE IV(MXFCAL) IS A     
C             LIMIT ON IV(NFCALL).                                      
C IV(NGCALL)... IV(30) IS THE NUMBER OF FUNCTION EVALUATIONS MADE ONLY  
C             FOR COMPUTING GRADIENTS.  THE TOTAL NUMBER OF FUNCTION    
C             EVALUATIONS IS THUS  IV(NFCALL) + IV(NGCALL).             
C                                                                       
C  ***  REFERENCE  ***                                                  
C                                                                       
C 1. STEWART, G.W. (1967), A MODIFICATION OF DAVIDON*S MINIMIZATION     
C        METHOD TO ACCEPT DIFFERENCE APPROXIMATIONS OF DERIVATIVES,     
C        J. ASSOC. COMPUT. MACH. 14, PP. 72-83.                         
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (WINTER 1980).  REVISED SEPT. 1982.         
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH           
C     SUPPORTED IN PART BY THE NATIONAL SCIENCE FOUNDATION UNDER        
C     GRANTS MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989,        
C     AND MCS-7906671.                                                  
C                                                                       
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL  RMNFB                                                   
C                                                                       
C  RMNFB... OVERSEES COMPUTATION OF FINITE-DIFFERENCE GRADIENT AND      
C         CALLS  RMNG TO CARRY OUT   MNG ALGORITHM.                     
C                                                                       
      INTEGER NF                                                        
      REAL FX                                                           
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NFCALL, TOOBIG                                            
C                                                                       
C/6                                                                     
C     DATA NFCALL/6/, TOOBIG/2/                                         
C/7                                                                     
      PARAMETER (NFCALL=6, TOOBIG=2)                                    
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
 10   CALL  RMNFB(B, D, FX, IV, LIV, LV, P, V, X)                       
      IF (IV(1) .GT. 2) GO TO 999                                       
C                                                                       
C     ***  COMPUTE FUNCTION  ***                                        
C                                                                       
      NF = IV(NFCALL)                                                   
      CALL CALCF(P, X, NF, FX, UIPARM, URPARM, UFPARM)                  
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 10                                                          
C                                                                       
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF   MNFB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   MNG(N, D, X, CALCF, CALCG, IV, LIV, LV, V,           
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING   ***   
C  ***  ANALYTIC GRADIENT AND HESSIAN APPROX. FROM SECANT UPDATE  ***   
C                                                                       
      INTEGER N, LIV, LV                                                
      INTEGER IV(LIV), UIPARM(1)                                        
      REAL D(N), X(N), V(LV), URPARM(1)                                 
C     DIMENSION V(71 + N*(N+15)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF, CALCG, UFPARM                                     
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        THIS ROUTINE INTERACTS WITH SUBROUTINE   RMNG  IN AN ATTEMPT   
C     TO FIND AN N-VECTOR  X*  THAT MINIMIZES THE (UNCONSTRAINED)       
C     OBJECTIVE FUNCTION COMPUTED BY  CALCF.  (OFTEN THE  X*  FOUND IS  
C     A LOCAL MINIMIZER RATHER THAN A GLOBAL ONE.)                      
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C N........ (INPUT) THE NUMBER OF VARIABLES ON WHICH  F  DEPENDS, I.E., 
C                  THE NUMBER OF COMPONENTS IN  X.                      
C D........ (INPUT/OUTPUT) A SCALE VECTOR SUCH THAT  D(I)*X(I),         
C                  I = 1,2,...,N,  ARE ALL IN COMPARABLE UNITS.         
C                  D CAN STRONGLY AFFECT THE BEHAVIOR OF   MNG.         
C                  FINDING THE BEST CHOICE OF D IS GENERALLY A TRIAL-   
C                  AND-ERROR PROCESS.  CHOOSING D SO THAT D(I)*X(I)     
C                  HAS ABOUT THE SAME VALUE FOR ALL I OFTEN WORKS WELL. 
C                  THE DEFAULTS PROVIDED BY SUBROUTINE IVSET (SEE IV    
C                  BELOW) REQUIRE THE CALLER TO SUPPLY D.               
C X........ (INPUT/OUTPUT) BEFORE (INITIALLY) CALLING   MNG, THE CALL-  
C                  ER SHOULD SET  X  TO AN INITIAL GUESS AT  X*.  WHEN  
C                    MNG RETURNS,  X  CONTAINS THE BEST POINT SO FAR    
C                  FOUND, I.E., THE ONE THAT GIVES THE LEAST VALUE SO   
C                  FAR SEEN FOR  F(X).                                  
C CALCF.... (INPUT) A SUBROUTINE THAT, GIVEN X, COMPUTES F(X).  CALCF   
C                  MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.    
C                  IT IS INVOKED BY                                     
C                       CALL CALCF(N, X, NF, F, UIPARM, URPARM, UFPARM) 
C                  WHEN CALCF IS CALLED, NF IS THE INVOCATION           
C                  COUNT FOR CALCF.  NF IS INCLUDED FOR POSSIBLE USE    
C                  WITH CALCG.  IF X IS OUT OF BOUNDS (E.G., IF IT      
C                  WOULD CAUSE OVERFLOW IN COMPUTING F(X)), THEN CALCF  
C                  SHOULD SET NF TO 0.  THIS WILL CAUSE A SHORTER STEP  
C                  TO BE ATTEMPTED.  (IF X IS IN BOUNDS, THEN CALCF     
C                  SHOULD NOT CHANGE NF.)  THE OTHER PARAMETERS ARE AS  
C                  DESCRIBED ABOVE AND BELOW.  CALCF SHOULD NOT CHANGE  
C                  N, P, OR X.                                          
C CALCG.... (INPUT) A SUBROUTINE THAT, GIVEN X, COMPUTES G(X), THE GRA- 
C                  DIENT OF F AT X.  CALCG MUST BE DECLARED EXTERNAL IN 
C                  THE CALLING PROGRAM.  IT IS INVOKED BY               
C                       CALL CALCG(N, X, NF, G, UIPARM, URPARM, UFAPRM) 
C                  WHEN CALCG IS CALLED, NF IS THE INVOCATION           
C                  COUNT FOR CALCF AT THE TIME F(X) WAS EVALUATED.  THE 
C                  X PASSED TO CALCG IS USUALLY THE ONE PASSED TO CALCF 
C                  ON EITHER ITS MOST RECENT INVOCATION OR THE ONE      
C                  PRIOR TO IT.  IF CALCF SAVES INTERMEDIATE RESULTS    
C                  FOR USE BY CALCG, THEN IT IS POSSIBLE TO TELL FROM   
C                  NF WHETHER THEY ARE VALID FOR THE CURRENT X (OR      
C                  WHICH COPY IS VALID IF TWO COPIES ARE KEPT).  IF G   
C                  CANNOT BE COMPUTED AT X, THEN CALCG SHOULD SET NF TO 
C                  0.  IN THIS CASE,   MNG WILL RETURN WITH IV(1) = 65. 
C                  (IF G CAN BE COMPUTED AT X, THEN CALCG SHOULD NOT    
C                  CHANGED NF.)  THE OTHER PARAMETERS TO CALCG ARE AS   
C                  DESCRIBED ABOVE AND BELOW.  CALCG SHOULD NOT CHANGE  
C                  N OR X.                                              
C IV....... (INPUT/OUTPUT) AN INTEGER VALUE ARRAY OF LENGTH LIV (SEE    
C                  BELOW) THAT HELPS CONTROL THE   MNG ALGORITHM AND    
C                  THAT IS USED TO STORE VARIOUS INTERMEDIATE QUANTI-   
C                  TIES.  OF PARTICULAR INTEREST ARE THE INITIALIZATION/
C                  RETURN CODE IV(1) AND THE ENTRIES IN IV THAT CONTROL 
C                  PRINTING AND LIMIT THE NUMBER OF ITERATIONS AND FUNC-
C                  TION EVALUATIONS.  SEE THE SECTION ON IV INPUT       
C                  VALUES BELOW.                                        
C LIV...... (INPUT) LENGTH OF IV ARRAY.  MUST BE AT LEAST 60.  IF LIV   
C                  IS TOO SMALL, THEN   MNG RETURNS WITH IV(1) = 15.    
C                  WHEN   MNG RETURNS, THE SMALLEST ALLOWED VALUE OF    
C                  LIV IS STORED IN IV(LASTIV) -- SEE THE SECTION ON    
C                  IV OUTPUT VALUES BELOW.  (THIS IS INTENDED FOR USE   
C                  WITH EXTENSIONS OF   MNG THAT HANDLE CONSTRAINTS.)   
C LV....... (INPUT) LENGTH OF V ARRAY.  MUST BE AT LEAST 71+N*(N+15)/2. 
C                  (AT LEAST 77+N*(N+17)/2 FOR   MNF, AT LEAST          
C                  78+N*(N+12) FOR   MNH).  IF LV IS TOO SMALL, THEN    
C                    MNG RETURNS WITH IV(1) = 16.  WHEN   MNG RETURNS,  
C                  THE SMALLEST ALLOWED VALUE OF LV IS STORED IN        
C                  IV(LASTV) -- SEE THE SECTION ON IV OUTPUT VALUES     
C                  BELOW.                                               
C V........ (INPUT/OUTPUT) A FLOATING-POINT VALUE ARRAY OF LENGTH LV    
C                  (SEE BELOW) THAT HELPS CONTROL THE   MNG ALGORITHM   
C                  AND THAT IS USED TO STORE VARIOUS INTERMEDIATE       
C                  QUANTITIES.  OF PARTICULAR INTEREST ARE THE ENTRIES  
C                  IN V THAT LIMIT THE LENGTH OF THE FIRST STEP         
C                  ATTEMPTED (LMAX0) AND SPECIFY CONVERGENCE TOLERANCES 
C                  (AFCTOL, LMAXS, RFCTOL, SCTOL, XCTOL, XFTOL).        
C UIPARM... (INPUT) USER INTEGER PARAMETER ARRAY PASSED WITHOUT CHANGE  
C                  TO CALCF AND CALCG.                                  
C URPARM... (INPUT) USER FLOATING-POINT PARAMETER ARRAY PASSED WITHOUT  
C                  CHANGE TO CALCF AND CALCG.                           
C UFPARM... (INPUT) USER EXTERNAL SUBROUTINE OR FUNCTION PASSED WITHOUT 
C                  CHANGE TO CALCF AND CALCG.                           
C                                                                       
C  ***  IV INPUT VALUES (FROM SUBROUTINE IVSET)  ***                    
C                                                                       
C IV(1)...  ON INPUT, IV(1) SHOULD HAVE A VALUE BETWEEN 0 AND 14......  
C             0 AND 12 MEAN THIS IS A FRESH START.  0 MEANS THAT        
C                  IVSET(2, IV, LIV, LV, V)                             
C             IS TO BE CALLED TO PROVIDE ALL DEFAULT VALUES TO IV AND   
C             V.  12 (THE VALUE THAT IVSET ASSIGNS TO IV(1)) MEANS THE  
C             CALLER HAS ALREADY CALLED IVSET AND HAS POSSIBLY CHANGED  
C             SOME IV AND/OR V ENTRIES TO NON-DEFAULT VALUES.           
C             13 MEANS IVSET HAS BEEN CALLED AND THAT   MNG (AND        
C              RMNG) SHOULD ONLY DO THEIR STORAGE ALLOCATION.  THAT IS, 
C             THEY SHOULD SET THE OUTPUT COMPONENTS OF IV THAT TELL     
C             WHERE VARIOUS SUBARRAYS ARRAYS OF V BEGIN, SUCH AS IV(G)  
C             (AND, FOR   MNH AND  RMNH ONLY, IV(DTOL)), AND RETURN.    
C             14 MEANS THAT A STORAGE HAS BEEN ALLOCATED (BY A CALL     
C             WITH IV(1) = 13) AND THAT THE ALGORITHM SHOULD BE         
C             STARTED.  WHEN CALLED WITH IV(1) = 13,   MNG RETURNS      
C             IV(1) = 14 UNLESS LIV OR LV IS TOO SMALL (OR N IS NOT     
C             POSITIVE).  DEFAULT = 12.                                 
C IV(INITH).... IV(25) TELLS WHETHER THE HESSIAN APPROXIMATION H SHOULD 
C             BE INITIALIZED.  1 (THE DEFAULT) MEANS  RMNG SHOULD       
C             INITIALIZE H TO THE DIAGONAL MATRIX WHOSE I-TH DIAGONAL   
C             ELEMENT IS D(I)**2.  0 MEANS THE CALLER HAS SUPPLIED A    
C             CHOLESKY FACTOR  L  OF THE INITIAL HESSIAN APPROXIMATION  
C             H = L*(L**T)  IN V, STARTING AT V(IV(LMAT)) = V(IV(42))   
C             (AND STORED COMPACTLY BY ROWS).  NOTE THAT IV(LMAT) MAY   
C             BE INITIALIZED BY CALLING   MNG WITH IV(1) = 13 (SEE      
C             THE IV(1) DISCUSSION ABOVE).  DEFAULT = 1.                
C IV(MXFCAL)... IV(17) GIVES THE MAXIMUM NUMBER OF FUNCTION EVALUATIONS 
C             (CALLS ON CALCF) ALLOWED.  IF THIS NUMBER DOES NOT SUF-   
C             FICE, THEN   MNG RETURNS WITH IV(1) = 9.  DEFAULT = 200.  
C IV(MXITER)... IV(18) GIVES THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.  
C             IT ALSO INDIRECTLY LIMITS THE NUMBER OF GRADIENT EVALUA-  
C             TIONS (CALLS ON CALCG) TO IV(MXITER) + 1.  IF IV(MXITER)  
C             ITERATIONS DO NOT SUFFICE, THEN   MNG RETURNS WITH        
C             IV(1) = 10.  DEFAULT = 150.                               
C IV(OUTLEV)... IV(19) CONTROLS THE NUMBER AND LENGTH OF ITERATION SUM- 
C             MARY LINES PRINTED (BY ITSUM).  IV(OUTLEV) = 0 MEANS DO   
C             NOT PRINT ANY SUMMARY LINES.  OTHERWISE, PRINT A SUMMARY  
C             LINE AFTER EACH ABS(IV(OUTLEV)) ITERATIONS.  IF IV(OUTLEV)
C             IS POSITIVE, THEN SUMMARY LINES OF LENGTH 78 (PLUS CARRI- 
C             AGE CONTROL) ARE PRINTED, INCLUDING THE FOLLOWING...  THE 
C             ITERATION AND FUNCTION EVALUATION COUNTS, F = THE CURRENT 
C             FUNCTION VALUE, RELATIVE DIFFERENCE IN FUNCTION VALUES    
C             ACHIEVED BY THE LATEST STEP (I.E., RELDF = (F0-V(F))/F01, 
C             WHERE F01 IS THE MAXIMUM OF ABS(V(F)) AND ABS(V(F0)) AND  
C             V(F0) IS THE FUNCTION VALUE FROM THE PREVIOUS ITERA-      
C             TION), THE RELATIVE FUNCTION REDUCTION PREDICTED FOR THE  
C             STEP JUST TAKEN (I.E., PRELDF = V(PREDUC) / F01, WHERE    
C             V(PREDUC) IS DESCRIBED BELOW), THE SCALED RELATIVE CHANGE 
C             IN X (SEE V(RELDX) BELOW), THE STEP PARAMETER FOR THE     
C             STEP JUST TAKEN (STPPAR = 0 MEANS A FULL NEWTON STEP,     
C             BETWEEN 0 AND 1 MEANS A RELAXED NEWTON STEP, BETWEEN 1    
C             AND 2 MEANS A DOUBLE DOGLEG STEP, GREATER THAN 2 MEANS    
C             A SCALED DOWN CAUCHY STEP -- SEE SUBROUTINE DBLDOG), THE  
C             2-NORM OF THE SCALE VECTOR D TIMES THE STEP JUST TAKEN    
C             (SEE V(DSTNRM) BELOW), AND NPRELDF, I.E.,                 
C             V(NREDUC)/F01, WHERE V(NREDUC) IS DESCRIBED BELOW -- IF   
C             NPRELDF IS POSITIVE, THEN IT IS THE RELATIVE FUNCTION     
C             REDUCTION PREDICTED FOR A NEWTON STEP (ONE WITH           
C             STPPAR = 0).  IF NPRELDF IS NEGATIVE, THEN IT IS THE      
C             NEGATIVE OF THE RELATIVE FUNCTION REDUCTION PREDICTED     
C             FOR A STEP COMPUTED WITH STEP BOUND V(LMAXS) FOR USE IN   
C             TESTING FOR SINGULAR CONVERGENCE.                         
C                  IF IV(OUTLEV) IS NEGATIVE, THEN LINES OF LENGTH 50   
C             ARE PRINTED, INCLUDING ONLY THE FIRST 6 ITEMS LISTED      
C             ABOVE (THROUGH RELDX).                                    
C             DEFAULT = 1.                                              
C IV(PARPRT)... IV(20) = 1 MEANS PRINT ANY NONDEFAULT V VALUES ON A     
C             FRESH START OR ANY CHANGED V VALUES ON A RESTART.         
C             IV(PARPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.    
C IV(PRUNIT)... IV(21) IS THE OUTPUT UNIT NUMBER ON WHICH ALL PRINTING  
C             IS DONE.  IV(PRUNIT) = 0 MEANS SUPPRESS ALL PRINTING.     
C             DEFAULT = STANDARD OUTPUT UNIT (UNIT 6 ON MOST SYSTEMS).  
C IV(SOLPRT)... IV(22) = 1 MEANS PRINT OUT THE VALUE OF X RETURNED (AS  
C             WELL AS THE GRADIENT AND THE SCALE VECTOR D).             
C             IV(SOLPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.    
C IV(STATPR)... IV(23) = 1 MEANS PRINT SUMMARY STATISTICS UPON RETURN-  
C             ING.  THESE CONSIST OF THE FUNCTION VALUE, THE SCALED     
C             RELATIVE CHANGE IN X CAUSED BY THE MOST RECENT STEP (SEE  
C             V(RELDX) BELOW), THE NUMBER OF FUNCTION AND GRADIENT      
C             EVALUATIONS (CALLS ON CALCF AND CALCG), AND THE RELATIVE  
C             FUNCTION REDUCTIONS PREDICTED FOR THE LAST STEP TAKEN AND 
C             FOR A NEWTON STEP (OR PERHAPS A STEP BOUNDED BY V(LMAXS)  
C             -- SEE THE DESCRIPTIONS OF PRELDF AND NPRELDF UNDER       
C             IV(OUTLEV) ABOVE).                                        
C             IV(STATPR) = 0 MEANS SKIP THIS PRINTING.                  
C             IV(STATPR) = -1 MEANS SKIP THIS PRINTING AS WELL AS THAT  
C             OF THE ONE-LINE TERMINATION REASON MESSAGE.  DEFAULT = 1. 
C IV(X0PRT).... IV(24) = 1 MEANS PRINT THE INITIAL X AND SCALE VECTOR D 
C             (ON A FRESH START ONLY).  IV(X0PRT) = 0 MEANS SKIP THIS   
C             PRINTING.  DEFAULT = 1.                                   
C                                                                       
C  ***  (SELECTED) IV OUTPUT VALUES  ***                                
C                                                                       
C IV(1)........ ON OUTPUT, IV(1) IS A RETURN CODE....                   
C             3 = X-CONVERGENCE.  THE SCALED RELATIVE DIFFERENCE (SEE   
C                  V(RELDX)) BETWEEN THE CURRENT PARAMETER VECTOR X AND 
C                  A LOCALLY OPTIMAL PARAMETER VECTOR IS VERY LIKELY AT 
C                  MOST V(XCTOL).                                       
C             4 = RELATIVE FUNCTION CONVERGENCE.  THE RELATIVE DIFFER-  
C                  ENCE BETWEEN THE CURRENT FUNCTION VALUE AND ITS LO-  
C                  CALLY OPTIMAL VALUE IS VERY LIKELY AT MOST V(RFCTOL).
C             5 = BOTH X- AND RELATIVE FUNCTION CONVERGENCE (I.E., THE  
C                  CONDITIONS FOR IV(1) = 3 AND IV(1) = 4 BOTH HOLD).   
C             6 = ABSOLUTE FUNCTION CONVERGENCE.  THE CURRENT FUNCTION  
C                  VALUE IS AT MOST V(AFCTOL) IN ABSOLUTE VALUE.        
C             7 = SINGULAR CONVERGENCE.  THE HESSIAN NEAR THE CURRENT   
C                  ITERATE APPEARS TO BE SINGULAR OR NEARLY SO, AND A   
C                  STEP OF LENGTH AT MOST V(LMAXS) IS UNLIKELY TO YIELD 
C                  A RELATIVE FUNCTION DECREASE OF MORE THAN V(SCTOL).  
C             8 = FALSE CONVERGENCE.  THE ITERATES APPEAR TO BE CONVERG-
C                  ING TO A NONCRITICAL POINT.  THIS MAY MEAN THAT THE  
C                  CONVERGENCE TOLERANCES (V(AFCTOL), V(RFCTOL),        
C                  V(XCTOL)) ARE TOO SMALL FOR THE ACCURACY TO WHICH    
C                  THE FUNCTION AND GRADIENT ARE BEING COMPUTED, THAT   
C                  THERE IS AN ERROR IN COMPUTING THE GRADIENT, OR THAT 
C                  THE FUNCTION OR GRADIENT IS DISCONTINUOUS NEAR X.    
C             9 = FUNCTION EVALUATION LIMIT REACHED WITHOUT OTHER CON-  
C                  VERGENCE (SEE IV(MXFCAL)).                           
C            10 = ITERATION LIMIT REACHED WITHOUT OTHER CONVERGENCE     
C                  (SEE IV(MXITER)).                                    
C            11 = STOPX RETURNED .TRUE. (EXTERNAL INTERRUPT).  SEE THE  
C                  USAGE NOTES BELOW.                                   
C            14 = STORAGE HAS BEEN ALLOCATED (AFTER A CALL WITH         
C                  IV(1) = 13).                                         
C            17 = RESTART ATTEMPTED WITH N CHANGED.                     
C            18 = D HAS A NEGATIVE COMPONENT AND IV(DTYPE) .LE. 0.      
C            19...43 = V(IV(1)) IS OUT OF RANGE.                        
C            63 = F(X) CANNOT BE COMPUTED AT THE INITIAL X.             
C            64 = BAD PARAMETERS PASSED TO ASSESS (WHICH SHOULD NOT     
C                  OCCUR).                                              
C            65 = THE GRADIENT COULD NOT BE COMPUTED AT X (SEE CALCG    
C                  ABOVE).                                              
C            67 = BAD FIRST PARAMETER TO IVSET.                         
C            80 = IV(1) WAS OUT OF RANGE.                               
C            81 = N IS NOT POSITIVE.                                    
C IV(G)........ IV(28) IS THE STARTING SUBSCRIPT IN V OF THE CURRENT    
C             GRADIENT VECTOR (THE ONE CORRESPONDING TO X).             
C IV(LASTIV)... IV(44) IS THE LEAST ACCEPTABLE VALUE OF LIV.  (IT IS    
C             ONLY SET IF LIV IS AT LEAST 44.)                          
C IV(LASTV).... IV(45) IS THE LEAST ACCEPTABLE VALUE OF LV.  (IT IS     
C             ONLY SET IF LIV IS LARGE ENOUGH, AT LEAST IV(LASTIV).)    
C IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCF (I.E.,
C             FUNCTION EVALUATIONS).                                    
C IV(NGCALL)... IV(30) IS THE NUMBER OF GRADIENT EVALUATIONS (CALLS ON  
C             CALCG).                                                   
C IV(NITER).... IV(31) IS THE NUMBER OF ITERATIONS PERFORMED.           
C                                                                       
C  ***  (SELECTED) V INPUT VALUES (FROM SUBROUTINE IVSET)  ***          
C                                                                       
C V(BIAS)..... V(43) IS THE BIAS PARAMETER USED IN SUBROUTINE DBLDOG -- 
C             SEE THAT SUBROUTINE FOR DETAILS.  DEFAULT = 0.8.          
C V(AFCTOL)... V(31) IS THE ABSOLUTE FUNCTION CONVERGENCE TOLERANCE.    
C             IF   MNG FINDS A POINT WHERE THE FUNCTION VALUE IS LESS   
C             THAN V(AFCTOL) IN ABSOLUTE VALUE, AND IF   MNG DOES NOT   
C             RETURN WITH IV(1) = 3, 4, OR 5, THEN IT RETURNS WITH      
C             IV(1) = 6.  THIS TEST CAN BE TURNED OFF BY SETTING        
C             V(AFCTOL) TO ZERO.  DEFAULT = MAX(10**-20, MACHEP**2),    
C             WHERE MACHEP IS THE UNIT ROUNDOFF.                        
C V(DINIT).... V(38), IF NONNEGATIVE, IS THE VALUE TO WHICH THE SCALE   
C             VECTOR D IS INITIALIZED.  DEFAULT = -1.                   
C V(LMAX0).... V(35) GIVES THE MAXIMUM 2-NORM ALLOWED FOR D TIMES THE   
C             VERY FIRST STEP THAT   MNG ATTEMPTS.  THIS PARAMETER CAN  
C             MARKEDLY AFFECT THE PERFORMANCE OF   MNG.                 
C V(LMAXS).... V(36) IS USED IN TESTING FOR SINGULAR CONVERGENCE -- IF  
C             THE FUNCTION REDUCTION PREDICTED FOR A STEP OF LENGTH     
C             BOUNDED BY V(LMAXS) IS AT MOST V(SCTOL) * ABS(F0), WHERE  
C             F0  IS THE FUNCTION VALUE AT THE START OF THE CURRENT     
C             ITERATION, AND IF   MNG DOES NOT RETURN WITH IV(1) = 3,   
C             4, 5, OR 6, THEN IT RETURNS WITH IV(1) = 7.  DEFAULT = 1. 
C V(RFCTOL)... V(32) IS THE RELATIVE FUNCTION CONVERGENCE TOLERANCE.    
C             IF THE CURRENT MODEL PREDICTS A MAXIMUM POSSIBLE FUNCTION 
C             REDUCTION (SEE V(NREDUC)) OF AT MOST V(RFCTOL)*ABS(F0)    
C             AT THE START OF THE CURRENT ITERATION, WHERE  F0  IS THE  
C             THEN CURRENT FUNCTION VALUE, AND IF THE LAST STEP ATTEMPT-
C             ED ACHIEVED NO MORE THAN TWICE THE PREDICTED FUNCTION     
C             DECREASE, THEN   MNG RETURNS WITH IV(1) = 4 (OR 5).       
C             DEFAULT = MAX(10**-10, MACHEP**(2/3)), WHERE MACHEP IS    
C             THE UNIT ROUNDOFF.                                        
C V(SCTOL).... V(37) IS THE SINGULAR CONVERGENCE TOLERANCE -- SEE THE   
C             DESCRIPTION OF V(LMAXS) ABOVE.                            
C V(TUNER1)... V(26) HELPS DECIDE WHEN TO CHECK FOR FALSE CONVERGENCE.  
C             THIS IS DONE IF THE ACTUAL FUNCTION DECREASE FROM THE     
C             CURRENT STEP IS NO MORE THAN V(TUNER1) TIMES ITS PREDICT- 
C             ED VALUE.  DEFAULT = 0.1.                                 
C V(XCTOL).... V(33) IS THE X-CONVERGENCE TOLERANCE.  IF A NEWTON STEP  
C             (SEE V(NREDUC)) IS TRIED THAT HAS V(RELDX) .LE. V(XCTOL)  
C             AND IF THIS STEP YIELDS AT MOST TWICE THE PREDICTED FUNC- 
C             TION DECREASE, THEN   MNG RETURNS WITH IV(1) = 3 (OR 5).  
C             (SEE THE DESCRIPTION OF V(RELDX) BELOW.)                  
C             DEFAULT = MACHEP**0.5, WHERE MACHEP IS THE UNIT ROUNDOFF. 
C V(XFTOL).... V(34) IS THE FALSE CONVERGENCE TOLERANCE.  IF A STEP IS  
C             TRIED THAT GIVES NO MORE THAN V(TUNER1) TIMES THE PREDICT-
C             ED FUNCTION DECREASE AND THAT HAS V(RELDX) .LE. V(XFTOL), 
C             AND IF   MNG DOES NOT RETURN WITH IV(1) = 3, 4, 5, 6, OR  
C             7, THEN IT RETURNS WITH IV(1) = 8.  (SEE THE DESCRIPTION  
C             OF V(RELDX) BELOW.)  DEFAULT = 100*MACHEP, WHERE          
C             MACHEP IS THE UNIT ROUNDOFF.                              
C V(*)........ IVSET SUPPLIES TO V A NUMBER OF TUNING CONSTANTS, WITH   
C             WHICH IT SHOULD ORDINARILY BE UNNECESSARY TO TINKER.  SEE 
C             SECTION 17 OF VERSION 2.2 OF THE NL2SOL USAGE SUMMARY     
C             (I.E., THE APPENDIX TO REF. 1) FOR DETAILS ON V(I),       
C             I = DECFAC, INCFAC, PHMNFC, PHMXFC, RDFCMN, RDFCMX,       
C             TUNER2, TUNER3, TUNER4, TUNER5.                           
C                                                                       
C  ***  (SELECTED) V OUTPUT VALUES  ***                                 
C                                                                       
C V(DGNORM)... V(1) IS THE 2-NORM OF (DIAG(D)**-1)*G, WHERE G IS THE    
C             MOST RECENTLY COMPUTED GRADIENT.                          
C V(DSTNRM)... V(2) IS THE 2-NORM OF DIAG(D)*STEP, WHERE STEP IS THE    
C             CURRENT STEP.                                             
C V(F)........ V(10) IS THE CURRENT FUNCTION VALUE.                     
C V(F0)....... V(13) IS THE FUNCTION VALUE AT THE START OF THE CURRENT  
C             ITERATION.                                                
C V(NREDUC)... V(6), IF POSITIVE, IS THE MAXIMUM FUNCTION REDUCTION     
C             POSSIBLE ACCORDING TO THE CURRENT MODEL, I.E., THE FUNC-  
C             TION REDUCTION PREDICTED FOR A NEWTON STEP (I.E.,         
C             STEP = -H**-1 * G,  WHERE  G  IS THE CURRENT GRADIENT AND 
C             H IS THE CURRENT HESSIAN APPROXIMATION).                  
C                  IF V(NREDUC) IS NEGATIVE, THEN IT IS THE NEGATIVE OF 
C             THE FUNCTION REDUCTION PREDICTED FOR A STEP COMPUTED WITH 
C             A STEP BOUND OF V(LMAXS) FOR USE IN TESTING FOR SINGULAR  
C             CONVERGENCE.                                              
C V(PREDUC)... V(7) IS THE FUNCTION REDUCTION PREDICTED (BY THE CURRENT 
C             QUADRATIC MODEL) FOR THE CURRENT STEP.  THIS (DIVIDED BY  
C             V(F0)) IS USED IN TESTING FOR RELATIVE FUNCTION           
C             CONVERGENCE.                                              
C V(RELDX).... V(17) IS THE SCALED RELATIVE CHANGE IN X CAUSED BY THE   
C             CURRENT STEP, COMPUTED AS                                 
C                  MAX(ABS(D(I)*(X(I)-X0(I)), 1 .LE. I .LE. P) /        
C                     MAX(D(I)*(ABS(X(I))+ABS(X0(I))), 1 .LE. I .LE. P),
C             WHERE X = X0 + STEP.                                      
C                                                                       
C-------------------------------  NOTES  -------------------------------
C                                                                       
C  ***  ALGORITHM NOTES  ***                                            
C                                                                       
C        THIS ROUTINE USES A HESSIAN APPROXIMATION COMPUTED FROM THE    
C     BFGS UPDATE (SEE REF 3).  ONLY A CHOLESKY FACTOR OF THE HESSIAN   
C     APPROXIMATION IS STORED, AND THIS IS UPDATED USING IDEAS FROM     
C     REF. 4.  STEPS ARE COMPUTED BY THE DOUBLE DOGLEG SCHEME DESCRIBED 
C     IN REF. 2.  THE STEPS ARE ASSESSED AS IN REF. 1.                  
C                                                                       
C  ***  USAGE NOTES  ***                                                
C                                                                       
C        AFTER A RETURN WITH IV(1) .LE. 11, IT IS POSSIBLE TO RESTART,  
C     I.E., TO CHANGE SOME OF THE IV AND V INPUT VALUES DESCRIBED ABOVE 
C     AND CONTINUE THE ALGORITHM FROM THE POINT WHERE IT WAS INTERRUPT- 
C     ED.  IV(1) SHOULD NOT BE CHANGED, NOR SHOULD ANY ENTRIES OF IV    
C     AND V OTHER THAN THE INPUT VALUES (THOSE SUPPLIED BY IVSET).      
C        THOSE WHO DO NOT WISH TO WRITE A CALCG WHICH COMPUTES THE      
C     GRADIENT ANALYTICALLY SHOULD CALL   MNF RATHER THAN   MNG.        
C       MNF USES FINITE DIFFERENCES TO COMPUTE AN APPROXIMATE GRADIENT. 
C        THOSE WHO WOULD PREFER TO PROVIDE F AND G (THE FUNCTION AND    
C     GRADIENT) BY REVERSE COMMUNICATION RATHER THAN BY WRITING SUBROU- 
C     TINES CALCF AND CALCG MAY CALL ON  RMNG DIRECTLY.  SEE THE COM-   
C     MENTS AT THE BEGINNING OF  RMNG.                                  
C        THOSE WHO USE   MNG INTERACTIVELY MAY WISH TO SUPPLY THEIR     
C     OWN STOPX FUNCTION, WHICH SHOULD RETURN .TRUE. IF THE BREAK KEY   
C     HAS BEEN PRESSED SINCE STOPX WAS LAST INVOKED.  THIS MAKES IT     
C     POSSIBLE TO EXTERNALLY INTERRUPT   MNG (WHICH WILL RETURN WITH    
C     IV(1) = 11 IF STOPX RETURNS .TRUE.).                              
C        STORAGE FOR G IS ALLOCATED AT THE END OF V.  THUS THE CALLER   
C     MAY MAKE V LONGER THAN SPECIFIED ABOVE AND MAY ALLOW CALCG TO USE 
C     ELEMENTS OF G BEYOND THE FIRST N AS SCRATCH STORAGE.              
C                                                                       
C  ***  PORTABILITY NOTES  ***                                          
C                                                                       
C        THE   MNG DISTRIBUTION TAPE CONTAINS BOTH SINGLE- AND DOUBLE-  
C     PRECISION VERSIONS OF THE   MNG SOURCE CODE, SO IT SHOULD BE UN-  
C     NECESSARY TO CHANGE PRECISIONS.                                   
C        ONLY THE FUNCTIONS I7MDCN AND  R7MDC CONTAIN MACHINE-DEPENDENT 
C     CONSTANTS.  TO CHANGE FROM ONE MACHINE TO ANOTHER, IT SHOULD      
C     SUFFICE TO CHANGE THE (FEW) RELEVANT LINES IN THESE FUNCTIONS.    
C        INTRINSIC FUNCTIONS ARE EXPLICITLY DECLARED.  ON CERTAIN COM-  
C     PUTERS (E.G. UNIVAC), IT MAY BE NECESSARY TO COMMENT OUT THESE    
C     DECLARATIONS.  SO THAT THIS MAY BE DONE AUTOMATICALLY BY A SIMPLE 
C     PROGRAM, SUCH DECLARATIONS ARE PRECEDED BY A COMMENT HAVING C/+   
C     IN COLUMNS 1-3 AND BLANKS IN COLUMNS 4-72 AND ARE FOLLOWED BY     
C     A COMMENT HAVING C/ IN COLUMNS 1 AND 2 AND BLANKS IN COLUMNS 3-72.
C        THE   MNG SOURCE CODE IS EXPRESSED IN 1966 ANSI STANDARD       
C     FORTRAN.  IT MAY BE CONVERTED TO FORTRAN 77 BY COMMENTING OUT ALL 
C     LINES THAT FALL BETWEEN A LINE HAVING C/6 IN COLUMNS 1-3 AND A    
C     LINE HAVING C/7 IN COLUMNS 1-3 AND BY REMOVING (I.E., REPLACING   
C     BY A BLANK) THE C IN COLUMN 1 OF THE LINES THAT FOLLOW THE C/7    
C     LINE AND PRECEDE A LINE HAVING C/ IN COLUMNS 1-2 AND BLANKS IN    
C     COLUMNS 3-72.  THESE CHANGES CONVERT SOME DATA STATEMENTS INTO    
C     PARAMETER STATEMENTS, CONVERT SOME VARIABLES FROM REAL TO         
C     CHARACTER*4, AND MAKE THE DATA STATEMENTS THAT INITIALIZE THESE   
C     VARIABLES USE CHARACTER STRINGS DELIMITED BY PRIMES INSTEAD       
C     OF HOLLERITH CONSTANTS.  (SUCH VARIABLES AND DATA STATEMENTS      
C     APPEAR ONLY IN MODULES ITSUM AND PARCK.  PARAMETER STATEMENTS     
C     APPEAR NEARLY EVERYWHERE.)  THESE CHANGES ALSO ADD SAVE STATE-    
C     MENTS FOR VARIABLES GIVEN MACHINE-DEPENDENT CONSTANTS BY  R7MDC.  
C                                                                       
C  ***  REFERENCES  ***                                                 
C                                                                       
C 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1981), ALGORITHM 573 --
C             AN ADAPTIVE NONLINEAR LEAST-SQUARES ALGORITHM, ACM TRANS. 
C             MATH. SOFTWARE 7, PP. 369-383.                            
C                                                                       
C 2.  DENNIS, J.E., AND MEI, H.H.W. (1979), TWO NEW UNCONSTRAINED OPTI- 
C             MIZATION ALGORITHMS WHICH USE FUNCTION AND GRADIENT       
C             VALUES, J. OPTIM. THEORY APPLIC. 28, PP. 453-482.         
C                                                                       
C 3.  DENNIS, J.E., AND MORE, J.J. (1977), QUASI-NEWTON METHODS, MOTIVA-
C             TION AND THEORY, SIAM REV. 19, PP. 46-89.                 
C                                                                       
C 4.  GOLDFARB, D. (1976), FACTORIZED VARIABLE METRIC METHODS FOR UNCON-
C             STRAINED OPTIMIZATION, MATH. COMPUT. 30, PP. 796-811.     
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (WINTER 1980).  REVISED SUMMER 1982.        
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH           
C     SUPPORTED IN PART BY THE NATIONAL SCIENCE FOUNDATION UNDER        
C     GRANTS MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989,        
C     AND MCS-7906671.                                                  
C.                                                                      
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL IVSET,  RMNG                                             
C                                                                       
C IVSET... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                  
C  RMNG... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT   MNG ALGO-   
C             RITHM.                                                    
C                                                                       
      INTEGER G1, IV1, NF                                               
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NEXTV, NFCALL, NFGCAL, G, TOOBIG, VNEED                   
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, TOOBIG/2/, VNEED/4/  
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, TOOBIG=2, VNEED=4) 
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 12 .OR. IV1 .EQ. 13) IV(VNEED) = IV(VNEED) + N       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  RMNG(D, F, V(G1), IV, LIV, LV, N, V, X)                     
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F, UIPARM, URPARM, UFPARM)                   
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCG(N, X, NF, V(G1), UIPARM, URPARM, UFPARM)               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(NEXTV) = IV(G) + N                                             
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF   MNG FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE   MNGB(N, D, X, B, CALCF, CALCG, IV, LIV, LV, V,       
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  MINIMIZE GENERAL SIMPLY BOUNDED OBJECTIVE FUNCTION USING  ***   
C  ***  ANALYTIC GRADIENT AND HESSIAN APPROX. FROM SECANT UPDATE  ***   
C                                                                       
      INTEGER N, LIV, LV                                                
      INTEGER IV(LIV), UIPARM(1)                                        
      REAL D(N), X(N), B(2,N), V(LV), URPARM(1)                         
C     DIMENSION V(71 + N*(N+15)/2), UIPARM(*), URPARM(*)                
      EXTERNAL CALCF, CALCG, UFPARM                                     
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        THIS ROUTINE IS LIKE   MNG, EXCEPT FOR THE EXTRA PARAMETER B,  
C     AN ARRAY OF LOWER AND UPPER BOUNDS ON X...   MNGB ENFORCES THE    
C     CONSTRAINTS THAT  B(1,I) .LE. X(I) .LE. B(2,I), I = 1(1)N.        
C     (INSTEAD OF CALLING  RMNG,   MNGB CALLS  RMNGB.)                  
C.                                                                      
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL IVSET,  RMNGB                                            
C                                                                       
C IVSET.... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                 
C  RMNGB... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT   MNG ALGO-  
C             RITHM.                                                    
C                                                                       
      INTEGER G1, IV1, NF                                               
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER NEXTV, NFCALL, NFGCAL, G, TOOBIG, VNEED                   
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, TOOBIG/2/, VNEED/4/  
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, TOOBIG=2, VNEED=4) 
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + N                      
      CALL  RMNGB(B, D, F, V, IV, LIV, LV, N, V, X)                     
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(NEXTV) = IV(G) + N                                             
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  RMNGB(B, D, F, V(G1), IV, LIV, LV, N, V, X)                 
      IF (IV(1) - 2) 30, 40, 999                                        
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F, UIPARM, URPARM, UFPARM)                   
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCG(N, X, NF, V(G1), UIPARM, URPARM, UFPARM)               
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF   MNGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   MNH(N, D, X, CALCF, CALCGH, IV, LIV, LV, V,          
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING   ***   
C  ***  (ANALYTIC) GRADIENT AND HESSIAN PROVIDED BY THE CALLER.   ***   
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV), UIPARM(1)                                        
      REAL D(N), X(N), V(LV), URPARM(1)                                 
C     DIMENSION V(78 + N*(N+12)), UIPARM(*), URPARM(*)                  
      EXTERNAL CALCF, CALCGH, UFPARM                                    
C                                                                       
C------------------------------  DISCUSSION  ---------------------------
C                                                                       
C        THIS ROUTINE IS LIKE   MNG, EXCEPT THAT THE SUBROUTINE PARA-   
C     METER CALCG OF   MNG (WHICH COMPUTES THE GRADIENT OF THE OBJEC-   
C     TIVE FUNCTION) IS REPLACED BY THE SUBROUTINE PARAMETER CALCGH,    
C     WHICH COMPUTES BOTH THE GRADIENT AND (LOWER TRIANGLE OF THE)      
C     HESSIAN OF THE OBJECTIVE FUNCTION.  THE CALLING SEQUENCE IS...    
C             CALL CALCGH(N, X, NF, G, H, UIPARM, URPARM, UFPARM)       
C     PARAMETERS N, X, NF, G, UIPARM, URPARM, AND UFPARM ARE THE SAME   
C     AS FOR   MNG, WHILE H IS AN ARRAY OF LENGTH N*(N+1)/2 IN WHICH    
C     CALCGH MUST STORE THE LOWER TRIANGLE OF THE HESSIAN AT X.  START- 
C     ING AT H(1), CALCGH MUST STORE THE HESSIAN ENTRIES IN THE ORDER   
C     (1,1), (2,1), (2,2), (3,1), (3,2), (3,3), ...                     
C        THE VALUE PRINTED (BY ITSUM) IN THE COLUMN LABELLED STPPAR     
C     IS THE LEVENBERG-MARQUARDT USED IN COMPUTING THE CURRENT STEP.    
C     ZERO MEANS A FULL NEWTON STEP.  IF THE SPECIAL CASE DESCRIBED IN  
C     REF. 1 IS DETECTED, THEN STPPAR IS NEGATED.  THE VALUE PRINTED    
C     IN THE COLUMN LABELLED NPRELDF IS ZERO IF THE CURRENT HESSIAN     
C     IS NOT POSITIVE DEFINITE.                                         
C        IT SOMETIMES PROVES WORTHWHILE TO LET D BE DETERMINED FROM THE 
C     DIAGONAL OF THE HESSIAN MATRIX BY SETTING IV(DTYPE) = 1 AND       
C     V(DINIT) = 0.  THE FOLLOWING IV AND V COMPONENTS ARE RELEVANT...  
C                                                                       
C IV(DTOL)..... IV(59) GIVES THE STARTING SUBSCRIPT IN V OF THE DTOL    
C             ARRAY USED WHEN D IS UPDATED.  (IV(DTOL) CAN BE           
C             INITIALIZED BY CALLING   MNH WITH IV(1) = 13.)            
C IV(DTYPE).... IV(16) TELLS HOW THE SCALE VECTOR D SHOULD BE CHOSEN.   
C             IV(DTYPE) .LE. 0 MEANS THAT D SHOULD NOT BE UPDATED, AND  
C             IV(DTYPE) .GE. 1 MEANS THAT D SHOULD BE UPDATED AS        
C             DESCRIBED BELOW WITH V(DFAC).  DEFAULT = 0.               
C V(DFAC)..... V(41) AND THE DTOL AND D0 ARRAYS (SEE V(DTINIT) AND      
C             V(D0INIT)) ARE USED IN UPDATING THE SCALE VECTOR D WHEN   
C             IV(DTYPE) .GT. 0.  (D IS INITIALIZED ACCORDING TO         
C             V(DINIT), DESCRIBED IN   MNG.)  LET                       
C                  D1(I) = MAX(SQRT(ABS(H(I,I))), V(DFAC)*D(I)),        
C             WHERE H(I,I) IS THE I-TH DIAGONAL ELEMENT OF THE CURRENT  
C             HESSIAN.  IF IV(DTYPE) = 1, THEN D(I) IS SET TO D1(I)     
C             UNLESS D1(I) .LT. DTOL(I), IN WHICH CASE D(I) IS SET TO   
C                  MAX(D0(I), DTOL(I)).                                 
C             IF IV(DTYPE) .GE. 2, THEN D IS UPDATED DURING THE FIRST   
C             ITERATION AS FOR IV(DTYPE) = 1 (AFTER ANY INITIALIZATION  
C             DUE TO V(DINIT)) AND IS LEFT UNCHANGED THEREAFTER.        
C             DEFAULT = 0.6.                                            
C V(DTINIT)... V(39), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS 
C             OF THE DTOL ARRAY (SEE V(DFAC)) ARE INITIALIZED.  IF      
C             V(DTINIT) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS     
C             STORED DTOL IN V STARTING AT V(IV(DTOL)).                 
C             DEFAULT = 10**-6.                                         
C V(D0INIT)... V(40), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS 
C             OF THE D0 VECTOR (SEE V(DFAC)) ARE INITIALIZED.  IF       
C             V(DFAC) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS       
C             STORED D0 IN V STARTING AT V(IV(DTOL)+N).  DEFAULT = 1.0. 
C                                                                       
C  ***  REFERENCE  ***                                                  
C                                                                       
C 1. GAY, D.M. (1981), COMPUTING OPTIMAL LOCALLY CONSTRAINED STEPS,     
C         SIAM J. SCI. STATIST. COMPUT. 2, PP. 186-197.                 
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (WINTER 1980).  REVISED SEPT. 1982.         
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH SUPPORTED 
C     IN PART BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS           
C     MCS-7600324 AND MCS-7906671.                                      
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL IVSET,  RMNH                                             
C                                                                       
C IVSET... PROVIDES DEFAULT INPUT VALUES FOR IV AND V.                  
C  RMNH... REVERSE-COMMUNICATION ROUTINE THAT DOES   MNH ALGORITHM.     
C                                                                       
      INTEGER G1, H1, IV1, LH, NF                                       
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER G, H, NEXTV, NFCALL, NFGCAL, TOOBIG, VNEED                
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, H/56/, TOOBIG/2/,    
C    1     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, H=56, TOOBIG=2,    
     1           VNEED=4)                                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = N * (N + 1) / 2                                              
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IF (IV(1) .EQ. 12 .OR. IV(1) .EQ. 13)                             
     1     IV(VNEED) = IV(VNEED) + N*(N+3)/2                            
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      H1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
      H1 = IV(H)                                                        
C                                                                       
 20   CALL  RMNH(D, F, V(G1), V(H1), IV, LH, LIV, LV, N, V, X)          
      IF (IV(1) - 2) 30, 40, 50                                         
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F, UIPARM, URPARM, UFPARM)                   
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCGH(N, X, NF, V(G1), V(H1), UIPARM, URPARM, UFPARM)       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 50   IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(H) = IV(G) + N                                                 
      IV(NEXTV) = IV(H) + N*(N+1)/2                                     
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF   MNH FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE   MNHB(N, D, X, B, CALCF, CALCGH, IV, LIV, LV, V,      
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  MINIMIZE GENERAL SIMPLY BOUNDED OBJECTIVE FUNCTION USING   ***  
C  ***  (ANALYTIC) GRADIENT AND HESSIAN PROVIDED BY THE CALLER.    ***  
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV), UIPARM(1)                                        
      REAL B(2,N), D(N), X(N), V(LV), URPARM(1)                         
C     DIMENSION V(78 + N*(N+12)), UIPARM(*), URPARM(*)                  
      EXTERNAL CALCF, CALCGH, UFPARM                                    
C                                                                       
C------------------------------  DISCUSSION  ---------------------------
C                                                                       
C        THIS ROUTINE IS LIKE   MNGB, EXCEPT THAT THE SUBROUTINE PARA-  
C     METER CALCG OF   MNGB (WHICH COMPUTES THE GRADIENT OF THE OBJEC-  
C     TIVE FUNCTION) IS REPLACED BY THE SUBROUTINE PARAMETER CALCGH,    
C     WHICH COMPUTES BOTH THE GRADIENT AND (LOWER TRIANGLE OF THE)      
C     HESSIAN OF THE OBJECTIVE FUNCTION.  THE CALLING SEQUENCE IS...    
C             CALL CALCGH(N, X, NF, G, H, UIPARM, URPARM, UFPARM)       
C     PARAMETERS N, X, NF, G, UIPARM, URPARM, AND UFPARM ARE THE SAME   
C     AS FOR   MNGB, WHILE H IS AN ARRAY OF LENGTH N*(N+1)/2 IN WHICH   
C     CALCGH MUST STORE THE LOWER TRIANGLE OF THE HESSIAN AT X.  START- 
C     ING AT H(1), CALCGH MUST STORE THE HESSIAN ENTRIES IN THE ORDER   
C     (1,1), (2,1), (2,2), (3,1), (3,2), (3,3), ...                     
C        THE VALUE PRINTED (BY ITSUM) IN THE COLUMN LABELLED STPPAR     
C     IS THE LEVENBERG-MARQUARDT USED IN COMPUTING THE CURRENT STEP.    
C     ZERO MEANS A FULL NEWTON STEP.  IF THE SPECIAL CASE DESCRIBED IN  
C     REF. 1 IS DETECTED, THEN STPPAR IS NEGATED.  THE VALUE PRINTED    
C     IN THE COLUMN LABELLED NPRELDF IS ZERO IF THE CURRENT HESSIAN     
C     IS NOT POSITIVE DEFINITE.                                         
C        IT SOMETIMES PROVES WORTHWHILE TO LET D BE DETERMINED FROM THE 
C     DIAGONAL OF THE HESSIAN MATRIX BY SETTING IV(DTYPE) = 1 AND       
C     V(DINIT) = 0.  THE FOLLOWING IV AND V COMPONENTS ARE RELEVANT...  
C                                                                       
C IV(DTOL)..... IV(59) GIVES THE STARTING SUBSCRIPT IN V OF THE DTOL    
C             ARRAY USED WHEN D IS UPDATED.  (IV(DTOL) CAN BE           
C             INITIALIZED BY CALLING   MNHB WITH IV(1) = 13.)           
C IV(DTYPE).... IV(16) TELLS HOW THE SCALE VECTOR D SHOULD BE CHOSEN.   
C             IV(DTYPE) .LE. 0 MEANS THAT D SHOULD NOT BE UPDATED, AND  
C             IV(DTYPE) .GE. 1 MEANS THAT D SHOULD BE UPDATED AS        
C             DESCRIBED BELOW WITH V(DFAC).  DEFAULT = 0.               
C V(DFAC)..... V(41) AND THE DTOL AND D0 ARRAYS (SEE V(DTINIT) AND      
C             V(D0INIT)) ARE USED IN UPDATING THE SCALE VECTOR D WHEN   
C             IV(DTYPE) .GT. 0.  (D IS INITIALIZED ACCORDING TO         
C             V(DINIT), DESCRIBED IN   MNG.)  LET                       
C                  D1(I) = MAX(SQRT(ABS(H(I,I))), V(DFAC)*D(I)),        
C             WHERE H(I,I) IS THE I-TH DIAGONAL ELEMENT OF THE CURRENT  
C             HESSIAN.  IF IV(DTYPE) = 1, THEN D(I) IS SET TO D1(I)     
C             UNLESS D1(I) .LT. DTOL(I), IN WHICH CASE D(I) IS SET TO   
C                  MAX(D0(I), DTOL(I)).                                 
C             IF IV(DTYPE) .GE. 2, THEN D IS UPDATED DURING THE FIRST   
C             ITERATION AS FOR IV(DTYPE) = 1 (AFTER ANY INITIALIZATION  
C             DUE TO V(DINIT)) AND IS LEFT UNCHANGED THEREAFTER.        
C             DEFAULT = 0.6.                                            
C V(DTINIT)... V(39), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS 
C             OF THE DTOL ARRAY (SEE V(DFAC)) ARE INITIALIZED.  IF      
C             V(DTINIT) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS     
C             STORED DTOL IN V STARTING AT V(IV(DTOL)).                 
C             DEFAULT = 10**-6.                                         
C V(D0INIT)... V(40), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS 
C             OF THE D0 VECTOR (SEE V(DFAC)) ARE INITIALIZED.  IF       
C             V(DFAC) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS       
C             STORED D0 IN V STARTING AT V(IV(DTOL)+N).  DEFAULT = 1.0. 
C                                                                       
C  ***  REFERENCE  ***                                                  
C                                                                       
C 1. GAY, D.M. (1981), COMPUTING OPTIMAL LOCALLY CONSTRAINED STEPS,     
C         SIAM J. SCI. STATIST. COMPUT. 2, PP. 186-197.                 
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (WINTER, SPRING 1983).                      
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      EXTERNAL IVSET,  RMNHB                                            
C                                                                       
C IVSET.... PROVIDES DEFAULT INPUT VALUES FOR IV AND V.                 
C  RMNHB... REVERSE-COMMUNICATION ROUTINE THAT DOES   MNHB ALGORITHM.   
C                                                                       
      INTEGER G1, H1, IV1, LH, NF                                       
      REAL F                                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER G, H, NEXTV, NFCALL, NFGCAL, TOOBIG, VNEED                
C                                                                       
C/6                                                                     
C     DATA NEXTV/47/, NFCALL/6/, NFGCAL/7/, G/28/, H/56/, TOOBIG/2/,    
C    1     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (NEXTV=47, NFCALL=6, NFGCAL=7, G=28, H=56, TOOBIG=2,    
     1           VNEED=4)                                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = N * (N + 1) / 2                                              
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + N*(N+3)/2              
      CALL  RMNHB(B, D, F, V, V, IV, LH, LIV, LV, N, V, X)              
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION                                              
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(H) = IV(G) + N                                                 
      IV(NEXTV) = IV(H) + N*(N+1)/2                                     
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   G1 = IV(G)                                                        
      H1 = IV(H)                                                        
C                                                                       
 20   CALL  RMNHB(B, D, F, V(G1), V(H1), IV, LH, LIV, LV, N, V, X)      
      IF (IV(1) - 2) 30, 40, 999                                        
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCF(N, X, NF, F, UIPARM, URPARM, UFPARM)                   
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 40   NF = IV(NFGCAL)                                                   
      CALL CALCGH(N, X, NF, V(G1), V(H1), UIPARM, URPARM, UFPARM)       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 20                                                          
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF   MNHB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE    N2F(N, P, X, CALCR, IV, LIV, LV, V,                 
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  MINIMIZE A NONLINEAR SUM OF SQUARES USING RESIDUAL VALUES ONLY..
C  ***  THIS AMOUNTS TO    N2G WITHOUT THE SUBROUTINE PARAMETER CALCJ.  
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV                                             
C/6                                                                     
C     INTEGER IV(LIV), UIPARM(1)                                        
C     REAL X(P), V(LV), URPARM(1)                                       
C/7                                                                     
      INTEGER IV(LIV), UIPARM(*)                                        
      REAL X(P), V(LV), URPARM(*)                                       
C/                                                                      
      EXTERNAL CALCR, UFPARM                                            
C                                                                       
C-----------------------------  DISCUSSION  ----------------------------
C                                                                       
C        THIS AMOUNTS TO SUBROUTINE NL2SNO (REF. 1) MODIFIED TO CALL    
C       RN2G.                                                           
C        THE PARAMETERS FOR    N2F ARE THE SAME AS THOSE FOR    N2G     
C     (WHICH SEE), EXCEPT THAT CALCJ IS OMITTED.  INSTEAD OF CALLING    
C     CALCJ TO OBTAIN THE JACOBIAN MATRIX OF R AT X,    N2F COMPUTES    
C     AN APPROXIMATION TO IT BY FINITE (FORWARD) DIFFERENCES -- SEE     
C     V(DLTFDJ) BELOW.     N2F USES FUNCTION VALUES ONLY WHEN COMPUT-   
C     THE COVARIANCE MATRIX (RATHER THAN THE FUNCTIONS AND GRADIENTS    
C     THAT    N2G MAY USE).  TO DO SO,    N2F SETS IV(COVREQ) TO MINUS  
C     ITS ABSOLUTE VALUE.  THUS V(DELTA0) IS NEVER REFERENCED AND ONLY  
C     V(DLTFDC) MATTERS -- SEE NL2SOL FOR A DESCRIPTION OF V(DLTFDC).   
C        THE NUMBER OF EXTRA CALLS ON CALCR USED IN COMPUTING THE JACO- 
C     BIAN APPROXIMATION ARE NOT INCLUDED IN THE FUNCTION EVALUATION    
C     COUNT IV(NFCALL), BUT ARE RECORDED IN IV(NGCALL) INSTEAD.         
C                                                                       
C V(DLTFDJ)... V(43) HELPS CHOOSE THE STEP SIZE USED WHEN COMPUTING THE 
C             FINITE-DIFFERENCE JACOBIAN MATRIX.  FOR DIFFERENCES IN-   
C             VOLVING X(I), THE STEP SIZE FIRST TRIED IS                
C                       V(DLTFDJ) * MAX(ABS(X(I)), 1/D(I)),             
C             WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).  (IF    
C             THIS STEP IS TOO BIG, I.E., IF CALCR SETS NF TO 0, THEN   
C             SMALLER STEPS ARE TRIED UNTIL THE STEP SIZE IS SHRUNK BE- 
C             LOW 1000 * MACHEP, WHERE MACHEP IS THE UNIT ROUNDOFF.     
C             DEFAULT = MACHEP**0.5.                                    
C                                                                       
C  ***  REFERENCE  ***                                                  
C                                                                       
C 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1981), AN ADAPTIVE     
C             NONLINEAR LEAST-SQUARES ALGORITHM, ACM TRANS. MATH.       
C             SOFTWARE, VOL. 7, NO. 3.                                  
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,   RN2G,  N2RDP,  V7SCP                            
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C   RN2G... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C  N2RDP... PRINTS REGRESSION DIAGNOSTICS.                              
C  V7SCP... SETS ALL COMPONENTS OF A VECTOR TO A SCALAR.                
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DK, DR1, I, IV1, J1K, K, N1, N2, NF, NG, RD1, R1, RN  
      REAL H, H0, HLIM, NEGPT5, ONE, XK, ZERO                           
C                                                                       
C  ***  IV AND V COMPONENTS  ***                                        
C                                                                       
      INTEGER COVREQ, D, DINIT, DLTFDJ, J, MODE, NEXTV, NFCALL, NFGCAL, 
     1        NGCALL, NGCOV, R, REGD, REGD0, TOOBIG, VNEED              
C/6                                                                     
C     DATA COVREQ/15/, D/27/, DINIT/38/, DLTFDJ/43/, J/70/, MODE/35/,   
C    1     NEXTV/47/, NFCALL/6/, NFGCAL/7/, NGCALL/30/, NGCOV/53/,      
C    2     R/61/, REGD/67/, REGD0/82/, TOOBIG/2/, VNEED/4/              
C/7                                                                     
      PARAMETER (COVREQ=15, D=27, DINIT=38, DLTFDJ=43, J=70, MODE=35,   
     1           NEXTV=47, NFCALL=6, NFGCAL=7, NGCALL=30, NGCOV=53,     
     2           R=61, REGD=67, REGD0=82, TOOBIG=2, VNEED=4)            
C/                                                                      
      DATA HLIM/0.1E+0/, NEGPT5/-0.5E+0/, ONE/1.E+0/, ZERO/0.E+0/       
C                                                                       
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IV(COVREQ) = -IABS(IV(COVREQ))                                    
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + P + N*(P+2)            
      CALL   RN2G(X, V, IV, LIV, LV, N, N, N1, N2, P, V, V, V, X)       
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(D) = IV(NEXTV)                                                 
      IV(R) = IV(D) + P                                                 
      IV(REGD0) = IV(R) + N                                             
      IV(J) = IV(REGD0) + N                                             
      IV(NEXTV) = IV(J) + N*P                                           
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      R1 = IV(R)                                                        
      RN = R1 + N - 1                                                   
      RD1 = IV(REGD0)                                                   
C                                                                       
 20   CALL   RN2G(V(D1), V(DR1), IV, LIV, LV, N, N, N1, N2, P, V(R1),   
     1           V(RD1), V, X)                                          
      IF (IV(1)-2) 30, 50, 100                                          
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCR(N, P, X, NF, V(R1), UIPARM, URPARM, UFPARM)            
      IF (NF .GT. 0) GO TO 40                                           
         IV(TOOBIG) = 1                                                 
         GO TO 20                                                       
 40   IF (IV(1) .GT. 0) GO TO 20                                        
C                                                                       
C  ***  COMPUTE FINITE-DIFFERENCE APPROXIMATION TO DR = GRAD. OF R  *** 
C                                                                       
C     *** INITIALIZE D IF NECESSARY ***                                 
C                                                                       
 50   IF (IV(MODE) .LT. 0 .AND. V(DINIT) .EQ. ZERO)                     
     1        CALL  V7SCP(P, V(D1), ONE)                                
C                                                                       
      J1K = DR1                                                         
      DK = D1                                                           
      NG = IV(NGCALL) - 1                                               
      IF (IV(1) .EQ. (-1)) IV(NGCOV) = IV(NGCOV) - 1                    
      DO 90 K = 1, P                                                    
         XK = X(K)                                                      
         H = V(DLTFDJ) * AMAX1( ABS(XK), ONE/V(DK))                     
         H0 = H                                                         
         DK = DK + 1                                                    
 60      X(K) = XK + H                                                  
         NF = IV(NFGCAL)                                                
         CALL CALCR (N, P, X, NF, V(J1K), UIPARM, URPARM, UFPARM)       
         NG = NG + 1                                                    
         IF (NF .GT. 0) GO TO 70                                        
              H = NEGPT5 * H                                            
              IF ( ABS(H/H0) .GE. HLIM) GO TO 60                        
                   IV(TOOBIG) = 1                                       
                   IV(NGCALL) = NG                                      
                   GO TO 20                                             
 70      X(K) = XK                                                      
         IV(NGCALL) = NG                                                
         DO 80 I = R1, RN                                               
              V(J1K) = (V(J1K) - V(I)) / H                              
              J1K = J1K + 1                                             
 80           CONTINUE                                                  
 90      CONTINUE                                                       
      GO TO 20                                                          
C                                                                       
 100  IF (IV(REGD) .GT. 0) IV(REGD) = RD1                               
      CALL  N2RDP(IV, LIV, LV, N, V(RD1), V)                            
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST LINE OF    N2F FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   N2FB(N, P, X, B, CALCR, IV, LIV, LV, V, UI, UR, UF)  
C                                                                       
C  ***  MINIMIZE A NONLINEAR SUM OF SQUARES USING RESIDUAL VALUES ONLY..
C  ***  THIS AMOUNTS TO    N2G WITHOUT THE SUBROUTINE PARAMETER CALCJ.  
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV                                             
C/6                                                                     
C     INTEGER IV(LIV), UI(1)                                            
C     REAL X(P), B(2,P), V(LV), UR(1)                                   
C/7                                                                     
      INTEGER IV(LIV), UI(*)                                            
      REAL X(P), B(2,P), V(LV), UR(*)                                   
C/                                                                      
      EXTERNAL CALCR, UF                                                
C                                                                       
C-----------------------------  DISCUSSION  ----------------------------
C                                                                       
C        THIS AMOUNTS TO SUBROUTINE NL2SNO (REF. 1) MODIFIED TO HANDLE  
C     SIMPLE BOUNDS ON THE VARIABLES...                                 
C           B(1,I) .LE. X(I) .LE. B(2,I), I = 1(1)P.                    
C        THE PARAMETERS FOR   N2FB ARE THE SAME AS THOSE FOR   N2GB     
C     (WHICH SEE), EXCEPT THAT CALCJ IS OMITTED.  INSTEAD OF CALLING    
C     CALCJ TO OBTAIN THE JACOBIAN MATRIX OF R AT X,   N2FB COMPUTES    
C     AN APPROXIMATION TO IT BY FINITE (FORWARD) DIFFERENCES -- SEE     
C     V(DLTFDJ) BELOW.    N2FB DOES NOT COMPUTE A COVARIANCE MATRIX.    
C        THE NUMBER OF EXTRA CALLS ON CALCR USED IN COMPUTING THE JACO- 
C     BIAN APPROXIMATION ARE NOT INCLUDED IN THE FUNCTION EVALUATION    
C     COUNT IV(NFCALL), BUT ARE RECORDED IN IV(NGCALL) INSTEAD.         
C                                                                       
C V(DLTFDJ)... V(43) HELPS CHOOSE THE STEP SIZE USED WHEN COMPUTING THE 
C             FINITE-DIFFERENCE JACOBIAN MATRIX.  FOR DIFFERENCES IN-   
C             VOLVING X(I), THE STEP SIZE FIRST TRIED IS                
C                       V(DLTFDJ) * MAX(ABS(X(I)), 1/D(I)),             
C             WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).  (IF    
C             THIS STEP IS TOO BIG, I.E., IF CALCR SETS NF TO 0, THEN   
C             SMALLER STEPS ARE TRIED UNTIL THE STEP SIZE IS SHRUNK BE- 
C             LOW 1000 * MACHEP, WHERE MACHEP IS THE UNIT ROUNDOFF.     
C             DEFAULT = MACHEP**0.5.                                    
C                                                                       
C  ***  REFERENCE  ***                                                  
C                                                                       
C 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1981), AN ADAPTIVE     
C             NONLINEAR LEAST-SQUARES ALGORITHM, ACM TRANS. MATH.       
C             SOFTWARE, VOL. 7, NO. 3.                                  
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,  RN2GB,  V7SCP                                    
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C  RN2GB... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C  N2RDP... PRINTS REGRESSION DIAGNOSTICS.                              
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DK, DR1, I, IV1, J1K, K, N1, N2, NF, NG, RD1, R1, RN  
      REAL H, H0, HLIM, NEGPT5, ONE, T, XK, XK1, ZERO                   
C                                                                       
C  ***  IV AND V COMPONENTS  ***                                        
C                                                                       
      INTEGER COVREQ, D, DINIT, DLTFDJ, J, MODE, NEXTV, NFCALL, NFGCAL, 
     1        NGCALL, NGCOV, R, REGD0, TOOBIG, VNEED                    
C/6                                                                     
C     DATA COVREQ/15/, D/27/, DINIT/38/, DLTFDJ/43/, J/70/, MODE/35/,   
C    1     NEXTV/47/, NFCALL/6/, NFGCAL/7/, NGCALL/30/, NGCOV/53/,      
C    2     R/61/, REGD0/82/, TOOBIG/2/, VNEED/4/                        
C/7                                                                     
      PARAMETER (COVREQ=15, D=27, DINIT=38, DLTFDJ=43, J=70, MODE=35,   
     1           NEXTV=47, NFCALL=6, NFGCAL=7, NGCALL=30, NGCOV=53,     
     2           R=61, REGD0=82, TOOBIG=2, VNEED=4)                     
C/                                                                      
      DATA HLIM/0.1E+0/, NEGPT5/-0.5E+0/, ONE/1.E+0/, ZERO/0.E+0/       
C                                                                       
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IV(COVREQ) = 0                                                    
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + P + N*(P+2)            
      CALL  RN2GB(B, X, V, IV, LIV, LV, N, N, N1, N2, P, V, V, V, X)    
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(D) = IV(NEXTV)                                                 
      IV(R) = IV(D) + P                                                 
      IV(REGD0) = IV(R) + N                                             
      IV(J) = IV(REGD0) + N                                             
      IV(NEXTV) = IV(J) + N*P                                           
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      R1 = IV(R)                                                        
      RN = R1 + N - 1                                                   
      RD1 = IV(REGD0)                                                   
C                                                                       
 20   CALL  RN2GB(B, V(D1), V(DR1), IV, LIV, LV, N, N, N1, N2, P, V(R1),
     1           V(RD1), V, X)                                          
      IF (IV(1)-2) 30, 50, 999                                          
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCR(N, P, X, NF, V(R1), UI, UR, UF)                        
      IF (NF .GT. 0) GO TO 40                                           
         IV(TOOBIG) = 1                                                 
         GO TO 20                                                       
 40   IF (IV(1) .GT. 0) GO TO 20                                        
C                                                                       
C  ***  COMPUTE FINITE-DIFFERENCE APPROXIMATION TO DR = GRAD. OF R  *** 
C                                                                       
C     *** INITIALIZE D IF NECESSARY ***                                 
C                                                                       
 50   IF (IV(MODE) .LT. 0 .AND. V(DINIT) .EQ. ZERO)                     
     1        CALL  V7SCP(P, V(D1), ONE)                                
C                                                                       
      J1K = DR1                                                         
      DK = D1                                                           
      NG = IV(NGCALL) - 1                                               
      IF (IV(1) .EQ. (-1)) IV(NGCOV) = IV(NGCOV) - 1                    
      DO 120 K = 1, P                                                   
         IF (B(1,K) .GE. B(2,K)) GO TO 110                              
         XK = X(K)                                                      
         H = V(DLTFDJ) * AMAX1( ABS(XK), ONE/V(DK))                     
         H0 = H                                                         
         DK = DK + 1                                                    
         T = NEGPT5                                                     
         XK1 = XK + H                                                   
         IF (XK - H .GE. B(1,K)) GO TO 60                               
            T = -T                                                      
            IF (XK1 .GT. B(2,K)) GO TO 80                               
 60      IF (XK1 .LE. B(2,K)) GO TO 70                                  
            T = -T                                                      
            H = -H                                                      
            XK1 = XK + H                                                
            IF (XK1 .LT. B(1,K)) GO TO 80                               
 70      X(K) = XK1                                                     
         NF = IV(NFGCAL)                                                
         CALL CALCR (N, P, X, NF, V(J1K), UI, UR, UF)                   
         NG = NG + 1                                                    
         IF (NF .GT. 0) GO TO 90                                        
              H = T * H                                                 
              XK1 = XK + H                                              
              IF ( ABS(H/H0) .GE. HLIM) GO TO 70                        
 80                IV(TOOBIG) = 1                                       
                   IV(NGCALL) = NG                                      
                   GO TO 20                                             
 90      X(K) = XK                                                      
         IV(NGCALL) = NG                                                
         DO 100 I = R1, RN                                              
              V(J1K) = (V(J1K) - V(I)) / H                              
              J1K = J1K + 1                                             
 100          CONTINUE                                                  
         GO TO 120                                                      
C        *** SUPPLY A ZERO DERIVATIVE FOR CONSTANT COMPONENTS...        
 110     CALL  V7SCP(N, V(J1K), ZERO)                                   
         J1K = J1K + N                                                  
 120     CONTINUE                                                       
      GO TO 20                                                          
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF   N2FB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE    N2G(N, P, X, CALCR, CALCJ, IV, LIV, LV, V,          
     1                  UI, UR, UF)                                     
C                                                                       
C  ***  VERSION OF NL2SOL THAT CALLS   RN2G  ***                        
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV                                             
C/6                                                                     
C     INTEGER IV(LIV), UI(1)                                            
C     REAL X(P), V(LV), UR(1)                                           
C/7                                                                     
      INTEGER IV(LIV), UI(*)                                            
      REAL X(P), V(LV), UR(*)                                           
C/                                                                      
      EXTERNAL CALCR, CALCJ, UF                                         
C                                                                       
C  ***  PARAMETER USAGE  ***                                            
C                                                                       
C N....... TOTAL NUMBER OF RESIDUALS.                                   
C P....... NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.      
C X....... PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,     
C             OUTPUT = BEST VALUE FOUND).                               
C CALCR... SUBROUTINE FOR COMPUTING RESIDUAL VECTOR.                    
C CALCJ... SUBROUTINE FOR COMPUTING JACOBIAN MATRIX = MATRIX OF FIRST   
C             PARTIALS OF THE RESIDUAL VECTOR.                          
C IV...... INTEGER VALUES ARRAY.                                        
C LIV..... LENGTH OF IV (SEE DISCUSSION BELOW).                         
C LV...... LENGTH OF V (SEE DISCUSSION BELOW).                          
C V....... FLOATING-POINT VALUES ARRAY.                                 
C UI...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C UR...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C UF...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C                                                                       
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        NOTE... NL2SOL (MENTIONED BELOW) IS A CODE FOR SOLVING         
C     NONLINEAR LEAST-SQUARES PROBLEMS.  IT IS DESCRIBED IN             
C     ACM TRANS. MATH. SOFTWARE, VOL. 9, PP. 369-383 (AN ADAPTIVE       
C     NONLINEAR LEAST-SQUARES ALGORITHM, BY J.E. DENNIS, D.M. GAY,      
C     AND R.E. WELSCH).                                                 
C                                                                       
C        LIV GIVES THE LENGTH OF IV.  IT MUST BE AT LEAST 82+P.  IF NOT,
C     THEN    N2G RETURNS WITH IV(1) = 15.  WHEN    N2G RETURNS, THE    
C     MINIMUM ACCEPTABLE VALUE OF LIV IS STORED IN IV(LASTIV) = IV(44), 
C     (PROVIDED THAT LIV .GE. 44).                                      
C                                                                       
C        LV GIVES THE LENGTH OF V.  THE MINIMUM VALUE FOR LV IS         
C     LV0 = 105 + P*(N + 2*P + 17) + 2*N.  IF LV IS SMALLER THAN THIS,  
C     THEN    N2G RETURNS WITH IV(1) = 16.  WHEN    N2G RETURNS, THE    
C     MINIMUM ACCEPTABLE VALUE OF LV IS STORED IN IV(LASTV) = IV(45)    
C     (PROVIDED LIV .GE. 45).                                           
C                                                                       
C        RETURN CODES AND CONVERGENCE TOLERANCES ARE THE SAME AS FOR    
C     NL2SOL, WITH SOME SMALL EXTENSIONS... IV(1) = 15 MEANS LIV WAS    
C     TOO SMALL.   IV(1) = 16 MEANS LV WAS TOO SMALL.                   
C                                                                       
C        THERE ARE TWO NEW V INPUT COMPONENTS...  V(LMAXS) = V(36) AND  
C     V(SCTOL) = V(37) SERVE WHERE V(LMAX0) AND V(RFCTOL) FORMERLY DID  
C     IN THE SINGULAR CONVERGENCE TEST -- SEE THE NL2SOL DOCUMENTATION. 
C                                                                       
C  ***  DEFAULT VALUES  ***                                             
C                                                                       
C        DEFAULT VALUES ARE PROVIDED BY SUBROUTINE IVSET, RATHER THAN   
C     DFAULT.  THE CALLING SEQUENCE IS...                               
C             CALL IVSET(1, IV, LIV, LV, V)                             
C     THE FIRST PARAMETER IS AN INTEGER 1.  IF LIV AND LV ARE LARGE     
C     ENOUGH FOR IVSET, THEN IVSET SETS IV(1) TO 12.  OTHERWISE IT      
C     SETS IV(1) TO 15 OR 16.  CALLING    N2G WITH IV(1) = 0 CAUSES ALL 
C     DEFAULT VALUES TO BE USED FOR THE INPUT COMPONENTS OF IV AND V.   
C        IF YOU FIRST CALL IVSET, THEN SET IV(1) TO 13 AND CALL    N2G, 
C     THEN STORAGE ALLOCATION ONLY WILL BE PERFORMED.  IN PARTICULAR,   
C     IV(D) = IV(27), IV(J) = IV(70), AND IV(R) = IV(61) WILL BE SET    
C     TO THE FIRST SUBSCRIPT IN V OF THE SCALE VECTOR, THE JACOBIAN     
C     MATRIX, AND THE RESIDUAL VECTOR RESPECTIVELY, PROVIDED LIV AND LV 
C     ARE LARGE ENOUGH.  IF SO, THEN    N2G RETURNS WITH IV(1) = 14.    
C     WHEN CALLED WITH IV(1) = 14,    N2G ASSUMES THAT STORAGE HAS      
C     BEEN ALLOCATED, AND IT BEGINS THE MINIMIZATION ALGORITHM.         
C                                                                       
C  ***  SCALE VECTOR  ***                                               
C                                                                       
C        ONE DIFFERENCE WITH NL2SOL IS THAT THE SCALE VECTOR D IS       
C     STORED IN V, STARTING AT A DIFFERENT SUBSCRIPT.  THE STARTING     
C     SUBSCRIPT VALUE IS STILL STORED IN IV(D) = IV(27).  THE           
C     DISCUSSION OF DEFAULT VALUES ABOVE TELLS HOW TO HAVE IV(D) SET    
C     BEFORE THE ALGORITHM IS STARTED.                                  
C                                                                       
C  ***  REGRESSION DIAGNOSTICS  ***                                     
C                                                                       
C        IF IV(RDREQ) SO DICTATES, THEN ESTIMATES ARE COMPUTED OF THE   
C     INFLUENCE EACH RESIDUAL COMPONENT HAS ON THE FINAL PARAMETER      
C     ESTIMATE X.  THE GENERAL IDEA IS THAT ONE MAY WISH TO EXAMINE     
C     RESIDUAL COMPONENTS (AND THE DATA BEHIND THEM) FOR WHICH THE      
C     INFLUENCE ESTIMATE IS SIGNIFICANTLY LARGER THAN MOST OF THE OTHER 
C     INFLUENCE ESTIMATES.  THESE ESTIMATES, HEREAFTER CALLED           
C     REGRESSION DIAGNOSTICS, ARE ONLY COMPUTED IF IV(RDREQ) = 2 OR 3.  
C     IN THIS CASE, FOR I = 1(1)N,                                      
C                    SQRT( G(I)**T * H(I)**-1 * G(I) )                  
C     IS COMPUTED AND STORED IN V, STARTING AT V(IV(REGD)), WHERE       
C     RDREQ = 57 AND REGD = 67.  HERE G(I) STANDS FOR THE GRADIENT      
C     RESULTING WHEN THE I-TH OBSERVATION IS DELETED AND H(I) STANDS    
C     FOR AN APPROXIMATION TO THE CORRESPONDING HESSIAN AT X, THE SOLU- 
C     TION CORRESPONDING TO ALL OBSERVATIONS.  (THIS APPROXIMATION IS   
C     OBTAINED BY SUBTRACTING THE FIRST-ORDER CONTRIBUTION OF THE I-TH  
C     OBSERVATION TO THE HESSIAN FROM A FINITE-DIFFERENCE HESSIAN       
C     APPROXIMATION.  IF H IS INDEFINITE, THEN IV(REGD) IS SET TO -1.   
C     IF H(I) IS INDEFINITE, THEN -1 IS RETURNED AS THE DIAGNOSTIC FOR  
C     OBSERVATION I.  IF NO DIAGNOSTICS ARE COMPUTED, PERHAPS BECAUSE   
C     OF A FAILURE TO CONVERGE, THEN IV(REGD) = 0 IS RETURNED.)         
C        PRINTING OF THE REGRESSION DIAGNOSTICS IS CONTROLLED BY        
C     IV(COVPRT) = IV(14)...  IF IV(COVPRT) = 3, THEN BOTH THE          
C     COVARIANCE MATRIX AND THE REGRESSION DIAGNOSTICS ARE PRINTED.     
C     IV(COVPRT) = 2 CAUSES ONLY THE REGRESSION DIAGNOSTICS TO BE       
C     PRINTED, IV(COVPRT) = 1 CAUSES ONLY THE COVARIANCE MATRIX TO BE   
C     PRINTED, AND IV(COVPRT) = 0 CAUSES NEITHER TO BE PRINTED.         
C                                                                       
C        RDREQ = 57 AND REGD = 67.                                      
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,   RN2G,  N2RDP                                    
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C   RN2G... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C  N2RDP... PRINTS REGRESSION DIAGNOSTICS.                              
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DR1, IV1, N1, N2, NF, R1, RD1                         
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NFCALL, NFGCAL, R, REGD, REGD0, TOOBIG, VNEED
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, R/61/,        
C    1     REGD/67/, REGD0/82/, TOOBIG/2/, VNEED/4/                     
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NFCALL=6, NFGCAL=7, R=61,        
     1           REGD=67, REGD0=82, TOOBIG=2, VNEED=4)                  
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + P + N*(P+2)            
      CALL   RN2G(X, V, IV, LIV, LV, N, N, N1, N2, P, V, V, V, X)       
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(D) = IV(NEXTV)                                                 
      IV(R) = IV(D) + P                                                 
      IV(REGD0) = IV(R) + N                                             
      IV(J) = IV(REGD0) + N                                             
      IV(NEXTV) = IV(J) + N*P                                           
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      R1 = IV(R)                                                        
      RD1 = IV(REGD0)                                                   
C                                                                       
 20   CALL   RN2G(V(D1), V(DR1), IV, LIV, LV, N, N, N1, N2, P, V(R1),   
     1            V(RD1), V, X)                                         
      IF (IV(1)-2) 30, 50, 60                                           
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCR(N, P, X, NF, V(R1), UI, UR, UF)                        
      IF (NF .GT. 0) GO TO 40                                           
         IV(TOOBIG) = 1                                                 
         GO TO 20                                                       
 40   IF (IV(1) .GT. 0) GO TO 20                                        
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 50   CALL CALCJ(N, P, X, IV(NFGCAL), V(DR1), UI, UR, UF)               
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 20                                                          
C                                                                       
C  ***  INDICATE WHETHER THE REGRESSION DIAGNOSTIC ARRAY WAS COMPUTED   
C  ***  AND PRINT IT IF SO REQUESTED...                                 
C                                                                       
 60   IF (IV(REGD) .GT. 0) IV(REGD) = RD1                               
      CALL  N2RDP(IV, LIV, LV, N, V(RD1), V)                            
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST LINE OF    N2G FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   N2GB(N, P, X, B, CALCR, CALCJ, IV, LIV, LV, V,       
     1                  UIPARM, URPARM, UFPARM)                         
C                                                                       
C  ***  VERSION OF NL2SOL THAT HANDLES SIMPLE BOUNDS ON X  ***          
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, P, LIV, LV                                             
C/6                                                                     
C     INTEGER IV(LIV), UIPARM(1)                                        
C     REAL X(P), B(2,P), V(LV), URPARM(1)                               
C/7                                                                     
      INTEGER IV(LIV), UIPARM(*)                                        
      REAL X(P), B(2,P), V(LV), URPARM(*)                               
C/                                                                      
      EXTERNAL CALCR, CALCJ, UFPARM                                     
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        NOTE... NL2SOL (MENTIONED BELOW) IS A CODE FOR SOLVING         
C     NONLINEAR LEAST-SQUARES PROBLEMS.  IT IS DESCRIBED IN             
C     ACM TRANS. MATH. SOFTWARE, VOL. 9, PP. 369-383 (AN ADAPTIVE       
C     NONLINEAR LEAST-SQUARES ALGORITHM, BY J.E. DENNIS, D.M. GAY,      
C     AND R.E. WELSCH).                                                 
C                                                                       
C        LIV GIVES THE LENGTH OF IV.  IT MUST BE AT LEAST 82 + 4*P.     
C     IF NOT, THEN   N2GB RETURNS WITH IV(1) = 15.  WHEN   N2GB         
C     RETURNS, THE MINIMUM ACCEPTABLE VALUE OF LIV IS STORED IN         
C     IV(LASTIV) = IV(44), (PROVIDED THAT LIV .GE. 44).                 
C                                                                       
C        LV GIVES THE LENGTH OF V.  THE MINIMUM VALUE FOR LV IS         
C     LV0 = 105 + P*(N + 2*P + 21) + 2*N.  IF LV IS SMALLER THAN THIS,  
C     THEN   N2GB RETURNS WITH IV(1) = 16.  WHEN   N2GB RETURNS, THE    
C     MINIMUM ACCEPTABLE VALUE OF LV IS STORED IN IV(LASTV) = IV(45)    
C     (PROVIDED LIV .GE. 45).                                           
C                                                                       
C        RETURN CODES AND CONVERGENCE TOLERANCES ARE THE SAME AS FOR    
C     NL2SOL, WITH SOME SMALL EXTENSIONS... IV(1) = 15 MEANS LIV WAS    
C     TOO SMALL.   IV(1) = 16 MEANS LV WAS TOO SMALL.                   
C                                                                       
C        THERE ARE TWO NEW V INPUT COMPONENTS...  V(LMAXS) = V(36) AND  
C     V(SCTOL) = V(37) SERVE WHERE V(LMAX0) AND V(RFCTOL) FORMERLY DID  
C     IN THE SINGULAR CONVERGENCE TEST -- SEE THE NL2SOL DOCUMENTATION. 
C                                                                       
C  ***  BOUNDS  ***                                                     
C                                                                       
C     THE BOUNDS  B(1,I) .LE. X(I) .LE. B(2,I), I = 1(1)P, ARE ENFORCED.
C                                                                       
C  ***  DEFAULT VALUES  ***                                             
C                                                                       
C        DEFAULT VALUES ARE PROVIDED BY SUBROUTINE IVSET, RATHER THAN   
C     DFAULT.  THE CALLING SEQUENCE IS...                               
C             CALL IVSET(1, IV, LIV, LV, V)                             
C     THE FIRST PARAMETER IS AN INTEGER 1.  IF LIV AND LV ARE LARGE     
C     ENOUGH FOR IVSET, THEN IVSET SETS IV(1) TO 12.  OTHERWISE IT      
C     SETS IV(1) TO 15 OR 16.  CALLING   N2GB WITH IV(1) = 0 CAUSES ALL 
C     DEFAULT VALUES TO BE USED FOR THE INPUT COMPONENTS OF IV AND V.   
C        IF YOU FIRST CALL IVSET, THEN SET IV(1) TO 13 AND CALL   N2GB, 
C     THEN STORAGE ALLOCATION ONLY WILL BE PERFORMED.  IN PARTICULAR,   
C     IV(D) = IV(27), IV(J) = IV(70), AND IV(R) = IV(61) WILL BE SET    
C     TO THE FIRST SUBSCRIPT IN V OF THE SCALE VECTOR, THE JACOBIAN     
C     MATRIX, AND THE RESIDUAL VECTOR RESPECTIVELY, PROVIDED LIV AND LV 
C     ARE LARGE ENOUGH.  IF SO, THEN   N2GB RETURNS WITH IV(1) = 14.    
C     WHEN CALLED WITH IV(1) = 14,   N2GB ASSUMES THAT STORAGE HAS      
C     BEEN ALLOCATED, AND IT BEGINS THE MINIMIZATION ALGORITHM.         
C                                                                       
C  ***  SCALE VECTOR  ***                                               
C                                                                       
C        ONE DIFFERENCE WITH NL2SOL IS THAT THE SCALE VECTOR D IS       
C     STORED IN V, STARTING AT A DIFFERENT SUBSCRIPT.  THE STARTING     
C     SUBSCRIPT VALUE IS STILL STORED IN IV(D) = IV(27).  THE           
C     DISCUSSION OF DEFAULT VALUES ABOVE TELLS HOW TO HAVE IV(D) SET    
C     BEFORE THE ALGORITHM IS STARTED.                                  
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,  RN2GB                                            
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C  RN2GB... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D1, DR1, IV1, N1, N2, NF, R1, RD1                         
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NFCALL, NFGCAL, R, REGD0, TOOBIG, VNEED      
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, R/61/,        
C    1     REGD0/82/, TOOBIG/2/, VNEED/4/                               
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NFCALL=6, NFGCAL=7, R=61,        
     1           REGD0=82, TOOBIG=2, VNEED=4)                           
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .EQ. 13) IV(VNEED) = IV(VNEED) + P + N*(P+2)            
      CALL  RN2GB(B, X, V, IV, LIV, LV, N, N, N1, N2, P, V, V, V, X)    
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(D) = IV(NEXTV)                                                 
      IV(R) = IV(D) + P                                                 
      IV(REGD0) = IV(R) + N                                             
      IV(J) = IV(REGD0) + N                                             
      IV(NEXTV) = IV(J) + N*P                                           
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      R1 = IV(R)                                                        
      RD1 = IV(REGD0)                                                   
C                                                                       
 20   CALL  RN2GB(B, V(D1), V(DR1), IV, LIV, LV, N, N, N1, N2, P, V(R1),
     1            V(RD1), V, X)                                         
      IF (IV(1)-2) 30, 50, 999                                          
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 30   NF = IV(NFCALL)                                                   
      CALL CALCR(N, P, X, NF, V(R1), UIPARM, URPARM, UFPARM)            
      IF (NF .GT. 0) GO TO 40                                           
         IV(TOOBIG) = 1                                                 
         GO TO 20                                                       
 40   IF (IV(1) .GT. 0) GO TO 20                                        
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 50   CALL CALCJ(N, P, X, IV(NFGCAL), V(DR1), UIPARM, URPARM, UFPARM)   
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 20                                                          
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF   N2GB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE    N2P(N, ND, P, X, CALCR, CALCJ, IV, LIV, LV, V,      
     1                  UI, UR, UF)                                     
C                                                                       
C  ***  VERSION OF NL2SOL THAT CALLS   RN2G AND HAS EXPANDED CALLING    
C  ***  SEQUENCES FOR CALCR, CALCJ, ALLOWING THEM TO PROVIDE R AND J    
C  ***  (RESIDUALS AND JACOBIAN) IN CHUNKS.                             
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, ND, P, LIV, LV                                         
C/6                                                                     
C     INTEGER IV(LIV), UI(1)                                            
C     REAL X(P), V(LV), UR(1)                                           
C/7                                                                     
      INTEGER IV(LIV), UI(*)                                            
      REAL X(P), V(LV), UR(*)                                           
C/                                                                      
      EXTERNAL CALCR, CALCJ, UF                                         
C                                                                       
C                                                                       
C  ***  PARAMETER USAGE  ***                                            
C                                                                       
C N....... TOTAL NUMBER OF RESIDUALS.                                   
C ND...... MAXIMUM NUMBER OF RESIDUAL COMPONENTS PROVIDED BY ANY CALL   
C             ON CALCR.                                                 
C P....... NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.      
C X....... PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,     
C             OUTPUT = BEST VALUE FOUND).                               
C CALCR... SUBROUTINE FOR COMPUTING RESIDUAL VECTOR.                    
C CALCJ... SUBROUTINE FOR COMPUTING JACOBIAN MATRIX = MATRIX OF FIRST   
C             PARTIALS OF THE RESIDUAL VECTOR.                          
C IV...... INTEGER VALUES ARRAY.                                        
C LIV..... LENGTH OF IV (SEE DISCUSSION BELOW).                         
C LV...... LENGTH OF V (SEE DISCUSSION BELOW).                          
C V....... FLOATING-POINT VALUES ARRAY.                                 
C UI...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C UR...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C UF...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C                                                                       
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C    THIS ROUTINE IS SIMILAR TO    N2G (WHICH SEE), EXCEPT THAT THE     
C CALLING SEQUENCE FOR CALCR AND CALCJ IS DIFFERENT -- IT ALLOWS        
C THE RESIDUAL VECTOR AND JACOBIAN MATRIX TO BE PASSED IN BLOCKS.       
C                                                                       
C   FOR CALCR, THE CALLING SEQUENCE IS...                               
C                                                                       
C     CALCR(N, ND1, N1, N2, P, X, NF, R, UI, UR, UF)                    
C                                                                       
C   PARAMETERS N, P, X, NF, R, UI, UR, UF ARE AS FOR THE CALCR USED     
C BY NL2SOL OR    N2G.                                                  
C   PARAMETERS ND1, N1, AND N2 ARE INPUTS TO CALCR.  CALCR SHOULD NOT   
C CHANGE ND1 OR N1 (BUT MAY CHANGE N2).                                 
C   ND1 = MIN(N,ND) IS THE MAXIMUM NUMBER OF RESIDUAL COMPONENTS THAT   
C CALCR SHOULD SUPPLY ON ONE CALL.                                      
C   N1 IS THE INDEX OF THE FIRST RESIDUAL COMPONENT THAT CALCR SHOULD   
C SUPPLY ON THIS CALL.                                                  
C   N2 HAS THE VALUE MIN(N, N1+ND1-1) WHEN CALCR IS CALLED.  CALCR      
C MAY SET N2 TO A LOWER VALUE (AT LEAST 1) AND FOR N1 .LE. I .LE. N2    
C SHOULD RETURN RESIDUAL COMPONENT I IN R(I-N1+1), I.E., IN COMPONENTS  
C R(1), R(2), ..., R(N2-N1+1).                                          
C                                                                       
C   FOR CALCJ, THE CALLING SEQUENCE IS...                               
C                                                                       
C     CALCJ(N, ND1, N1, N2, P, X, NF, J, UI, UR, UF)                    
C                                                                       
C   ALL PARAMETERS EXCEPT N2 AND J ARE AS FOR CALCR.  N2 MAY NOT BE     
C CHANGED, BUT OTHERWISE IS AS FOR CALCR.  (WHENEVER CALCJ IS CALLED,   
C CALCR WILL JUST HAVE BEEN CALLED WITH THE SAME VALUE OF N1 BUT        
C POSSIBLY A DIFFERENT X -- NF IDENTIFIES THE X PASSED.  IF CALCR       
C CHANGES N2, THEN THIS CHANGED VALUE IS PASSED TO CALCJ.)              
C   J IS A FLOATING-POINT ARRAY DIMENSIONED J(ND1,P).  FOR I = N1(1)N2  
C AND K = 1(1)P, CALCJ MUST STORE THE PARTIAL DERIVATIVE AT X OF        
C RESIDUAL COMPONENT I WITH RESPECT TO X(K) IN J(I-N1+1,K).             
C                                                                       
C   LIV MUST BE AT LEAST 82 + P.  LV MUST BE AT LEAST                   
C         105 + P*(17 + 2*P) + (P+1)*MIN(ND,N) + N                      
C IF ND .LT. N AND NO REGRESSION DIAGNOSTIC ARRAY IS REQUESTED          
C (I.E., IV(RDREQ) = 0 OR 1), THEN LV CAN BE N LESS THAN THIS.          
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,  N2RDP,   RN2G                                    
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C  N2RDP... PRINTS REGRESSION DIAGNOSTICS.                              
C   RN2G... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      LOGICAL ONERD                                                     
      INTEGER D1, DR1, I, IV1, N1, N2, ND1, NF, R1, RD0, RD1, X01       
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NF00, NFCALL, NFGCAL, R, RDREQ, REGD,        
     1        REGD0, TOOBIG, VNEED, X0                                  
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NF00/81/, NFCALL/6/, NFGCAL/7/,     
C    1     R/61/, RDREQ/57/, REGD/67/, REGD0/82/, TOOBIG/2/, VNEED/4/,  
C    2     X0/43/                                                       
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NF00=81, NFCALL=6, NFGCAL=7,     
     1           R=61, RDREQ=57, REGD=67, REGD0=82, TOOBIG=2, VNEED=4,  
     2           X0=43)                                                 
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      ND1 = MIN0(ND, N)                                                 
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      I = IV(VNEED) + P + ND1*(P+1)                                     
      ONERD = IV(RDREQ) .GE. 2 .OR. ND .GE. N                           
      IF (ONERD) I = I + N                                              
      IF (IV(1) .EQ. 13) IV(VNEED) = I                                  
      CALL   RN2G(V, V, IV, LIV, LV, N, ND1, N1, N2, P, V, V, V, X)     
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(D) = IV(NEXTV)                                                 
      IV(R) = IV(D) + P                                                 
      I = IV(R) + ND1                                                   
      IV(REGD0) = I                                                     
      IF (ONERD) I = I + N                                              
      IV(J) = I                                                         
      IV(NEXTV) = I + ND1*P                                             
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      R1 = IV(R)                                                        
      RD1 = IV(REGD0)                                                   
      RD0 = RD1 - 1                                                     
C                                                                       
 20   CALL   RN2G(V(D1), V(DR1), IV, LIV, LV, N, ND1, N1, N2, P, V(R1), 
     1            V(RD1), V, X)                                         
      IV1 = IV(1)                                                       
      IF (IV1-2) 40, 30, 80                                             
 30   IF (ND .GE. N) GO TO 70                                           
C                                                                       
C  ***  FIRST COMPUTE RELEVANT PORTION OF R  ***                        
C                                                                       
 40   NF = IV(NFCALL)                                                   
      IF (IABS(IV1) .GE. 2) NF = IV(NFGCAL)                             
      CALL CALCR(N, ND1, N1, N2, P, X, NF, V(R1), UI, UR, UF)           
      IF (NF .GT. 0) GO TO 50                                           
         IV(TOOBIG) = 1                                                 
         GO TO 20                                                       
 50   I = IV1 + 4                                                       
      GO TO (70, 60, 70, 20, 20, 70), I                                 
 60   X01 = IV(X0)                                                      
      CALL CALCJ(N, ND1, N1, N2, P, V(X01), IV(NF00), V(DR1), UI,       
     1           UR, UF)                                                
      IF (IV(NF00) .LE. 0) IV(TOOBIG) = 1                               
      GO TO 20                                                          
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 70   CALL CALCJ(N, ND1, N1, N2, P, X, IV(NFGCAL), V(DR1), UI, UR, UF)  
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      RD1 = RD0 + N1                                                    
      GO TO 20                                                          
C                                                                       
 80   RD1 = RD0 + 1                                                     
      IF (IV(REGD) .GT. 0) IV(REGD) = RD1                               
      IF (IV(1) .LE. 8) CALL  N2RDP(IV, LIV, LV, N, V(RD1), V)          
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST LINE OF    N2P FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   N2PB(N, ND, P, X, B, CALCR, CALCJ, IV, LIV, LV, V,   
     1                  UI, UR, UF)                                     
C                                                                       
C *** SIMPLY BOUNDED VERSION OF NL2SOL THAT HAS EXPANDED CALLING        
C *** SEQUENCES FOR CALCR, CALCJ, ALLOWING THEM TO PROVIDE R AND J      
C *** (RESIDUALS AND JACOBIAN) IN CHUNKS.                               
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
      INTEGER N, ND, P, LIV, LV                                         
C/6                                                                     
C     INTEGER IV(LIV), UI(1)                                            
C     REAL B(2,P), X(P), V(LV), UR(1)                                   
C/7                                                                     
      INTEGER IV(LIV), UI(*)                                            
      REAL B(2,P), X(P), V(LV), UR(*)                                   
C/                                                                      
      EXTERNAL CALCR, CALCJ, UF                                         
C                                                                       
C                                                                       
C  ***  PARAMETER USAGE  ***                                            
C                                                                       
C N....... TOTAL NUMBER OF RESIDUALS.                                   
C ND...... MAXIMUM NUMBER OF RESIDUAL COMPONENTS PROVIDED BY ANY CALL   
C             ON CALCR.                                                 
C P....... NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.      
C X....... PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,     
C             OUTPUT = BEST VALUE FOUND).                               
C CALCR... SUBROUTINE FOR COMPUTING RESIDUAL VECTOR.                    
C CALCJ... SUBROUTINE FOR COMPUTING JACOBIAN MATRIX = MATRIX OF FIRST   
C             PARTIALS OF THE RESIDUAL VECTOR.                          
C IV...... INTEGER VALUES ARRAY.                                        
C LIV..... LENGTH OF IV (SEE DISCUSSION BELOW).                         
C LV...... LENGTH OF V (SEE DISCUSSION BELOW).                          
C V....... FLOATING-POINT VALUES ARRAY.                                 
C UI...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C UR...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C UF...... PASSED UNCHANGED TO CALCR AND CALCJ.                         
C                                                                       
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C    THIS ROUTINE IS SIMILAR TO    N2G (WHICH SEE), EXCEPT THAT THE     
C CALLING SEQUENCE FOR CALCR AND CALCJ IS DIFFERENT -- IT ALLOWS        
C THE RESIDUAL VECTOR AND JACOBIAN MATRIX TO BE PASSED IN BLOCKS.       
C                                                                       
C   FOR CALCR, THE CALLING SEQUENCE IS...                               
C                                                                       
C     CALCR(N, ND1, N1, N2, P, X, NF, R, UI, UR, UF)                    
C                                                                       
C   PARAMETERS N, P, X, NF, R, UI, UR, UF ARE AS FOR THE CALCR USED     
C BY NL2SOL OR    N2G.                                                  
C   PARAMETERS ND1, N1, AND N2 ARE INPUTS TO CALCR.  CALCR SHOULD NOT   
C CHANGE ND1 OR N1 (BUT MAY CHANGE N2).                                 
C   ND1 = MIN(N,ND) IS THE MAXIMUM NUMBER OF RESIDUAL COMPONENTS THAT   
C CALCR SHOULD SUPPLY ON ONE CALL.                                      
C   N1 IS THE INDEX OF THE FIRST RESIDUAL COMPONENT THAT CALCR SHOULD   
C SUPPLY ON THIS CALL.                                                  
C   N2 HAS THE VALUE MIN(N, N1+ND1-1) WHEN CALCR IS CALLED.  CALCR      
C MAY SET N2 TO A LOWER VALUE (AT LEAST 1) AND FOR N1 .LE. I .LE. N2    
C SHOULD RETURN RESIDUAL COMPONENT I IN R(I-N1+1), I.E., IN COMPONENTS  
C R(1), R(2), ..., R(N2-N1+1).                                          
C                                                                       
C   FOR CALCJ, THE CALLING SEQUENCE IS...                               
C                                                                       
C     CALCJ(N, ND1, N1, N2, P, X, NF, J, UI, UR, UF)                    
C                                                                       
C   ALL PARAMETERS EXCEPT N2 AND J ARE AS FOR CALCR.  N2 MAY NOT BE     
C CHANGED, BUT OTHERWISE IS AS FOR CALCR.  (WHENEVER CALCJ IS CALLED,   
C CALCR WILL JUST HAVE BEEN CALLED WITH THE SAME VALUE OF N1 BUT        
C POSSIBLY A DIFFERENT X -- NF IDENTIFIES THE X PASSED.  IF CALCR       
C CHANGES N2, THEN THIS CHANGED VALUE IS PASSED TO CALCJ.)              
C   J IS A FLOATING-POINT ARRAY DIMENSIONED J(ND1,P).  FOR I = N1(1)N2  
C AND K = 1(1)P, CALCJ MUST STORE THE PARTIAL DERIVATIVE AT X OF        
C RESIDUAL COMPONENT I WITH RESPECT TO X(K) IN J(I-N1+1,K).             
C                                                                       
C   LIV MUST BE AT LEAST 82 + P.  LV MUST BE AT LEAST                   
C         105 + P*(17 + 2*P) + (P+1)*MIN(ND,N) + N                      
C IF ND .LT. N AND NO REGRESSION DIAGNOSTIC ARRAY IS REQUESTED          
C (I.E., IV(RDREQ) = 0 OR 1), THEN LV CAN BE N LESS THAN THIS.          
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  +++++++++++++++++++++++++++ 
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,  RN2GB                                            
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C  RN2GB... CARRIES OUT OPTIMIZATION ITERATIONS.                        
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      LOGICAL ONERD                                                     
      INTEGER D1, DR1, I, IV1, N1, N2, ND1, NF, R1, RD1, X01            
C                                                                       
C  ***  IV COMPONENTS  ***                                              
C                                                                       
      INTEGER D, J, NEXTV, NF00, NFCALL, NFGCAL, R,                     
     1        REGD0, TOOBIG, VNEED, X0                                  
C/6                                                                     
C     DATA D/27/, J/70/, NEXTV/47/, NF00/81/, NFCALL/6/, NFGCAL/7/,     
C    1     R/61/, REGD0/82/, TOOBIG/2/, VNEED/4/, X0/43/                
C/7                                                                     
      PARAMETER (D=27, J=70, NEXTV=47, NF00=81, NFCALL=6, NFGCAL=7,     
     1           R=61, REGD0=82, TOOBIG=2, VNEED=4, X0=43)              
C/                                                                      
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      ND1 = MIN0(ND, N)                                                 
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      I = IV(VNEED) + P + ND1*(P+1)                                     
      ONERD = ND .GE. N                                                 
      IF (ONERD) I = I + N                                              
      IF (IV(1) .EQ. 13) IV(VNEED) = I                                  
      CALL  RN2GB(B, V, V, IV, LIV, LV, N, ND1, N1, N2, P, V, V, V, X)  
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(D) = IV(NEXTV)                                                 
      IV(R) = IV(D) + P                                                 
      I = IV(R) + ND1                                                   
      IV(REGD0) = I                                                     
      IF (ONERD) I = I + N                                              
      IV(J) = I                                                         
      IV(NEXTV) = I + ND1*P                                             
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 10   D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      R1 = IV(R)                                                        
      RD1 = IV(REGD0)                                                   
C                                                                       
 20   CALL  RN2GB(B, V(D1), V(DR1), IV, LIV, LV, N, ND1, N1, N2, P,     
     1            V(R1), V(RD1), V, X)                                  
      IV1 = IV(1)                                                       
      IF (IV1-2) 40, 30, 999                                            
 30   IF (ND .GE. N) GO TO 70                                           
C                                                                       
C  ***  FIRST COMPUTE RELEVANT PORTION OF R  ***                        
C                                                                       
 40   NF = IV(NFCALL)                                                   
      IF (IABS(IV1) .GE. 2) NF = IV(NFGCAL)                             
      CALL CALCR(N, ND1, N1, N2, P, X, NF, V(R1), UI, UR, UF)           
      IF (NF .GT. 0) GO TO 50                                           
         IV(TOOBIG) = 1                                                 
         GO TO 20                                                       
 50   I = IV1 + 4                                                       
      GO TO (70, 60, 70, 20, 20, 70), I                                 
 60   X01 = IV(X0)                                                      
      CALL CALCJ(N, ND1, N1, N2, P, V(X01), IV(NF00), V(DR1), UI,       
     1           UR, UF)                                                
      IF (IV(NF00) .LE. 0) IV(TOOBIG) = 1                               
      GO TO 20                                                          
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 70   CALL CALCJ(N, ND1, N1, N2, P, X, IV(NFGCAL), V(DR1), UI, UR, UF)  
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 20                                                          
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST LINE OF   N2PB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE    NSF(N, P, L, ALF, C, Y, CALCA, INC, IINC, IV,       
     1                  LIV, LV, V, UIPARM, URPARM, UFPARM)             
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING                   
C  ***  FINITE-DIFFERENCE DERIVATIVES.                                  
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
C/6                                                                     
C     INTEGER INC(IINC,P), IV(LIV), UIPARM(1)                           
C     REAL ALF(P), C(L), URPARM(1), V(LV), Y(N)                         
C/7                                                                     
      INTEGER INC(IINC,P), IV(LIV), UIPARM(*)                           
      REAL ALF(P), C(L), URPARM(*), V(LV), Y(N)                         
C/                                                                      
      EXTERNAL CALCA, UFPARM                                            
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C      N (IN)  NUMBER OF OBSERVATIONS.                                  
C      P (IN)  NUMBER OF NONLINEAR PARAMETERS TO BE ESTIMATED.          
C      L (IN)  NUMBER OF LINEAR PARAMETERS TO BE ESTIMATED.             
C    ALF (I/O) NONLINEAR PARAMETERS.                                    
C                 INPUT = INITIAL GUESS,                                
C                 OUTPUT = BEST ESTIMATE FOUND.                         
C      C (OUT) LINEAR PARAMETERS (ESTIMATED).                           
C      Y (IN)  RIGHT-HAND SIDE VECTOR.                                  
C  CALCA (IN)  SUBROUTINE TO COMPUTE A MATRIX.                          
C    INC (IN)  INCIDENCE MATRIX OF DEPENDENCIES OF COLUMNS OF A ON      
C                 COMPONENTS OF ALF -- INC(I,J) = 1 MEANS COLUMN I      
C                 OF A DEPENDS ON ALF(J).                               
C   IINC (IN)  DECLARED LEAD DIMENSION OF INC.  MUST BE AT LEAST L+1.   
C     IV (I/O) INTEGER PARAMETER AND SCRATCH VECTOR.                    
C    LIV (IN)  LENGTH OF IV.  MUST BE AT LEAST                          
C                 122 + 2*M + 4*P + 2*L + MAX(L+1,6*P), WHERE  M  IS    
C                 THE NUMBER OF ONES IN INC.                            
C     LV (IN)  LENGTH OF V.  MUST BE AT LEAST                           
C                 105 + 2*N*(L+3) + JLEN + L*(L+3)/2 + P*(2*P + 18),    
C                 WHERE  JLEN = (L+P)*(N+L+P+1),  UNLESS NEITHER A      
C                 COVARIANCE MATRIX NOR REGRESSION DIAGNOSTICS ARE      
C                 REQUESTED, IN WHICH CASE  JLEN = N*P.  IF THE LAST    
C                 ROW OF INC CONTAINS ONLY ZEROS, THEN LV CAN BE 4*N    
C                 LESS THAN JUST DESCRIBED.                             
C      V (I/O) FLOATING-POINT PARAMETER AND SCRATCH VECTOR.             
C UIPARM (I/O) INTEGER VECTOR PASSED WITHOUT CHANGE TO CALCA.           
C URPARM (I/O) FLOATING-POINT VECTOR PASSED WITHOUT CHANGE TO CALCA.    
C UFPARM (I/O) SUBROUTINE PASSED (WITHOUT HAVING BEEN CALLED) TO CALCA. 
C                                                                       
C                                                                       
C--------------------------  DECLARATIONS  ---------------------------- 
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET, DSM,   RNSG, V2AXY, V7CPY,  V7SCL                 
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V VALUES.                           
C DSM...... DETERMINES EFFICIENT ORDER FOR FINITE DIFFERENCES.          
C   RNSG... CARRIES OUT NL2SOL ALGORITHM.                               
C V2AXY.... ADDS A MULTIPLE OF ONE VECTOR TO ANOTHER.                   
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7SCL... SCALES AND COPIES ONE VECTOR TO ANOTHER.                    
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      LOGICAL PARTJ                                                     
      INTEGER A0, A1, AJ, ALP1, BWA1, D0, DA0, DA1, DAJ, GPTR1, GRP1,   
     1        GRP2, I, I1, IN0, IN1, IN2, INI, INLEN, IPNTR1, IV1, IWA1,
     2        IWALEN, J1, JN1, JPNTR1, K, L1, LP1, M, M0, NF, NG, NGRP0,
     3        NGRP1, NGRP2, RSAVE0, RSAVE1, RSVLEN, X0I, XSAVE0, XSAVE1 
      REAL DELTA, DI, H, XI                                             
      REAL NEGONE, ONE, ZERO                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, COVREQ, D, DAMAT, DLTFDJ, GPTR, GRP, IN, IVNEED,    
     1        L1SAV, MAXGRP, MODE, MSAVE, NEXTIV, NEXTV, NFCALL, NFGCAL,
     2        PERM, RESTOR, TOOBIG, VNEED, XSAVE                        
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, COVREQ/15/, D/27/, DAMAT/114/, DLTFDJ/43/,        
C    1     GPTR/117/, GRP/118/, IN/112/, IVNEED/3/, L1SAV/111/,         
C    2     MAXGRP/116/, MODE/35/, MSAVE/115/, NEXTIV/46/, NEXTV/47/,    
C    3     NFCALL/6/, NFGCAL/7/, PERM/58/, RESTOR/9/, TOOBIG/2/,        
C    4     VNEED/4/, XSAVE/119/                                         
C/7                                                                     
      PARAMETER (AMAT=113, COVREQ=15, D=27, DAMAT=114, DLTFDJ=43,       
     1           GPTR=117, GRP=118, IN=112, IVNEED=3, L1SAV=111,        
     2           MAXGRP=116, MODE=35, MSAVE=115, NEXTIV=46, NEXTV=47,   
     3           NFCALL=6, NFGCAL=7, PERM=58, RESTOR=9, TOOBIG=2,       
     4           VNEED=4, XSAVE=119)                                    
C/                                                                      
      DATA NEGONE/-1.E+0/, ONE/1.E+0/, ZERO/0.E+0/                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      LP1 = L + 1                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 80             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 120                                        
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 120                       
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 50                                       
C                                                                       
C  ***  FRESH START ***                                                 
C                                                                       
      IF (IV(PERM) .LE. XSAVE) IV(PERM) = XSAVE + 1                     
C                                                                       
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 80          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 80                 
 40      CONTINUE                                                       
C                                                                       
C     *** NOW L1 = 1 MEANS A HAS COLUMN L+1 ***                         
C                                                                       
C     *** COMPUTE STORAGE REQUIREMENTS ***                              
C                                                                       
      IWALEN = MAX0(LP1, 6*P)                                           
      INLEN = 2 * M                                                     
      IV(IVNEED) = IV(IVNEED) + INLEN + 3*P + L + IWALEN + 3            
      RSVLEN = 2 * L1 * N                                               
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + 2*N*L1 + RSVLEN + P                       
C                                                                       
 50   CALL   RNSG(V, ALF, C, V, IV, IV, L, 1, N, LIV, LV, N, M, P, V, Y)
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(XSAVE) = IV(DAMAT) + N*L1                                      
      IV(NEXTV) = IV(XSAVE) + P + RSVLEN                                
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  DETERMINE HOW MANY GROUPS FOR FINITE DIFFERENCES                
C  ***  (SET UP TO CALL DSM)                                            
C                                                                       
      IN1 = IV(IN)                                                      
      JN1 = IN1 + M                                                     
      DO 70 K = 1, P                                                    
         DO 60 I = 1, LP1                                               
            IF (INC(I,K) .EQ. 0) GO TO 60                               
               IV(IN1) = I                                              
               IN1 = IN1 + 1                                            
               IV(JN1) = K                                              
               JN1 = JN1 + 1                                            
 60         CONTINUE                                                    
 70      CONTINUE                                                       
      IN1 = IV(IN)                                                      
      JN1 = IN1 + M                                                     
      IWA1 = IN1 + INLEN                                                
      NGRP1 = IWA1 + IWALEN                                             
      BWA1 = NGRP1 + P                                                  
      IPNTR1 = BWA1 + P                                                 
      JPNTR1 = IPNTR1 + L + 2                                           
      CALL DSM(LP1, P, M, IV(IN1), IV(JN1), IV(NGRP1), NG, K, I,        
     1         IV(IPNTR1), IV(JPNTR1), IV(IWA1), IWALEN, IV(BWA1))      
      IF (I .EQ. 1) GO TO 90                                            
         IV(1) = 69                                                     
         GO TO 50                                                       
 80   IV(1) = 66                                                        
      GO TO 50                                                          
C                                                                       
C  ***  SET UP GRP AND GPTR ARRAYS FOR COMPUTING FINITE DIFFERENCES     
C                                                                       
C  ***  THERE ARE NG GROUPS.  GROUP I CONTAINS ALF(GRP(J)) FOR          
C  ***  GPTR(I) .LE. J .LE. GPTR(I+1)-1.                                
C                                                                       
 90   IV(MAXGRP) = NG                                                   
      IV(GPTR) = IN1 + 2*L1                                             
      GPTR1 = IV(GPTR)                                                  
      IV(GRP) = GPTR1 + NG + 1                                          
      IV(NEXTIV) = IV(GRP) + P                                          
      GRP1 = IV(GRP)                                                    
      NGRP0 = NGRP1 - 1                                                 
      NGRP2 = NGRP0 + P                                                 
      DO 110 I = 1, NG                                                  
         IV(GPTR1) = GRP1                                               
         GPTR1 = GPTR1 + 1                                              
         DO 100 I1 = NGRP1, NGRP2                                       
            IF (IV(I1) .NE. I) GO TO 100                                
            IV(GRP1) = I1 - NGRP0                                       
            GRP1 = GRP1 + 1                                             
 100        CONTINUE                                                    
 110     CONTINUE                                                       
      IV(GPTR1) = GRP1                                                  
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
C  ***  INITIALIZE POINTERS  ***                                        
C                                                                       
 120  A1 = IV(AMAT)                                                     
      A0 = A1 - N                                                       
      DA1 = IV(DAMAT)                                                   
      DA0 = DA1 - N                                                     
      IN1 = IV(IN)                                                      
      IN0 = IN1 - 2                                                     
      L1 = IV(L1SAV)                                                    
      IN2 = IN1 + 2*L1 - 1                                              
      D0 = IV(D) - 1                                                    
      NG = IV(MAXGRP)                                                   
      XSAVE1 = IV(XSAVE)                                                
      XSAVE0 = XSAVE1 - 1                                               
      RSAVE1 = XSAVE1 + P                                               
      RSAVE0 = RSAVE1 + N                                               
      ALP1 = A1 + L*N                                                   
      DELTA = V(DLTFDJ)                                                 
      IV(COVREQ) = -IABS(IV(COVREQ))                                    
C                                                                       
 130  CALL   RNSG(V(A1), ALF, C, V(DA1), IV(IN1), IV, L, L1, N, LIV, LV,
     1            N, L1, P, V, Y)                                       
      IF (IV(1)-2) 140, 150, 999                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 140  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF, NF, V(A1), UIPARM, URPARM, UFPARM)       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      IF (L1 .LE. L) GO TO 130                                          
      IF (IV(RESTOR) .EQ. 2) CALL V7CPY(N, V(RSAVE0), V(RSAVE1))        
      CALL V7CPY(N, V(RSAVE1), V(ALP1))                                 
      GO TO 130                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 150  IF (L1 .GT. L .AND. IV(NFGCAL) .EQ. IV(NFCALL))                   
     1      CALL V7CPY(N, V(RSAVE0), V(RSAVE1))                         
      GPTR1 = IV(GPTR)                                                  
      DO 230 K = 1, NG                                                  
         CALL V7CPY(P, V(XSAVE1), ALF)                                  
         GRP1 = IV(GPTR1)                                               
         GRP2 = IV(GPTR1+1) - 1                                         
         GPTR1 = GPTR1 + 1                                              
         DO 160 I1 = GRP1, GRP2                                         
            I = IV(I1)                                                  
            XI = ALF(I)                                                 
            J1 = D0 + I                                                 
            DI = V(J1)                                                  
            IF (DI .LE. ZERO) DI = ONE                                  
            H = DELTA * AMAX1( ABS(XI), ONE/DI)                         
            IF (XI .LT. ZERO) H = -H                                    
            X0I = XSAVE0 + I                                            
            V(X0I) = XI + H                                             
 160        CONTINUE                                                    
         CALL CALCA(N, P, L, V(XSAVE1), IV(NFGCAL), V(DA1),             
     1              UIPARM, URPARM, UFPARM)                             
         IF (IV(NFGCAL) .GT. 0) GO TO 170                               
            IV(TOOBIG) = 1                                              
            GO TO 130                                                   
 170     JN1 = IN1                                                      
         DO 180 I = IN1, IN2                                            
 180        IV(I) = 0                                                   
         PARTJ = IV(MODE) .LE. P                                        
         DO 220 I1 = GRP1, GRP2                                         
            I = IV(I1)                                                  
            DO 210 J1 = 1, L1                                           
               IF (INC(J1,I) .EQ. 0) GO TO 210                          
               INI = IN0 + 2*J1                                         
               IV(INI) = I                                              
               IV(INI+1) = J1                                           
               X0I = XSAVE0 + I                                         
               H = ONE / (V(X0I) - ALF(I))                              
               DAJ = DA0 + J1*N                                         
               IF (PARTJ) GO TO 190                                     
C                 *** FULL FINITE DIFFERENCE FOR COV. AND REG. DIAG. ***
                  AJ = A0 + J1*N                                        
                  CALL V2AXY(N, V(DAJ), NEGONE, V(AJ), V(DAJ))          
                  GO TO 200                                             
 190           IF (J1 .GT. L)                                           
     1            CALL V2AXY(N, V(DAJ), NEGONE, V(RSAVE0), V(DAJ))      
 200           CALL  V7SCL(N, V(DAJ), H, V(DAJ))                        
 210           CONTINUE                                                 
 220        CONTINUE                                                    
         IF (K .GE. NG) GO TO 240                                       
         IV(1) = -2                                                     
         CALL   RNSG(V(A1), ALF, C, V(DA1), IV(IN1), IV, L, L1, N, LIV, 
     1               LV, N, L1, P, V, Y)                                
         IF (-2 .NE. IV(1)) GO TO 999                                   
 230     CONTINUE                                                       
 240  IV(1) = 2                                                         
      GO TO 130                                                         
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    NSF FOLLOWS  ***                                
      END                                                               
      SUBROUTINE    NSG(N, P, L, ALF, C, Y, CALCA, CALCB, INC, IINC, IV,
     1                  LIV, LV, V, UIPARM, URPARM, UFPARM)             
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING  ***              
C  ***  ANALYTICALLY COMPUTED DERIVATIVES.             ***              
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
C/6                                                                     
C     INTEGER INC(IINC,P), IV(LIV), UIPARM(1)                           
C     REAL ALF(P), C(L), URPARM(1), V(LV), Y(N)                         
C/7                                                                     
      INTEGER INC(IINC,P), IV(LIV), UIPARM(*)                           
      REAL ALF(P), C(L), URPARM(*), V(LV), Y(N)                         
C/                                                                      
      EXTERNAL CALCA, CALCB, UFPARM                                     
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),    NSG ATTEMPTS TO COMPUTE A LEAST SQUARES FIT           
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )).                       
C                       I=1    I             I                          
C                                                                       
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C--------------------------  PARAMETER USAGE  ------------------------- 
C                                                                       
C INPUT PARAMETERS                                                      
C                                                                       
C N     INTEGER        NUMBER OF OBSERVATIONS (MUST BE .GE. MAX(L,P)).  
C                                                                       
C P     INTEGER        NUMBER OF NONLINEAR PARAMETERS (MUST BE .GE. 1). 
C                                                                       
C L     INTEGER        NUMBER OF LINEAR PARAMETERS (MUST BE .GE. 0).    
C                                                                       
C ALF   D.P. ARRAY     P VECTOR = INITIAL ESTIMATE OF THE NONLINEAR     
C                      PARAMETERS.                                      
C                                                                       
C CALCA SUBROUTINE     USER PROVIDED FUNCTION TO CALCULATE THE MODEL    
C                      (I.E., TO CALCULATE PHI) -- SEE THE NOTE BELOW   
C                      ON THE CALLING SEQUENCE FOR CALCA.               
C                      CALCA MUST BE DECLARED EXTERNAL IN THE CALLING   
C                      PROGRAM.                                         
C                                                                       
C CALCB SUBROUTINE     USER PROVIDED FUNCTION TO CALCULATE THE DERIVA-  
C                      TIVE OF THE MODEL (I.E., OF PHI) WITH RESPECT TO 
C                      ALF -- SEE THE NOTE BELOW ON THE CALLING         
C                      SEQUENCE FOR CALCB.  CALCB MUST BE DECLARED      
C                      EXTERNAL IN THE CALLING PROGRAM.                 
C                                                                       
C Y     D.P. ARRAY     VECTOR OF OBSERVATIONS.                          
C                                                                       
C INC   INTEGER ARRAY  A 2 DIM. ARRAY OF DIMENSION AT LEAST (L+1,P)     
C                      INDICATING THE POSITION OF THE NONLINEAR PARA-   
C                      METERS IN THE MODEL.  SET INC(J,K) = 1 IF ALF(K) 
C                      APPEARS IN PHI(J).  OTHERWISE SET INC(J,K) = 0.  
C                      IF PHI((L+1)) IS NOT IN THE MODEL, SET THE L+1ST 
C                      ROW OF INC TO ALL ZEROS.  EVERY COLUMN OF INC    
C                      MUST CONTAIN AT LEAST ONE 1.                     
C                                                                       
C IINC   INTEGER       DECLARED ROW DIMENSION OF INC, WHICH MUST BE AT  
C                      LEAST L+1.                                       
C                                                                       
C IV     INTEGER       ARRAY OF LENGTH AT LEAST LIV THAT CONTAINS       
C                      VARIOUS PARAMETERS FOR THE SUBROUTINE, SUCH AS   
C                      THE ITERATION AND FUNCTION EVALUATION LIMITS AND 
C                      SWITCHES THAT CONTROL PRINTING.  THE INPUT COM-  
C                      PONENTS OF IV ARE DESCRIBED IN DETAIL IN THE     
C                      PORT OPTIMIZATION DOCUMENTATION.                 
C                         IF IV(1)=0 ON INPUT, THEN DEFAULT PARAMETERS  
C                      ARE SUPPLIED TO IV AND V.  THE CALLER MAY SUPPLY 
C                      NONDEFAULT PARAMETERS TO IV AND V BY EXECUTING A 
C                      CALL IVSET(1,IV,LIV,LV,V) AND THEN ASSIGNING     
C                      NONDEFAULT VALUES TO THE APPROPRIATE COMPONENTS  
C                      OF IV AND V BEFORE CALLING    NSG.               
C                                                                       
C LIV     INTEGER      LENGTH OF IV.  MUST BE AT LEAST  115+P+L + 2*M,  
C                      WHERE  M  IS THE NUMBER OF ONES IN INC.          
C                                                                       
C LV      INTEGER      LENGTH OF V.  MUST BE AT LEAST                   
C                      105 + N*(L+M+3) + JLEN + L*(L+3)/2 + P*(2*P+17), 
C                      WHERE  M  IS AS FOR LIV (SEE ABOVE) AND          
C                      JLEN = (L+P)*(N+L+P+1),  UNLESS NEITHER A        
C                      COVARIANCE MATRIX NOR REGRESSION DIAGNOSTICS ARE 
C                      REQUESTED, IN WHICH CASE  JLEN = N*P.  IF THE    
C                      LAST ROW OF INC CONTAINS ONLY ZEROS, THEN LV     
C                      CAN BE N LESS THAN JUST DESCRIBED.               
C                                                                       
C V       D.P. ARRAY   WORK AND PARAMETER ARRAY OF LENGTH AT LEAST LV   
C                      THAT CONTAINS SUCH INPUT COMPONENTS AS THE       
C                      CONVERGENCE TOLERANCES.  THE INPUT COMPONENTS OF 
C                      V MAY BE SUPPLIED AS FOR IV (SEE ABOVE).  NOTE   
C                      THAT V(35) CONTAINS THE INITIAL STEP BOUND,      
C                      WHICH, IF TOO LARGE, MAY LEAD TO OVERFLOW.       
C                                                                       
C UIPARM INTEGER ARRAY SCRATCH SPACE FOR USER TO SEND INFORMATION       
C                      TO CALCA AND CALCB.                              
C                                                                       
C URPARM D.P. ARRAY    SCRATCH SPACE FOR USER TO SEND INFORMATION       
C                      TO CALCA AND CALCB.                              
C                                                                       
C UFPARM EXTERNAL      SUBROUTINE SENT TO CALCA AND CALCB FOR THEIR     
C                      USE.  NOTE THAT THE SUBROUTINE PASSED FOR UFPARM 
C                      MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.
C                                                                       
C                                                                       
C OUTPUT PARAMETERS                                                     
C                                                                       
C ALF    D.P. ARRAY    FINAL NONLINEAR PARAMETERS.                      
C                                                                       
C C      D.P. ARRAY    L VECTOR OF LINEAR PARAMETERS -- NOTE THAT NO    
C                      INITIAL GUESS FOR C IS REQUIRED.                 
C                                                                       
C IV                   IV(1) CONTAINS A RETURN CODE DESCRIBED IN THE    
C                      PORT OPTIMIZATION DOCUMENTATION.  IF IV(1) LIES  
C                      BETWEEN 3 AND 7, THEN THE ALGORITHM HAS          
C                      CONVERGED (BUT IV(1) = 7 INDICATES POSSIBLE      
C                      TROUBLE WITH THE MODEL).  IV(1) = 9 OR 10 MEANS  
C                      FUNCTION EVALUATION OR ITERATION LIMIT REACHED.  
C                      IV(1) = 66 MEANS BAD PARAMETERS (INCLUDING A     
C                      COLUMN OF ZEROS IN INC).  NOTE THAT THE          
C                      ALGORITHM CAN BE RESTARTED AFTER ANY RETURN WITH 
C                      IV(1) .LT. 12 -- SEE THE PORT DOCUMENTATION.     
C                                                                       
C V                    VARIOUS ITEMS OF INTEREST, INCLUDING THE NORM OF 
C                      THE GRADIENT(1) AND THE FUNCTION VALUE(10).  SEE 
C                      THE PORT DOCUMENTATION FOR A COMPLETE LIST.      
C                                                                       
C                                                                       
C                                                                       
C PARAMETERS FOR CALCA(N,P,L,ALF,NF,PHI, UIPARM,URPARM,UFPARM)          
C                                                                       
C N,L,P,ALF ARE INPUT PARAMETERS AS DESCRIBED ABOVE                     
C                                                                       
C PHI    D.P. ARRAY  N*(L+1) ARRAY WHOSE COLUMNS CONTAIN THE TERMS OF   
C                    THE MODEL.  CALCA MUST EVALUATE PHI(ALF) AND STORE 
C                    THE RESULT IN PHI.  IF THE (L+1)ST TERM IS NOT IN  
C                    THE MODEL, THEN NOTHING SHOULD BE STORED IN THE    
C                    (L+1)ST COLUMN OF PHI.                             
C                                                                       
C NF     INTEGER     CURRENT INVOCATION COUNT FOR CALCA.  IF PHI CANNOT 
C                    BE EVALUATED AT ALF (E.G. BECAUSE AN ARGUMENT TO   
C                    AN INTRINSIC FUNCTION IS OUT OF RANGE), THEN CALCA 
C                    SHOULD SIMPLY SET NF TO 0 AND RETURN.  THIS        
C                    TELLS THE ALGORITHM TO TRY A SMALLER STEP.         
C                                                                       
C UIPARM,URPARM,UFPARM ARE AS DESCRIBED ABOVE                           
C                                                                       
C N.B. THE DEPENDENT VARIABLE T IS NOT EXPLICITLY PASSED.  IF REQUIRED, 
C IT MAY BE PASSED IN UIPARM OR URPARM OR STORED IN NAMED COMMON.       
C                                                                       
C                                                                       
C PARAMETERS FOR CALCB(N,P,L,ALF,NF,DER, UIPARM,URPARM,UFPARM)          
C                                                                       
C N,P,L,ALF,NF,UIPARM,URPARM,UFPARM ARE AS FOR CALCA                    
C                                                                       
C DER   D.P. ARRAY   N*M ARRAY, WHERE M IS THE NUMBER OF ONES IN INC.   
C                    CALCB MUST SET DER TO THE DERIVATIVES OF THE MODEL 
C                    WITH RESPECT TO ALF.  IF THE MODEL HAS K TERMS THAT
C                    DEPEND ON ALF(I), THEN DER WILL HAVE K CONSECUTIVE 
C                    COLUMNS OF DERIVATIVES WITH RESPECT TO ALF(I).  THE
C                    COLUMNS OF DER CORRESPOND TO THE ONES IN INC WHEN  
C                    ONE TRAVELS THROUGH INC BY COLUMNS.  FOR EXAMPLE,  
C                    IF INC HAS THE FORM...                             
C                      1  1  0                                          
C                      0  1  0                                          
C                      1  0  0                                          
C                      0  0  1                                          
C                    THEN THE FIRST TWO COLUMNS OF DER ARE FOR THE      
C                    DERIVATIVES OF COLUMNS 1 AND 3 OF PHI WITH RESPECT 
C                    TO ALF(1), COLUMNS 3 AND 4 OF DER ARE FOR THE      
C                    DERIVATIVES OF COLUMNS 1 AND 2 OF PHI WITH RESPECT 
C                    TO ALF(2), AND COLUMN 5 OF DER IS FOR THE DERIVA-  
C                    TIVE OF COLUMN 4 OF PHI WITH RESPECT TO ALF(3).    
C                    MORE SPECIFICALLY, DER(I,2) IS FOR THE DERIVATIVE  
C                    OF PHI(I,3) WITH RESPECT TO ALF(1) AND DER(I,5) IS 
C                    FOR THE DERIVATIVE OF PHI(I,4) WITH RESPECT TO     
C                    ALF(3) (FOR I = 1,2,...,N).                        
C                       THE VALUE OF ALF PASSED TO CALCB IS THE SAME AS 
C                    THAT PASSED TO CALCA THE LAST TIME IT WAS CALLED.  
C                    (IF DER CANNOT BE EVALUATED, THEN CALCB SHOULD SET 
C                    NF TO 0.  THIS WILL CAUSE AN ERROR RETURN.)        
C                                                                       
C N.B. DER IS FOR DERIVATIVES WITH RESPECT TO ALF, NOT T.               
C                                                                       
C------------------------------  NOTES  ------------------------------- 
C                                                                       
C      THIS PROGRAM WAS WRITTEN BY LINDA KAUFMAN AT BELL LABS, MURRAY   
C HILL, N.J. IN 1977 AND EXTENSIVELY REVISED BY HER AND DAVID GAY IN    
C 1980, 1981, 1983, 1984.  THE WORK OF DAVID GAY WAS SUPPORTED IN PART  
C BY NATIONAL SCIENCE FOUNDATION GRANT MCS-7906671.                     
C                                                                       
C--------------------------  DECLARATIONS  ---------------------------- 
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,   RNSG                                            
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V VALUES.                           
C   RNSG... CARRIES OUT NL2SOL ALGORITHM.                               
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER A1, DA1, I, IN1, IV1, K, L1, LP1, M, M0, NF               
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, DAMAT, IN, IVNEED, L1SAV, MSAVE, NEXTIV,            
     1        NEXTV, NFCALL, NFGCAL, PERM, TOOBIG, VNEED                
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, DAMAT/114/, IN/112/, IVNEED/3/, L1SAV/111/,       
C    1     MSAVE/115/, NEXTIV/46/, NEXTV/47/, NFCALL/6/, NFGCAL/7/,     
C    2     PERM/58/, TOOBIG/2/, VNEED/4/                                
C/7                                                                     
      PARAMETER (AMAT=113, DAMAT=114, IN=112, IVNEED=3, L1SAV=111,      
     1           MSAVE=115, NEXTIV=46, NEXTV=47, NFCALL=6, NFGCAL=7,    
     2           PERM=58, TOOBIG=2, VNEED=4)                            
C/                                                                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 50             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 90                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 90                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 60                                       
      IF (IV(PERM) .LE. MSAVE) IV(PERM) = MSAVE + 1                     
      LP1 = L + 1                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
C                                                                       
      IV(IVNEED) = IV(IVNEED) + 2*M                                     
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + N*(L1+M)                                  
      GO TO 60                                                          
C                                                                       
 50   IV(1) = 66                                                        
C                                                                       
 60   CALL   RNSG(V, ALF, C, V, IV, IV, L, 1, N, LIV, LV, N, M, P, V, Y)
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(NEXTIV) = IV(IN) + 2*M                                         
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(NEXTV) = IV(DAMAT) + N*M                                       
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  SET UP IN ARRAY  ***                                            
C                                                                       
      IN1 = IV(IN)                                                      
      DO 80 I = 1, P                                                    
         DO 70 K = 1, LP1                                               
            IF (INC(K,I) .EQ. 0) GO TO 70                               
               IV(IN1) = I                                              
               IV(IN1+1) = K                                            
               IN1 = IN1 + 2                                            
 70         CONTINUE                                                    
 80      CONTINUE                                                       
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 90   A1 = IV(AMAT)                                                     
      DA1 = IV(DAMAT)                                                   
      IN1 = IV(IN)                                                      
      L1 = IV(L1SAV)                                                    
      M = IV(MSAVE)                                                     
C                                                                       
 100  CALL   RNSG(V(A1), ALF, C, V(DA1), IV(IN1), IV, L, L1, N, LIV, LV,
     1            N, M, P, V, Y)                                        
      IF (IV(1)-2) 110, 120, 999                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 110  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF, NF, V(A1), UIPARM, URPARM, UFPARM)       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 100                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 120  CALL CALCB(N, P, L, ALF, IV(NFGCAL), V(DA1), UIPARM, URPARM,      
     1           UFPARM)                                                
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 100                                                         
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF    NSG FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  RMNF(D, FX, IV, LIV, LV, N, V, X)                     
C                                                                       
C  ***  ITERATION DRIVER FOR   MNF...                                   
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING         
C  ***  FINITE-DIFFERENCE GRADIENTS AND SECANT HESSIAN APPROXIMATIONS.  
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      REAL D(N), FX, X(N), V(LV)                                        
C     DIMENSION V(77 + N*(N+17)/2)                                      
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        THIS ROUTINE INTERACTS WITH SUBROUTINE   RMNG  IN AN ATTEMPT   
C     TO FIND AN N-VECTOR  X*  THAT MINIMIZES THE (UNCONSTRAINED)       
C     OBJECTIVE FUNCTION  FX = F(X)  COMPUTED BY THE CALLER.  (OFTEN    
C     THE  X*  FOUND IS A LOCAL MINIMIZER RATHER THAN A GLOBAL ONE.)    
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C        THE PARAMETERS FOR  RMNF ARE THE SAME AS THOSE FOR   MNG       
C     (WHICH SEE), EXCEPT THAT CALCF, CALCG, UIPARM, URPARM, AND UFPARM 
C     ARE OMITTED, AND A PARAMETER  FX  FOR THE OBJECTIVE FUNCTION      
C     VALUE AT X IS ADDED.  INSTEAD OF CALLING CALCG TO OBTAIN THE      
C     GRADIENT OF THE OBJECTIVE FUNCTION AT X,  RMNF CALLS  S7GRD,      
C     WHICH COMPUTES AN APPROXIMATION TO THE GRADIENT BY FINITE         
C     (FORWARD AND CENTRAL) DIFFERENCES USING THE METHOD OF REF. 1.     
C     THE FOLLOWING INPUT COMPONENT IS OF INTEREST IN THIS REGARD       
C     (AND IS NOT DESCRIBED IN   MNG).                                  
C                                                                       
C V(ETA0)..... V(42) IS AN ESTIMATED BOUND ON THE RELATIVE ERROR IN THE 
C             OBJECTIVE FUNCTION VALUE COMPUTED BY CALCF...             
C                  (TRUE VALUE) = (COMPUTED VALUE) * (1 + E),           
C             WHERE ABS(E) .LE. V(ETA0).  DEFAULT = MACHEP * 10**3,     
C             WHERE MACHEP IS THE UNIT ROUNDOFF.                        
C                                                                       
C        THE OUTPUT VALUES IV(NFCALL) AND IV(NGCALL) HAVE DIFFERENT     
C     MEANINGS FOR   MNF THAN FOR   MNG...                              
C                                                                       
C IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCF (I.E.,
C             FUNCTION EVALUATIONS) EXCLUDING THOSE MADE ONLY FOR       
C             COMPUTING GRADIENTS.  THE INPUT VALUE IV(MXFCAL) IS A     
C             LIMIT ON IV(NFCALL).                                      
C IV(NGCALL)... IV(30) IS THE NUMBER OF FUNCTION EVALUATIONS MADE ONLY  
C             FOR COMPUTING GRADIENTS.  THE TOTAL NUMBER OF FUNCTION    
C             EVALUATIONS IS THUS  IV(NFCALL) + IV(NGCALL).             
C                                                                       
C  ***  REFERENCES  ***                                                 
C                                                                       
C 1. STEWART, G.W. (1967), A MODIFICATION OF DAVIDON*S MINIMIZATION     
C        METHOD TO ACCEPT DIFFERENCE APPROXIMATIONS OF DERIVATIVES,     
C        J. ASSOC. COMPUT. MACH. 14, PP. 72-83.                         
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (AUGUST 1982).                              
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      REAL  D7TPR                                                       
      EXTERNAL IVSET,  D7TPR,  S7GRD,  RMNG,  V7SCP                     
C                                                                       
C IVSET.... SUPPLIES DEFAULT PARAMETER VALUES.                          
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C  S7GRD... COMPUTES FINITE-DIFFERENCE GRADIENT APPROXIMATION.          
C  RMNG.... REVERSE-COMMUNICATION ROUTINE THAT DOES   MNG ALGORITHM.    
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C                                                                       
      INTEGER ALPHA, G1, I, IV1, J, K, W                                
      REAL ZERO                                                         
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER ETA0, F, G, LMAT, NEXTV, NGCALL, NITER, SGIRC, TOOBIG,    
     1        VNEED                                                     
C                                                                       
C/6                                                                     
C     DATA ETA0/42/, F/10/, G/28/, LMAT/42/, NEXTV/47/, NGCALL/30/,     
C    1     NITER/31/, SGIRC/57/, TOOBIG/2/, VNEED/4/                    
C/7                                                                     
      PARAMETER (ETA0=42, F=10, G=28, LMAT=42, NEXTV=47, NGCALL=30,     
     1           NITER=31, SGIRC=57, TOOBIG=2, VNEED=4)                 
C/                                                                      
C/6                                                                     
C     DATA ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (ZERO=0.E+0)                                            
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 1) GO TO 10                                          
      IF (IV1 .EQ. 2) GO TO 50                                          
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 12 .OR. IV1 .EQ. 13) IV(VNEED) = IV(VNEED) + 2*N + 6 
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  RMNG(D, FX, V(G1), IV, LIV, LV, N, V, X)                    
      IF (IV(1) - 2) 999, 30, 70                                        
C                                                                       
C  ***  COMPUTE GRADIENT  ***                                           
C                                                                       
 30   IF (IV(NITER) .EQ. 0) CALL  V7SCP(N, V(G1), ZERO)                 
      J = IV(LMAT)                                                      
      K = G1 - N                                                        
      DO 40 I = 1, N                                                    
         V(K) =  D7TPR(I, V(J), V(J))                                   
         K = K + 1                                                      
         J = J + I                                                      
 40      CONTINUE                                                       
C     ***  UNDO INCREMENT OF IV(NGCALL) DONE BY  RMNG  ***              
      IV(NGCALL) = IV(NGCALL) - 1                                       
C     ***  STORE RETURN CODE FROM  S7GRD IN IV(SGIRC)  ***              
      IV(SGIRC) = 0                                                     
C     ***  X MAY HAVE BEEN RESTORED, SO COPY BACK FX... ***             
      FX = V(F)                                                         
      GO TO 60                                                          
C                                                                       
C     ***  GRADIENT LOOP  ***                                           
C                                                                       
 50   IF (IV(TOOBIG) .NE. 0) GO TO 10                                   
C                                                                       
 60   G1 = IV(G)                                                        
      ALPHA = G1 - N                                                    
      W = ALPHA - 6                                                     
      CALL  S7GRD(V(ALPHA), D, V(ETA0), FX, V(G1), IV(SGIRC), N, V(W),X)
      IF (IV(SGIRC) .EQ. 0) GO TO 10                                    
         IV(NGCALL) = IV(NGCALL) + 1                                    
         GO TO 999                                                      
C                                                                       
 70   IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(G) = IV(NEXTV) + N + 6                                         
      IV(NEXTV) = IV(G) + N                                             
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF  RMNF FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  RMNFB(B, D, FX, IV, LIV, LV, P, V, X)                 
C                                                                       
C  ***  ITERATION DRIVER FOR   MNF...                                   
C  ***  MINIMIZE GENERAL UNCONSTRAINED OBJECTIVE FUNCTION USING         
C  ***  FINITE-DIFFERENCE GRADIENTS AND SECANT HESSIAN APPROXIMATIONS.  
C                                                                       
      INTEGER LIV, LV, P                                                
      INTEGER IV(LIV)                                                   
      REAL B(2,P), D(P), FX, X(P), V(LV)                                
C     DIMENSION V(77 + P*(P+17)/2)                                      
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        THIS ROUTINE INTERACTS WITH SUBROUTINE   RMNGB  IN AN ATTEMPT  
C     TO FIND AN P-VECTOR  X*  THAT MINIMIZES THE (UNCONSTRAINED)       
C     OBJECTIVE FUNCTION  FX = F(X)  COMPUTED BY THE CALLER.  (OFTEN    
C     THE  X*  FOUND IS A LOCAL MINIMIZER RATHER THAN A GLOBAL ONE.)    
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C        THE PARAMETERS FOR  RMNFB ARE THE SAME AS THOSE FOR   MNG      
C     (WHICH SEE), EXCEPT THAT CALCF, CALCG, UIPARM, URPARM, AND UFPARM 
C     ARE OMITTED, AND A PARAMETER  FX  FOR THE OBJECTIVE FUNCTION      
C     VALUE AT X IS ADDED.  INSTEAD OF CALLING CALCG TO OBTAIN THE      
C     GRADIENT OF THE OBJECTIVE FUNCTION AT X,  RMNFB CALLS  S3GRD,     
C     WHICH COMPUTES AN APPROXIMATION TO THE GRADIENT BY FINITE         
C     (FORWARD AND CENTRAL) DIFFERENCES USING THE METHOD OF REF. 1.     
C     THE FOLLOWING INPUT COMPONENT IS OF INTEREST IN THIS REGARD       
C     (AND IS NOT DESCRIBED IN   MNG).                                  
C                                                                       
C V(ETA0)..... V(42) IS AN ESTIMATED BOUND ON THE RELATIVE ERROR IN THE 
C             OBJECTIVE FUNCTION VALUE COMPUTED BY CALCF...             
C                  (TRUE VALUE) = (COMPUTED VALUE) * (1 + E),           
C             WHERE ABS(E) .LE. V(ETA0).  DEFAULT = MACHEP * 10**3,     
C             WHERE MACHEP IS THE UNIT ROUNDOFF.                        
C                                                                       
C        THE OUTPUT VALUES IV(NFCALL) AND IV(NGCALL) HAVE DIFFERENT     
C     MEANINGS FOR   MNF THAN FOR   MNG...                              
C                                                                       
C IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCF (I.E.,
C             FUNCTION EVALUATIONS) EXCLUDING THOSE MADE ONLY FOR       
C             COMPUTING GRADIENTS.  THE INPUT VALUE IV(MXFCAL) IS A     
C             LIMIT ON IV(NFCALL).                                      
C IV(NGCALL)... IV(30) IS THE NUMBER OF FUNCTION EVALUATIONS MADE ONLY  
C             FOR COMPUTING GRADIENTS.  THE TOTAL NUMBER OF FUNCTION    
C             EVALUATIONS IS THUS  IV(NFCALL) + IV(NGCALL).             
C                                                                       
C  ***  REFERENCES  ***                                                 
C                                                                       
C 1. STEWART, G.W. (1967), A MODIFICATION OF DAVIDON*S MINIMIZATION     
C        METHOD TO ACCEPT DIFFERENCE APPROXIMATIONS OF DERIVATIVES,     
C        J. ASSOC. COMPUT. MACH. 14, PP. 72-83.                         
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (AUGUST 1982).                              
C                                                                       
C----------------------------  DECLARATIONS  ---------------------------
C                                                                       
      REAL  D7TPR                                                       
      EXTERNAL IVSET,  D7TPR,  S3GRD,  RMNGB,  V7SCP                    
C                                                                       
C IVSET.... SUPPLIES DEFAULT PARAMETER VALUES.                          
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C  S3GRD... COMPUTES FINITE-DIFFERENCE GRADIENT APPROXIMATION.          
C  RMNGB... REVERSE-COMMUNICATION ROUTINE THAT DOES   MNGB ALGORITHM.   
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C                                                                       
      INTEGER ALPHA, ALPHA0, G1, I, IPI, IV1, J, K, W                   
      REAL ZERO                                                         
C                                                                       
C  ***  SUBSCRIPTS FOR IV   ***                                         
C                                                                       
      INTEGER ETA0, F, G, LMAT, NEXTV, NGCALL,                          
     1        NITER, PERM, SGIRC, TOOBIG, VNEED                         
C                                                                       
C/6                                                                     
C     DATA ETA0/42/, F/10/, G/28/, LMAT/42/, NEXTV/47/, NGCALL/30/,     
C    1     NITER/31/, PERM/58/, SGIRC/57/, TOOBIG/2/, VNEED/4/          
C/7                                                                     
      PARAMETER (ETA0=42, F=10, G=28, LMAT=42, NEXTV=47, NGCALL=30,     
     1           NITER=31, PERM=58, SGIRC=57, TOOBIG=2, VNEED=4)        
C/                                                                      
C/6                                                                     
C     DATA ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (ZERO=0.E+0)                                            
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 1) GO TO 10                                          
      IF (IV1 .EQ. 2) GO TO 50                                          
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 12 .OR. IV1 .EQ. 13) IV(VNEED) = IV(VNEED) + 2*P + 6 
      IF (IV1 .EQ. 14) GO TO 10                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 10                        
      G1 = 1                                                            
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      GO TO 20                                                          
C                                                                       
 10   G1 = IV(G)                                                        
C                                                                       
 20   CALL  RMNGB(B, D, FX, V(G1), IV, LIV, LV, P, V, X)                
      IF (IV(1) - 2) 999, 30, 80                                        
C                                                                       
C  ***  COMPUTE GRADIENT  ***                                           
C                                                                       
 30   IF (IV(NITER) .EQ. 0) CALL  V7SCP(P, V(G1), ZERO)                 
      J = IV(LMAT)                                                      
      ALPHA0 = G1 - P - 1                                               
      IPI = IV(PERM)                                                    
      DO 40 I = 1, P                                                    
         K = ALPHA0 + IV(IPI)                                           
         V(K) =  D7TPR(I, V(J), V(J))                                   
         IPI = IPI + 1                                                  
         J = J + I                                                      
 40      CONTINUE                                                       
C     ***  UNDO INCREMENT OF IV(NGCALL) DONE BY  RMNGB  ***             
      IV(NGCALL) = IV(NGCALL) - 1                                       
C     ***  STORE RETURN CODE FROM  S3GRD IN IV(SGIRC)  ***              
      IV(SGIRC) = 0                                                     
C     ***  X MAY HAVE BEEN RESTORED, SO COPY BACK FX... ***             
      FX = V(F)                                                         
      GO TO 60                                                          
C                                                                       
C     ***  GRADIENT LOOP  ***                                           
C                                                                       
 50   IF (IV(TOOBIG) .NE. 0) GO TO 10                                   
C                                                                       
 60   G1 = IV(G)                                                        
      ALPHA = G1 - P                                                    
      W = ALPHA - 6                                                     
      CALL  S3GRD(V(ALPHA), B, D, V(ETA0), FX, V(G1), IV(SGIRC), P,     
     1            V(W), X)                                              
      I = IV(SGIRC)                                                     
      IF (I .EQ. 0) GO TO 10                                            
      IF (I .LE. P) GO TO 70                                            
         IV(TOOBIG) = 1                                                 
         GO TO 10                                                       
C                                                                       
 70   IV(NGCALL) = IV(NGCALL) + 1                                       
      GO TO 999                                                         
C                                                                       
 80   IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(G) = IV(NEXTV) + P + 6                                         
      IV(NEXTV) = IV(G) + P                                             
      IF (IV1 .NE. 13) GO TO 10                                         
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF  RMNFB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  RMNG(D, FX, G, IV, LIV, LV, N, V, X)                  
C                                                                       
C  ***  CARRY OUT   MNG (UNCONSTRAINED MINIMIZATION) ITERATIONS, USING  
C  ***  DOUBLE-DOGLEG/BFGS STEPS.                                       
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      REAL D(N), FX, G(N), V(LV), X(N)                                  
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C D.... SCALE VECTOR.                                                   
C FX... FUNCTION VALUE.                                                 
C G.... GRADIENT VECTOR.                                                
C IV... INTEGER VALUE ARRAY.                                            
C LIV.. LENGTH OF IV (AT LEAST 60).                                     
C LV... LENGTH OF V (AT LEAST 71 + N*(N+13)/2).                         
C N.... NUMBER OF VARIABLES (COMPONENTS IN X AND G).                    
C V.... FLOATING-POINT VALUE ARRAY.                                     
C X.... VECTOR OF PARAMETERS TO BE OPTIMIZED.                           
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        PARAMETERS IV, N, V, AND X ARE THE SAME AS THE CORRESPONDING   
C     ONES TO   MNG (WHICH SEE), EXCEPT THAT V CAN BE SHORTER (SINCE    
C     THE PART OF V THAT   MNG USES FOR STORING G IS NOT NEEDED).       
C     MOREOVER, COMPARED WITH   MNG, IV(1) MAY HAVE THE TWO ADDITIONAL  
C     OUTPUT VALUES 1 AND 2, WHICH ARE EXPLAINED BELOW, AS IS THE USE   
C     OF IV(TOOBIG) AND IV(NFGCAL).  THE VALUE IV(G), WHICH IS AN       
C     OUTPUT VALUE FROM   MNG (AND   MNF), IS NOT REFERENCED BY         
C      RMNG OR THE SUBROUTINES IT CALLS.                                
C        FX AND G NEED NOT HAVE BEEN INITIALIZED WHEN  RMNG IS CALLED   
C     WITH IV(1) = 12, 13, OR 14.                                       
C                                                                       
C IV(1) = 1 MEANS THE CALLER SHOULD SET FX TO F(X), THE FUNCTION VALUE  
C             AT X, AND CALL  RMNG AGAIN, HAVING CHANGED NONE OF THE    
C             OTHER PARAMETERS.  AN EXCEPTION OCCURS IF F(X) CANNOT BE  
C             (E.G. IF OVERFLOW WOULD OCCUR), WHICH MAY HAPPEN BECAUSE  
C             OF AN OVERSIZED STEP.  IN THIS CASE THE CALLER SHOULD SET 
C             IV(TOOBIG) = IV(2) TO 1, WHICH WILL CAUSE  RMNG TO IG-    
C             NORE FX AND TRY A SMALLER STEP.  THE PARAMETER NF THAT    
C               MNG PASSES TO CALCF (FOR POSSIBLE USE BY CALCG) IS A    
C             COPY OF IV(NFCALL) = IV(6).                               
C IV(1) = 2 MEANS THE CALLER SHOULD SET G TO G(X), THE GRADIENT VECTOR  
C             OF F AT X, AND CALL  RMNG AGAIN, HAVING CHANGED NONE OF   
C             THE OTHER PARAMETERS EXCEPT POSSIBLY THE SCALE VECTOR D   
C             WHEN IV(DTYPE) = 0.  THE PARAMETER NF THAT   MNG PASSES   
C             TO CALCG IS IV(NFGCAL) = IV(7).  IF G(X) CANNOT BE        
C             EVALUATED, THEN THE CALLER MAY SET IV(TOOBIG) TO 0, IN    
C             WHICH CASE  RMNG WILL RETURN WITH IV(1) = 65.             
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (DECEMBER 1979).  REVISED SEPT. 1982.       
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH SUPPORTED 
C     IN PART BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS           
C     MCS-7600324 AND MCS-7906671.                                      
C                                                                       
C        (SEE   MNG FOR REFERENCES.)                                    
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER DG1, DUMMY, G01, I, K, L, LSTGST, NWTST1, RSTRST, STEP1,  
     1        TEMP1, W, X01, Z                                          
      REAL T                                                            
C                                                                       
C     ***  CONSTANTS  ***                                               
C                                                                       
      REAL HALF, NEGONE, ONE, ONEP2, ZERO                               
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      LOGICAL STOPX                                                     
      REAL  D7TPR,  RLDST,  V2NRM                                       
      EXTERNAL A7SST, D7DOG, IVSET,  D7TPR, ITSUM,  L7ITV,  L7IVM,      
     1          L7TVM,  L7UPD, L7VML, PARCK,  RLDST, STOPX, V2AXY,      
     2         V7CPY,  V7SCP,  V7VMP,  V2NRM,  W7ZBF                    
C                                                                       
C A7SST.... ASSESSES CANDIDATE STEP.                                    
C D7DOG.... COMPUTES DOUBLE-DOGLEG (CANDIDATE) STEP.                    
C IVSET.... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                 
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C ITSUM.... PRINTS ITERATION SUMMARY AND INFO ON INITIAL AND FINAL X.   
C  L7ITV... MULTIPLIES INVERSE TRANSPOSE OF LOWER TRIANGLE TIMES VECTOR.
C  L7IVM... MULTIPLIES INVERSE OF LOWER TRIANGLE TIMES VECTOR.          
C  L7TVM... MULTIPLIES TRANSPOSE OF LOWER TRIANGLE TIMES VECTOR.        
C LUPDT.... UPDATES CHOLESKY FACTOR OF HESSIAN APPROXIMATION.           
C L7VML.... MULTIPLIES LOWER TRIANGLE TIMES VECTOR.                     
C PARCK.... CHECKS VALIDITY OF INPUT IV AND V VALUES.                   
C  RLDST... COMPUTES V(RELDX) = RELATIVE STEP SIZE.                     
C STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.           
C V2AXY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.              
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C  V7VMP... MULTIPLIES VECTOR BY VECTOR RAISED TO POWER (COMPONENTWISE).
C  V2NRM... RETURNS THE 2-NORM OF A VECTOR.                             
C  W7ZBF... COMPUTES W AND Z FOR  L7UPD CORRESPONDING TO BFGS UPDATE.   
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, DG, DGNORM, DINIT, DSTNRM, DST0, F, F0, FDIF,     
     1        GTHG, GTSTEP, G0, INCFAC, INITH, IRC, KAGQT, LMAT, LMAX0, 
     2        LMAXS, MODE, MODEL, MXFCAL, MXITER, NEXTV, NFCALL, NFGCAL,
     3        NGCALL, NITER, NREDUC, NWTSTP, PREDUC, RADFAC, RADINC,    
     4        RADIUS, RAD0, RELDX, RESTOR, STEP, STGLIM, STLSTG, TOOBIG,
     5        TUNER4, TUNER5, VNEED, XIRC, X0                           
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, DG/37/, G0/48/, INITH/25/, IRC/29/, KAGQT/33/,   
C    1     MODE/35/, MODEL/5/, MXFCAL/17/, MXITER/18/, NFCALL/6/,       
C    2     NFGCAL/7/, NGCALL/30/, NITER/31/, NWTSTP/34/, RADINC/8/,     
C    3     RESTOR/9/, STEP/40/, STGLIM/11/, STLSTG/41/, TOOBIG/2/,      
C    4     VNEED/4/, XIRC/13/, X0/43/                                   
C/7                                                                     
      PARAMETER (CNVCOD=55, DG=37, G0=48, INITH=25, IRC=29, KAGQT=33,   
     1           MODE=35, MODEL=5, MXFCAL=17, MXITER=18, NFCALL=6,      
     2           NFGCAL=7, NGCALL=30, NITER=31, NWTSTP=34, RADINC=8,    
     3           RESTOR=9, STEP=40, STGLIM=11, STLSTG=41, TOOBIG=2,     
     4           VNEED=4, XIRC=13, X0=43)                               
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA DGNORM/1/, DINIT/38/, DSTNRM/2/, DST0/3/, F/10/, F0/13/,     
C    1     FDIF/11/, GTHG/44/, GTSTEP/4/, INCFAC/23/, LMAT/42/,         
C    2     LMAX0/35/, LMAXS/36/, NEXTV/47/, NREDUC/6/, PREDUC/7/,       
C    3     RADFAC/16/, RADIUS/8/, RAD0/9/, RELDX/17/, TUNER4/29/,       
C    4     TUNER5/30/                                                   
C/7                                                                     
      PARAMETER (DGNORM=1, DINIT=38, DSTNRM=2, DST0=3, F=10, F0=13,     
     1           FDIF=11, GTHG=44, GTSTEP=4, INCFAC=23, LMAT=42,        
     2           LMAX0=35, LMAXS=36, NEXTV=47, NREDUC=6, PREDUC=7,      
     3           RADFAC=16, RADIUS=8, RAD0=9, RELDX=17, TUNER4=29,      
     4           TUNER5=30)                                             
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA HALF/0.5E+0/, NEGONE/-1.E+0/, ONE/1.E+0/, ONEP2/1.2E+0/,     
C    1     ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (HALF=0.5E+0, NEGONE=-1.E+0, ONE=1.E+0, ONEP2=1.2E+0,   
     1           ZERO=0.E+0)                                            
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      I = IV(1)                                                         
      IF (I .EQ. 1) GO TO 50                                            
      IF (I .EQ. 2) GO TO 60                                            
C                                                                       
C  ***  CHECK VALIDITY OF IV AND V INPUT VALUES  ***                    
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IF (IV(1) .EQ. 12 .OR. IV(1) .EQ. 13)                             
     1     IV(VNEED) = IV(VNEED) + N*(N+13)/2                           
      CALL PARCK(2, D, IV, LIV, LV, N, V)                               
      I = IV(1) - 2                                                     
      IF (I .GT. 12) GO TO 999                                          
      GO TO (190, 190, 190, 190, 190, 190, 120, 90, 120, 10, 10, 20), I 
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
 10   L = IV(LMAT)                                                      
      IV(X0) = L + N*(N+1)/2                                            
      IV(STEP) = IV(X0) + N                                             
      IV(STLSTG) = IV(STEP) + N                                         
      IV(G0) = IV(STLSTG) + N                                           
      IV(NWTSTP) = IV(G0) + N                                           
      IV(DG) = IV(NWTSTP) + N                                           
      IV(NEXTV) = IV(DG) + N                                            
      IF (IV(1) .NE. 13) GO TO 20                                       
         IV(1) = 14                                                     
         GO TO 999                                                      
C                                                                       
C  ***  INITIALIZATION  ***                                             
C                                                                       
 20   IV(NITER) = 0                                                     
      IV(NFCALL) = 1                                                    
      IV(NGCALL) = 1                                                    
      IV(NFGCAL) = 1                                                    
      IV(MODE) = -1                                                     
      IV(MODEL) = 1                                                     
      IV(STGLIM) = 1                                                    
      IV(TOOBIG) = 0                                                    
      IV(CNVCOD) = 0                                                    
      IV(RADINC) = 0                                                    
      V(RAD0) = ZERO                                                    
      IF (V(DINIT) .GE. ZERO) CALL  V7SCP(N, D, V(DINIT))               
      IF (IV(INITH) .NE. 1) GO TO 40                                    
C                                                                       
C     ***  SET THE INITIAL HESSIAN APPROXIMATION TO DIAG(D)**-2  ***    
C                                                                       
         L = IV(LMAT)                                                   
         CALL  V7SCP(N*(N+1)/2, V(L), ZERO)                             
         K = L - 1                                                      
         DO 30 I = 1, N                                                 
              K = K + I                                                 
              T = D(I)                                                  
              IF (T .LE. ZERO) T = ONE                                  
              V(K) = T                                                  
 30           CONTINUE                                                  
C                                                                       
C  ***  COMPUTE INITIAL FUNCTION VALUE  ***                             
C                                                                       
 40   IV(1) = 1                                                         
      GO TO 999                                                         
C                                                                       
 50   V(F) = FX                                                         
      IF (IV(MODE) .GE. 0) GO TO 190                                    
      IV(1) = 2                                                         
      IF (IV(TOOBIG) .EQ. 0) GO TO 999                                  
         IV(1) = 63                                                     
         GO TO 350                                                      
C                                                                       
C  ***  MAKE SURE GRADIENT COULD BE COMPUTED  ***                       
C                                                                       
 60   IF (IV(TOOBIG) .EQ. 0) GO TO 70                                   
         IV(1) = 65                                                     
         GO TO 350                                                      
C                                                                       
 70   DG1 = IV(DG)                                                      
      CALL  V7VMP(N, V(DG1), G, D, -1)                                  
      V(DGNORM) =  V2NRM(N, V(DG1))                                     
C                                                                       
      IF (IV(CNVCOD) .NE. 0) GO TO 340                                  
      IF (IV(MODE) .EQ. 0) GO TO 300                                    
C                                                                       
C  ***  ALLOW FIRST STEP TO HAVE SCALED 2-NORM AT MOST V(LMAX0)  ***    
C                                                                       
      V(RADIUS) = V(LMAX0)                                              
C                                                                       
      IV(MODE) = 0                                                      
C                                                                       
C                                                                       
C-----------------------------  MAIN LOOP  -----------------------------
C                                                                       
C                                                                       
C  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***             
C                                                                       
 80   CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
 90   K = IV(NITER)                                                     
      IF (K .LT. IV(MXITER)) GO TO 100                                  
         IV(1) = 10                                                     
         GO TO 350                                                      
C                                                                       
C  ***  UPDATE RADIUS  ***                                              
C                                                                       
 100  IV(NITER) = K + 1                                                 
      IF (K .GT. 0) V(RADIUS) = V(RADFAC) * V(DSTNRM)                   
C                                                                       
C  ***  INITIALIZE FOR START OF NEXT ITERATION  ***                     
C                                                                       
      G01 = IV(G0)                                                      
      X01 = IV(X0)                                                      
      V(F0) = V(F)                                                      
      IV(IRC) = 4                                                       
      IV(KAGQT) = -1                                                    
C                                                                       
C     ***  COPY X TO X0, G TO G0  ***                                   
C                                                                       
      CALL V7CPY(N, V(X01), X)                                          
      CALL V7CPY(N, V(G01), G)                                          
C                                                                       
C  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***                  
C                                                                       
 110  IF (.NOT. STOPX(DUMMY)) GO TO 130                                 
         IV(1) = 11                                                     
         GO TO 140                                                      
C                                                                       
C     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.  
C                                                                       
 120  IF (V(F) .GE. V(F0)) GO TO 130                                    
         V(RADFAC) = ONE                                                
         K = IV(NITER)                                                  
         GO TO 100                                                      
C                                                                       
 130  IF (IV(NFCALL) .LT. IV(MXFCAL)) GO TO 150                         
         IV(1) = 9                                                      
 140     IF (V(F) .GE. V(F0)) GO TO 350                                 
C                                                                       
C        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH        
C        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.                
C                                                                       
              IV(CNVCOD) = IV(1)                                        
              GO TO 290                                                 
C                                                                       
C. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . . 
C                                                                       
 150  STEP1 = IV(STEP)                                                  
      DG1 = IV(DG)                                                      
      NWTST1 = IV(NWTSTP)                                               
      IF (IV(KAGQT) .GE. 0) GO TO 160                                   
         L = IV(LMAT)                                                   
         CALL  L7IVM(N, V(NWTST1), V(L), G)                             
         V(NREDUC) = HALF *  D7TPR(N, V(NWTST1), V(NWTST1))             
         CALL  L7ITV(N, V(NWTST1), V(L), V(NWTST1))                     
         CALL  V7VMP(N, V(STEP1), V(NWTST1), D, 1)                      
         V(DST0) =  V2NRM(N, V(STEP1))                                  
         CALL  V7VMP(N, V(DG1), V(DG1), D, -1)                          
         CALL  L7TVM(N, V(STEP1), V(L), V(DG1))                         
         V(GTHG) =  V2NRM(N, V(STEP1))                                  
         IV(KAGQT) = 0                                                  
 160  CALL D7DOG(V(DG1), LV, N, V(NWTST1), V(STEP1), V)                 
      IF (IV(IRC) .NE. 6) GO TO 170                                     
         IF (IV(RESTOR) .NE. 2) GO TO 160                               
         RSTRST = 2                                                     
         GO TO 200                                                      
C                                                                       
C  ***  CHECK WHETHER EVALUATING F(X0 + STEP) LOOKS WORTHWHILE  ***     
C                                                                       
 170  IV(TOOBIG) = 0                                                    
      IF (V(DSTNRM) .LE. ZERO) GO TO 190                                
      IF (IV(IRC) .NE. 5) GO TO 180                                     
      IF (V(RADFAC) .LE. ONE) GO TO 180                                 
      IF (V(PREDUC) .GT. ONEP2 * V(FDIF)) GO TO 180                     
         IF (IV(RESTOR) .NE. 2) GO TO 190                               
         RSTRST = 0                                                     
         GO TO 200                                                      
C                                                                       
C  ***  COMPUTE F(X0 + STEP)  ***                                       
C                                                                       
 180  X01 = IV(X0)                                                      
      STEP1 = IV(STEP)                                                  
      CALL V2AXY(N, X, ONE, V(STEP1), V(X01))                           
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 999                                                         
C                                                                       
C. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
C                                                                       
 190  RSTRST = 3                                                        
 200  X01 = IV(X0)                                                      
      V(RELDX) =  RLDST(N, D, X, V(X01))                                
      CALL A7SST(IV, LIV, LV, V)                                        
      STEP1 = IV(STEP)                                                  
      LSTGST = IV(STLSTG)                                               
      I = IV(RESTOR) + 1                                                
      GO TO (240, 210, 220, 230), I                                     
 210  CALL V7CPY(N, X, V(X01))                                          
      GO TO 240                                                         
 220   CALL V7CPY(N, V(LSTGST), V(STEP1))                               
       GO TO 240                                                        
 230     CALL V7CPY(N, V(STEP1), V(LSTGST))                             
         CALL V2AXY(N, X, ONE, V(STEP1), V(X01))                        
         V(RELDX) =  RLDST(N, D, X, V(X01))                             
         IV(RESTOR) = RSTRST                                            
C                                                                       
 240  K = IV(IRC)                                                       
      GO TO (250,280,280,280,250,260,270,270,270,270,270,270,330,300), K
C                                                                       
C     ***  RECOMPUTE STEP WITH CHANGED RADIUS  ***                      
C                                                                       
 250     V(RADIUS) = V(RADFAC) * V(DSTNRM)                              
         GO TO 110                                                      
C                                                                       
C  ***  COMPUTE STEP OF LENGTH V(LMAXS) FOR SINGULAR CONVERGENCE TEST.  
C                                                                       
 260  V(RADIUS) = V(LMAXS)                                              
      GO TO 150                                                         
C                                                                       
C  ***  CONVERGENCE OR FALSE CONVERGENCE  ***                           
C                                                                       
 270  IV(CNVCOD) = K - 4                                                
      IF (V(F) .GE. V(F0)) GO TO 340                                    
         IF (IV(XIRC) .EQ. 14) GO TO 340                                
              IV(XIRC) = 14                                             
C                                                                       
C. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
C                                                                       
 280  IF (IV(IRC) .NE. 3) GO TO 290                                     
         STEP1 = IV(STEP)                                               
         TEMP1 = IV(STLSTG)                                             
C                                                                       
C     ***  SET  TEMP1 = HESSIAN * STEP  FOR USE IN GRADIENT TESTS  ***  
C                                                                       
         L = IV(LMAT)                                                   
         CALL  L7TVM(N, V(TEMP1), V(L), V(STEP1))                       
         CALL L7VML(N, V(TEMP1), V(L), V(TEMP1))                        
C                                                                       
C  ***  COMPUTE GRADIENT  ***                                           
C                                                                       
 290  IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(1) = 2                                                         
      GO TO 999                                                         
C                                                                       
C  ***  INITIALIZATIONS -- G0 = G - G0, ETC.  ***                       
C                                                                       
 300  G01 = IV(G0)                                                      
      CALL V2AXY(N, V(G01), NEGONE, V(G01), G)                          
      STEP1 = IV(STEP)                                                  
      TEMP1 = IV(STLSTG)                                                
      IF (IV(IRC) .NE. 3) GO TO 320                                     
C                                                                       
C  ***  SET V(RADFAC) BY GRADIENT TESTS  ***                            
C                                                                       
C     ***  SET  TEMP1 = DIAG(D)**-1 * (HESSIAN*STEP + (G(X0)-G(X)))  ***
C                                                                       
         CALL V2AXY(N, V(TEMP1), NEGONE, V(G01), V(TEMP1))              
         CALL  V7VMP(N, V(TEMP1), V(TEMP1), D, -1)                      
C                                                                       
C        ***  DO GRADIENT TESTS  ***                                    
C                                                                       
         IF ( V2NRM(N, V(TEMP1)) .LE. V(DGNORM) * V(TUNER4))            
     1                  GO TO 310                                       
              IF ( D7TPR(N, G, V(STEP1))                                
     1                  .GE. V(GTSTEP) * V(TUNER5))  GO TO 320          
 310               V(RADFAC) = V(INCFAC)                                
C                                                                       
C  ***  UPDATE H, LOOP  ***                                             
C                                                                       
 320  W = IV(NWTSTP)                                                    
      Z = IV(X0)                                                        
      L = IV(LMAT)                                                      
      CALL  W7ZBF(V(L), N, V(STEP1), V(W), V(G01), V(Z))                
C                                                                       
C     ** USE THE N-VECTORS STARTING AT V(STEP1) AND V(G01) FOR SCRATCH..
      CALL  L7UPD(V(TEMP1), V(STEP1), V(L), V(G01), V(L), N, V(W), V(Z))
      IV(1) = 2                                                         
      GO TO 80                                                          
C                                                                       
C. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
C                                                                       
C  ***  BAD PARAMETERS TO ASSESS  ***                                   
C                                                                       
 330  IV(1) = 64                                                        
      GO TO 350                                                         
C                                                                       
C  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  *** 
C                                                                       
 340  IV(1) = IV(CNVCOD)                                                
      IV(CNVCOD) = 0                                                    
 350  CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST LINE OF  RMNG FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  RMNGB(B, D, FX, G, IV, LIV, LV, N, V, X)              
C                                                                       
C  ***  CARRY OUT   MNGB (SIMPLY BOUNDED MINIMIZATION) ITERATIONS,      
C  ***  USING DOUBLE-DOGLEG/BFGS STEPS.                                 
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      REAL B(2,N), D(N), FX, G(N), V(LV), X(N)                          
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C B.... VECTOR OF LOWER AND UPPER BOUNDS ON X.                          
C D.... SCALE VECTOR.                                                   
C FX... FUNCTION VALUE.                                                 
C G.... GRADIENT VECTOR.                                                
C IV... INTEGER VALUE ARRAY.                                            
C LIV.. LENGTH OF IV (AT LEAST 60).                                     
C LV... LENGTH OF V (AT LEAST 71 + N*(N+13)/2).                         
C N.... NUMBER OF VARIABLES (COMPONENTS IN X AND G).                    
C V.... FLOATING-POINT VALUE ARRAY.                                     
C X.... VECTOR OF PARAMETERS TO BE OPTIMIZED.                           
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        PARAMETERS IV, N, V, AND X ARE THE SAME AS THE CORRESPONDING   
C     ONES TO   MNGB (WHICH SEE), EXCEPT THAT V CAN BE SHORTER (SINCE   
C     THE PART OF V THAT   MNGB USES FOR STORING G IS NOT NEEDED).      
C     MOREOVER, COMPARED WITH   MNGB, IV(1) MAY HAVE THE TWO ADDITIONAL 
C     OUTPUT VALUES 1 AND 2, WHICH ARE EXPLAINED BELOW, AS IS THE USE   
C     OF IV(TOOBIG) AND IV(NFGCAL).  THE VALUE IV(G), WHICH IS AN       
C     OUTPUT VALUE FROM   MNGB (AND SMSNOB), IS NOT REFERENCED BY       
C      RMNGB OR THE SUBROUTINES IT CALLS.                               
C        FX AND G NEED NOT HAVE BEEN INITIALIZED WHEN  RMNGB IS CALLED  
C     WITH IV(1) = 12, 13, OR 14.                                       
C                                                                       
C IV(1) = 1 MEANS THE CALLER SHOULD SET FX TO F(X), THE FUNCTION VALUE  
C             AT X, AND CALL  RMNGB AGAIN, HAVING CHANGED NONE OF THE   
C             OTHER PARAMETERS.  AN EXCEPTION OCCURS IF F(X) CANNOT BE  
C             (E.G. IF OVERFLOW WOULD OCCUR), WHICH MAY HAPPEN BECAUSE  
C             OF AN OVERSIZED STEP.  IN THIS CASE THE CALLER SHOULD SET 
C             IV(TOOBIG) = IV(2) TO 1, WHICH WILL CAUSE  RMNGB TO IG-   
C             NORE FX AND TRY A SMALLER STEP.  THE PARAMETER NF THAT    
C               MNGB PASSES TO CALCF (FOR POSSIBLE USE BY CALCG) IS A   
C             COPY OF IV(NFCALL) = IV(6).                               
C IV(1) = 2 MEANS THE CALLER SHOULD SET G TO G(X), THE GRADIENT VECTOR  
C             OF F AT X, AND CALL  RMNGB AGAIN, HAVING CHANGED NONE OF  
C             THE OTHER PARAMETERS EXCEPT POSSIBLY THE SCALE VECTOR D   
C             WHEN IV(DTYPE) = 0.  THE PARAMETER NF THAT   MNGB PASSES  
C             TO CALCG IS IV(NFGCAL) = IV(7).  IF G(X) CANNOT BE        
C             EVALUATED, THEN THE CALLER MAY SET IV(NFGCAL) TO 0, IN    
C             WHICH CASE  RMNGB WILL RETURN WITH IV(1) = 65.            
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (DECEMBER 1979).  REVISED SEPT. 1982.       
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH SUPPORTED 
C     IN PART BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS           
C     MCS-7600324 AND MCS-7906671.                                      
C                                                                       
C        (SEE   MNG FOR REFERENCES.)                                    
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER DG1, DSTEP1, DUMMY, G01, I, I1, IPI, IPN, J, K, L, LSTGST,
     1        N1, NP1, NWTST1, RSTRST, STEP1, TEMP0, TEMP1, TD1, TG1,   
     2        W1, X01, Z                                                
      REAL GI, T, XI                                                    
C                                                                       
C     ***  CONSTANTS  ***                                               
C                                                                       
      REAL NEGONE, ONE, ONEP2, ZERO                                     
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      LOGICAL STOPX                                                     
      REAL  D7TPR,  RLDST,  V2NRM                                       
      EXTERNAL A7SST,  D7DGB, IVSET,  D7TPR, I7SHFT, ITSUM,  L7TVM,     
     1          L7UPD, L7VML, PARCK,  Q7RSH,  RLDST, STOPX,  V2NRM,     
     2         V2AXY, V7CPY,  V7IPR,  V7SCP,  V7VMP,  W7ZBF             
C                                                                       
C A7SST.... ASSESSES CANDIDATE STEP.                                    
C  D7DGB... COMPUTES SIMPLY BOUNDED DOUBLE-DOGLEG (CANDIDATE) STEP.     
C IVSET.... SUPPLIES DEFAULT IV AND V INPUT COMPONENTS.                 
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C I7SHFT... CYCLICALLLY SHIFTS AN ARRAY OF INTEGERS.                    
C ITSUM.... PRINTS ITERATION SUMMARY AND INFO ON INITIAL AND FINAL X.   
C  L7TVM... MULTIPLIES TRANSPOSE OF LOWER TRIANGLE TIMES VECTOR.        
C LUPDT.... UPDATES CHOLESKY FACTOR OF HESSIAN APPROXIMATION.           
C L7VML.... MULTIPLIES LOWER TRIANGLE TIMES VECTOR.                     
C PARCK.... CHECKS VALIDITY OF INPUT IV AND V VALUES.                   
C  Q7RSH... CYCLICALLY SHIFTS CHOLESKY FACTOR.                          
C  RLDST... COMPUTES V(RELDX) = RELATIVE STEP SIZE.                     
C STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.           
C  V2NRM... RETURNS THE 2-NORM OF A VECTOR.                             
C V2AXY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.              
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7IPR... CYCLICALLY SHIFTS A FLOATING-POINT ARRAY.                   
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C  V7VMP... MULTIPLIES VECTOR BY VECTOR RAISED TO POWER (COMPONENTWISE).
C  W7ZBF... COMPUTES W AND Z FOR  L7UPD CORRESPONDING TO BFGS UPDATE.   
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, DG, DGNORM, DINIT, DSTNRM, F, F0, FDIF,           
     1        GTSTEP, INCFAC, INITH, IRC, IVNEED, KAGQT, LMAT,          
     2        LMAX0, LMAXS, MODE, MODEL, MXFCAL, MXITER, NC, NEXTIV,    
     3        NEXTV, NFCALL, NFGCAL, NGCALL, NITER, NWTSTP, PERM,       
     4        PREDUC, RADFAC, RADINC, RADIUS, RAD0, RELDX, RESTOR, STEP,
     4        STGLIM, STLSTG, TOOBIG, TUNER4, TUNER5, VNEED, XIRC, X0   
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C  ***  (NOTE THAT NC IS STORED IN IV(G0)) ***                          
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, DG/37/, INITH/25/, IRC/29/, IVNEED/3/, KAGQT/33/,
C    1     MODE/35/, MODEL/5/, MXFCAL/17/, MXITER/18/, NC/48/,          
C    2     NEXTIV/46/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, NGCALL/30/,     
C    3     NITER/31/, NWTSTP/34/, PERM/58/, RADINC/8/, RESTOR/9/,       
C    4     STEP/40/, STGLIM/11/, STLSTG/41/, TOOBIG/2/, XIRC/13/, X0/43/
C/7                                                                     
      PARAMETER (CNVCOD=55, DG=37, INITH=25, IRC=29, IVNEED=3, KAGQT=33,
     1           MODE=35, MODEL=5, MXFCAL=17, MXITER=18, NC=48,         
     2           NEXTIV=46, NEXTV=47, NFCALL=6, NFGCAL=7, NGCALL=30,    
     3           NITER=31, NWTSTP=34, PERM=58, RADINC=8, RESTOR=9,      
     4           STEP=40, STGLIM=11, STLSTG=41, TOOBIG=2, XIRC=13,      
     5           X0=43)                                                 
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA DGNORM/1/, DINIT/38/, DSTNRM/2/, F/10/, F0/13/, FDIF/11/,    
C    1     GTSTEP/4/, INCFAC/23/, LMAT/42/, LMAX0/35/, LMAXS/36/,       
C    2     PREDUC/7/, RADFAC/16/, RADIUS/8/, RAD0/9/, RELDX/17/,        
C    3     TUNER4/29/, TUNER5/30/, VNEED/4/                             
C/7                                                                     
      PARAMETER (DGNORM=1, DINIT=38, DSTNRM=2, F=10, F0=13, FDIF=11,    
     1           GTSTEP=4, INCFAC=23, LMAT=42, LMAX0=35, LMAXS=36,      
     2           PREDUC=7, RADFAC=16, RADIUS=8, RAD0=9, RELDX=17,       
     3           TUNER4=29, TUNER5=30, VNEED=4)                         
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA NEGONE/-1.E+0/, ONE/1.E+0/, ONEP2/1.2E+0/, ZERO/0.E+0/       
C/7                                                                     
      PARAMETER (NEGONE=-1.E+0, ONE=1.E+0, ONEP2=1.2E+0, ZERO=0.E+0)    
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      I = IV(1)                                                         
      IF (I .EQ. 1) GO TO 70                                            
      IF (I .EQ. 2) GO TO 80                                            
C                                                                       
C  ***  CHECK VALIDITY OF IV AND V INPUT VALUES  ***                    
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IF (IV(1) .LT. 12) GO TO 10                                       
      IF (IV(1) .GT. 13) GO TO 10                                       
         IV(VNEED) = IV(VNEED) + N*(N+19)/2                             
         IV(IVNEED) = IV(IVNEED) + N                                    
 10   CALL PARCK(2, D, IV, LIV, LV, N, V)                               
      I = IV(1) - 2                                                     
      IF (I .GT. 12) GO TO 999                                          
      GO TO (250, 250, 250, 250, 250, 250, 190, 150, 190, 20, 20, 30), I
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
 20   L = IV(LMAT)                                                      
      IV(X0) = L + N*(N+1)/2                                            
      IV(STEP) = IV(X0) + 2*N                                           
      IV(STLSTG) = IV(STEP) + 2*N                                       
      IV(NWTSTP) = IV(STLSTG) + N                                       
      IV(DG) = IV(NWTSTP) + 2*N                                         
      IV(NEXTV) = IV(DG) + 2*N                                          
      IV(NEXTIV) = IV(PERM) + N                                         
      IF (IV(1) .NE. 13) GO TO 30                                       
         IV(1) = 14                                                     
         GO TO 999                                                      
C                                                                       
C  ***  INITIALIZATION  ***                                             
C                                                                       
 30   IV(NITER) = 0                                                     
      IV(NFCALL) = 1                                                    
      IV(NGCALL) = 1                                                    
      IV(NFGCAL) = 1                                                    
      IV(MODE) = -1                                                     
      IV(MODEL) = 1                                                     
      IV(STGLIM) = 1                                                    
      IV(TOOBIG) = 0                                                    
      IV(CNVCOD) = 0                                                    
      IV(RADINC) = 0                                                    
      IV(NC) = N                                                        
      V(RAD0) = ZERO                                                    
C                                                                       
C  ***  CHECK CONSISTENCY OF B AND INITIALIZE IP ARRAY  ***             
C                                                                       
      IPI = IV(PERM)                                                    
      DO 40 I = 1, N                                                    
         IV(IPI) = I                                                    
         IPI = IPI + 1                                                  
         IF (B(1,I) .GT. B(2,I)) GO TO 410                              
 40      CONTINUE                                                       
C                                                                       
      IF (V(DINIT) .GE. ZERO) CALL  V7SCP(N, D, V(DINIT))               
      IF (IV(INITH) .NE. 1) GO TO 60                                    
C                                                                       
C     ***  SET THE INITIAL HESSIAN APPROXIMATION TO DIAG(D)**-2  ***    
C                                                                       
         L = IV(LMAT)                                                   
         CALL  V7SCP(N*(N+1)/2, V(L), ZERO)                             
         K = L - 1                                                      
         DO 50 I = 1, N                                                 
              K = K + I                                                 
              T = D(I)                                                  
              IF (T .LE. ZERO) T = ONE                                  
              V(K) = T                                                  
 50           CONTINUE                                                  
C                                                                       
C  ***  GET INITIAL FUNCTION VALUE  ***                                 
C                                                                       
 60   IV(1) = 1                                                         
      GO TO 440                                                         
C                                                                       
 70   V(F) = FX                                                         
      IF (IV(MODE) .GE. 0) GO TO 250                                    
      IV(1) = 2                                                         
      IF (IV(TOOBIG) .EQ. 0) GO TO 999                                  
         IV(1) = 63                                                     
         GO TO 430                                                      
C                                                                       
C  ***  MAKE SURE GRADIENT COULD BE COMPUTED  ***                       
C                                                                       
 80   IF (IV(TOOBIG) .EQ. 0) GO TO 90                                   
         IV(1) = 65                                                     
         GO TO 430                                                      
C                                                                       
C  ***  CHOOSE INITIAL PERMUTATION  ***                                 
C                                                                       
 90   IPI = IV(PERM)                                                    
      IPN = IPI + N                                                     
      N1 = N                                                            
      NP1 = N + 1                                                       
      L = IV(LMAT)                                                      
      W1 = IV(NWTSTP) + N                                               
      K = N - IV(NC)                                                    
      DO 120 I = 1, N                                                   
         IPN = IPN - 1                                                  
         J = IV(IPN)                                                    
         IF (B(1,J) .GE. B(2,J)) GO TO 100                              
         XI = X(J)                                                      
         GI = G(J)                                                      
         IF (XI .LE. B(1,J) .AND. GI .GT. ZERO) GO TO 100               
         IF (XI .GE. B(2,J) .AND. GI .LT. ZERO) GO TO 100               
C           *** DISALLOW CONVERGENCE IF X(J) HAS JUST BEEN FREED ***    
            IF (I .LE. K) IV(CNVCOD) = 0                                
            GO TO 120                                                   
 100     I1 = NP1 - I                                                   
         IF (I1 .GE. N1) GO TO 110                                      
            CALL I7SHFT(N1, I1, IV(IPI))                                
            CALL  Q7RSH(I1, N1, .FALSE., G, V(L), V(W1))                
 110        N1 = N1 - 1                                                 
 120     CONTINUE                                                       
C                                                                       
      IV(NC) = N1                                                       
      V(DGNORM) = ZERO                                                  
      IF (N1 .LE. 0) GO TO 130                                          
         DG1 = IV(DG)                                                   
         CALL  V7VMP(N, V(DG1), G, D, -1)                               
         CALL  V7IPR(N, IV(IPI), V(DG1))                                
         V(DGNORM) =  V2NRM(N1, V(DG1))                                 
 130  IF (IV(CNVCOD) .NE. 0) GO TO 420                                  
      IF (IV(MODE) .EQ. 0) GO TO 370                                    
C                                                                       
C  ***  ALLOW FIRST STEP TO HAVE SCALED 2-NORM AT MOST V(LMAX0)  ***    
C                                                                       
      V(RADIUS) = V(LMAX0)                                              
C                                                                       
      IV(MODE) = 0                                                      
C                                                                       
C                                                                       
C-----------------------------  MAIN LOOP  -----------------------------
C                                                                       
C                                                                       
C  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***             
C                                                                       
 140  CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
 150  K = IV(NITER)                                                     
      IF (K .LT. IV(MXITER)) GO TO 160                                  
         IV(1) = 10                                                     
         GO TO 430                                                      
C                                                                       
C  ***  UPDATE RADIUS  ***                                              
C                                                                       
 160  IV(NITER) = K + 1                                                 
      IF (K .EQ. 0) GO TO 170                                           
      T = V(RADFAC) * V(DSTNRM)                                         
      IF (V(RADFAC) .LT. ONE .OR. T .GT. V(RADIUS)) V(RADIUS) = T       
C                                                                       
C  ***  INITIALIZE FOR START OF NEXT ITERATION  ***                     
C                                                                       
 170  X01 = IV(X0)                                                      
      V(F0) = V(F)                                                      
      IV(IRC) = 4                                                       
      IV(KAGQT) = -1                                                    
C                                                                       
C     ***  COPY X TO X0  ***                                            
C                                                                       
      CALL V7CPY(N, V(X01), X)                                          
C                                                                       
C  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***                  
C                                                                       
 180  IF (.NOT. STOPX(DUMMY)) GO TO 200                                 
         IV(1) = 11                                                     
         GO TO 210                                                      
C                                                                       
C     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.  
C                                                                       
 190  IF (V(F) .GE. V(F0)) GO TO 200                                    
         V(RADFAC) = ONE                                                
         K = IV(NITER)                                                  
         GO TO 160                                                      
C                                                                       
 200  IF (IV(NFCALL) .LT. IV(MXFCAL)) GO TO 220                         
         IV(1) = 9                                                      
 210     IF (V(F) .GE. V(F0)) GO TO 430                                 
C                                                                       
C        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH        
C        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.                
C                                                                       
              IV(CNVCOD) = IV(1)                                        
              GO TO 360                                                 
C                                                                       
C. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . . 
C                                                                       
 220  STEP1 = IV(STEP)                                                  
      DG1 = IV(DG)                                                      
      NWTST1 = IV(NWTSTP)                                               
      W1 = NWTST1 + N                                                   
      DSTEP1 = STEP1 + N                                                
      IPI = IV(PERM)                                                    
      L = IV(LMAT)                                                      
      TG1 = DG1 + N                                                     
      X01 = IV(X0)                                                      
      TD1 = X01 + N                                                     
      CALL  D7DGB(B, D, V(DG1), V(DSTEP1), G, IV(IPI), IV(KAGQT),       
     1            V(L), LV, N, IV(NC), V(NWTST1), V(STEP1), V(TD1),     
     2            V(TG1), V, V(W1), V(X01))                             
      IF (IV(IRC) .NE. 6) GO TO 230                                     
         IF (IV(RESTOR) .NE. 2) GO TO 250                               
         RSTRST = 2                                                     
         GO TO 260                                                      
C                                                                       
C  ***  CHECK WHETHER EVALUATING F(X0 + STEP) LOOKS WORTHWHILE  ***     
C                                                                       
 230  IV(TOOBIG) = 0                                                    
      IF (V(DSTNRM) .LE. ZERO) GO TO 250                                
      IF (IV(IRC) .NE. 5) GO TO 240                                     
      IF (V(RADFAC) .LE. ONE) GO TO 240                                 
      IF (V(PREDUC) .GT. ONEP2 * V(FDIF)) GO TO 240                     
         IF (IV(RESTOR) .NE. 2) GO TO 250                               
         RSTRST = 0                                                     
         GO TO 260                                                      
C                                                                       
C  ***  COMPUTE F(X0 + STEP)  ***                                       
C                                                                       
 240  CALL V2AXY(N, X, ONE, V(STEP1), V(X01))                           
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 440                                                         
C                                                                       
C. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
C                                                                       
 250  RSTRST = 3                                                        
 260  X01 = IV(X0)                                                      
      V(RELDX) =  RLDST(N, D, X, V(X01))                                
      CALL A7SST(IV, LIV, LV, V)                                        
      STEP1 = IV(STEP)                                                  
      LSTGST = IV(STLSTG)                                               
      I = IV(RESTOR) + 1                                                
      GO TO (300, 270, 280, 290), I                                     
 270  CALL V7CPY(N, X, V(X01))                                          
      GO TO 300                                                         
 280   CALL V7CPY(N, V(LSTGST), X)                                      
       GO TO 300                                                        
 290     CALL V7CPY(N, X, V(LSTGST))                                    
         CALL V2AXY(N, V(STEP1), NEGONE, V(X01), X)                     
         V(RELDX) =  RLDST(N, D, X, V(X01))                             
         IV(RESTOR) = RSTRST                                            
C                                                                       
 300  K = IV(IRC)                                                       
      GO TO (310,340,340,340,310,320,330,330,330,330,330,330,400,370), K
C                                                                       
C     ***  RECOMPUTE STEP WITH CHANGED RADIUS  ***                      
C                                                                       
 310     V(RADIUS) = V(RADFAC) * V(DSTNRM)                              
         GO TO 180                                                      
C                                                                       
C  ***  COMPUTE STEP OF LENGTH V(LMAXS) FOR SINGULAR CONVERGENCE TEST.  
C                                                                       
 320  V(RADIUS) = V(LMAXS)                                              
      GO TO 220                                                         
C                                                                       
C  ***  CONVERGENCE OR FALSE CONVERGENCE  ***                           
C                                                                       
 330  IV(CNVCOD) = K - 4                                                
      IF (V(F) .GE. V(F0)) GO TO 420                                    
         IF (IV(XIRC) .EQ. 14) GO TO 420                                
              IV(XIRC) = 14                                             
C                                                                       
C. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
C                                                                       
 340  X01 = IV(X0)                                                      
      STEP1 = IV(STEP)                                                  
      CALL V2AXY(N, V(STEP1), NEGONE, V(X01), X)                        
      IF (IV(IRC) .NE. 3) GO TO 360                                     
C                                                                       
C     ***  SET  TEMP1 = HESSIAN * STEP  FOR USE IN GRADIENT TESTS  ***  
C                                                                       
C     ***  USE X0 AS TEMPORARY...                                       
C                                                                       
         IPI = IV(PERM)                                                 
         CALL V7CPY(N, V(X01), V(STEP1))                                
         CALL  V7IPR(N, IV(IPI), V(X01))                                
         L = IV(LMAT)                                                   
         CALL  L7TVM(N, V(X01), V(L), V(X01))                           
         CALL L7VML(N, V(X01), V(L), V(X01))                            
C                                                                       
C        *** UNPERMUTE X0 INTO TEMP1 ***                                
C                                                                       
         TEMP1 = IV(STLSTG)                                             
         TEMP0 = TEMP1 - 1                                              
         DO 350 I = 1, N                                                
            J = IV(IPI)                                                 
            IPI = IPI + 1                                               
            K = TEMP0 + J                                               
            V(K) = V(X01)                                               
            X01 = X01 + 1                                               
 350        CONTINUE                                                    
C                                                                       
C  ***  SAVE OLD GRADIENT, COMPUTE NEW ONE  ***                         
C                                                                       
 360  G01 = IV(NWTSTP) + N                                              
      CALL V7CPY(N, V(G01), G)                                          
      IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(TOOBIG) = 0                                                    
      IV(1) = 2                                                         
      GO TO 999                                                         
C                                                                       
C  ***  INITIALIZATIONS -- G0 = G - G0, ETC.  ***                       
C                                                                       
 370  G01 = IV(NWTSTP) + N                                              
      CALL V2AXY(N, V(G01), NEGONE, V(G01), G)                          
      STEP1 = IV(STEP)                                                  
      TEMP1 = IV(STLSTG)                                                
      IF (IV(IRC) .NE. 3) GO TO 390                                     
C                                                                       
C  ***  SET V(RADFAC) BY GRADIENT TESTS  ***                            
C                                                                       
C     ***  SET  TEMP1 = DIAG(D)**-1 * (HESSIAN*STEP + (G(X0)-G(X)))  ***
C                                                                       
         CALL V2AXY(N, V(TEMP1), NEGONE, V(G01), V(TEMP1))              
         CALL  V7VMP(N, V(TEMP1), V(TEMP1), D, -1)                      
C                                                                       
C        ***  DO GRADIENT TESTS  ***                                    
C                                                                       
         IF ( V2NRM(N, V(TEMP1)) .LE. V(DGNORM) * V(TUNER4))            
     1                  GO TO 380                                       
              IF ( D7TPR(N, G, V(STEP1))                                
     1                  .GE. V(GTSTEP) * V(TUNER5))  GO TO 390          
 380               V(RADFAC) = V(INCFAC)                                
C                                                                       
C  ***  UPDATE H, LOOP  ***                                             
C                                                                       
 390  W1 = IV(NWTSTP)                                                   
      Z = IV(X0)                                                        
      L = IV(LMAT)                                                      
      IPI = IV(PERM)                                                    
      CALL  V7IPR(N, IV(IPI), V(STEP1))                                 
      CALL  V7IPR(N, IV(IPI), V(G01))                                   
      CALL  W7ZBF(V(L), N, V(STEP1), V(W1), V(G01), V(Z))               
C                                                                       
C     ** USE THE N-VECTORS STARTING AT V(STEP1) AND V(G01) FOR SCRATCH..
      CALL  L7UPD(V(TEMP1), V(STEP1), V(L), V(G01), V(L), N, V(W1),     
     1            V(Z))                                                 
      IV(1) = 2                                                         
      GO TO 140                                                         
C                                                                       
C. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
C                                                                       
C  ***  BAD PARAMETERS TO ASSESS  ***                                   
C                                                                       
 400  IV(1) = 64                                                        
      GO TO 430                                                         
C                                                                       
C  ***  INCONSISTENT B  ***                                             
C                                                                       
 410  IV(1) = 82                                                        
      GO TO 430                                                         
C                                                                       
C  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  *** 
C                                                                       
 420  IV(1) = IV(CNVCOD)                                                
      IV(CNVCOD) = 0                                                    
 430  CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
      GO TO 999                                                         
C                                                                       
C  ***  PROJECT X INTO FEASIBLE REGION (PRIOR TO COMPUTING F OR G)  *** 
C                                                                       
 440  DO 450 I = 1, N                                                   
         IF (X(I) .LT. B(1,I)) X(I) = B(1,I)                            
         IF (X(I) .GT. B(2,I)) X(I) = B(2,I)                            
 450     CONTINUE                                                       
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF  RMNGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  RMNH(D, FX, G, H, IV, LH, LIV, LV, N, V, X)           
C                                                                       
C  ***  CARRY OUT   MNH (UNCONSTRAINED MINIMIZATION) ITERATIONS, USING  
C  ***  HESSIAN MATRIX PROVIDED BY THE CALLER.                          
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LH, LIV, LV, N                                            
      INTEGER IV(LIV)                                                   
      REAL D(N), FX, G(N), H(LH), V(LV), X(N)                           
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C D.... SCALE VECTOR.                                                   
C FX... FUNCTION VALUE.                                                 
C G.... GRADIENT VECTOR.                                                
C H.... LOWER TRIANGLE OF THE HESSIAN, STORED ROWWISE.                  
C IV... INTEGER VALUE ARRAY.                                            
C LH... LENGTH OF H = P*(P+1)/2.                                        
C LIV.. LENGTH OF IV (AT LEAST 60).                                     
C LV... LENGTH OF V (AT LEAST 78 + N*(N+21)/2).                         
C N.... NUMBER OF VARIABLES (COMPONENTS IN X AND G).                    
C V.... FLOATING-POINT VALUE ARRAY.                                     
C X.... PARAMETER VECTOR.                                               
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        PARAMETERS IV, N, V, AND X ARE THE SAME AS THE CORRESPONDING   
C     ONES TO   MNH (WHICH SEE), EXCEPT THAT V CAN BE SHORTER (SINCE    
C     THE PART OF V THAT   MNH USES FOR STORING G AND H IS NOT NEEDED). 
C     MOREOVER, COMPARED WITH   MNH, IV(1) MAY HAVE THE TWO ADDITIONAL  
C     OUTPUT VALUES 1 AND 2, WHICH ARE EXPLAINED BELOW, AS IS THE USE   
C     OF IV(TOOBIG) AND IV(NFGCAL).  THE VALUE IV(G), WHICH IS AN       
C     OUTPUT VALUE FROM   MNH, IS NOT REFERENCED BY  RMNH OR THE        
C     SUBROUTINES IT CALLS.                                             
C                                                                       
C IV(1) = 1 MEANS THE CALLER SHOULD SET FX TO F(X), THE FUNCTION VALUE  
C             AT X, AND CALL  RMNH AGAIN, HAVING CHANGED NONE OF THE    
C             OTHER PARAMETERS.  AN EXCEPTION OCCURS IF F(X) CANNOT BE  
C             COMPUTED (E.G. IF OVERFLOW WOULD OCCUR), WHICH MAY HAPPEN 
C             BECAUSE OF AN OVERSIZED STEP.  IN THIS CASE THE CALLER    
C             SHOULD SET IV(TOOBIG) = IV(2) TO 1, WHICH WILL CAUSE      
C              RMNH TO IGNORE FX AND TRY A SMALLER STEP.  THE PARA-     
C             METER NF THAT   MNH PASSES TO CALCF (FOR POSSIBLE USE BY  
C             CALCGH) IS A COPY OF IV(NFCALL) = IV(6).                  
C IV(1) = 2 MEANS THE CALLER SHOULD SET G TO G(X), THE GRADIENT OF F AT 
C             X, AND H TO THE LOWER TRIANGLE OF H(X), THE HESSIAN OF F  
C             AT X, AND CALL  RMNH AGAIN, HAVING CHANGED NONE OF THE    
C             OTHER PARAMETERS EXCEPT PERHAPS THE SCALE VECTOR D.       
C                  THE PARAMETER NF THAT   MNH PASSES TO CALCG IS       
C             IV(NFGCAL) = IV(7).  IF G(X) AND H(X) CANNOT BE EVALUATED,
C             THEN THE CALLER MAY SET IV(TOOBIG) TO 0, IN WHICH CASE    
C              RMNH WILL RETURN WITH IV(1) = 65.                        
C                  NOTE --  RMNH OVERWRITES H WITH THE LOWER TRIANGLE   
C             OF  DIAG(D)**-1 * H(X) * DIAG(D)**-1.                     
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (WINTER 1980).  REVISED SEPT. 1982.         
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH SUPPORTED 
C     IN PART BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS           
C     MCS-7600324 AND MCS-7906671.                                      
C                                                                       
C        (SEE   MNG AND   MNH FOR REFERENCES.)                          
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER DG1, DUMMY, I, J, K, L, LSTGST, NN1O2, RSTRST, STEP1,     
     1        TEMP1, W1, X01                                            
      REAL T                                                            
C                                                                       
C     ***  CONSTANTS  ***                                               
C                                                                       
      REAL ONE, ONEP2, ZERO                                             
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      LOGICAL STOPX                                                     
      REAL  D7TPR,  RLDST,  V2NRM                                       
      EXTERNAL A7SST, IVSET,  D7TPR, D7DUP, G7QTS, ITSUM, PARCK,        
     1          RLDST,  S7LVM, STOPX, V2AXY, V7CPY,  V7SCP,  V2NRM      
C                                                                       
C A7SST.... ASSESSES CANDIDATE STEP.                                    
C IVSET.... PROVIDES DEFAULT IV AND V INPUT VALUES.                     
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C D7DUP.... UPDATES SCALE VECTOR D.                                     
C G7QTS.... COMPUTES OPTIMALLY LOCALLY CONSTRAINED STEP.                
C ITSUM.... PRINTS ITERATION SUMMARY AND INFO ON INITIAL AND FINAL X.   
C PARCK.... CHECKS VALIDITY OF INPUT IV AND V VALUES.                   
C  RLDST... COMPUTES V(RELDX) = RELATIVE STEP SIZE.                     
C  S7LVM... MULTIPLIES SYMMETRIC MATRIX TIMES VECTOR, GIVEN THE LOWER   
C             TRIANGLE OF THE MATRIX.                                   
C STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.           
C V2AXY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.              
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C  V2NRM... RETURNS THE 2-NORM OF A VECTOR.                             
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, DG, DGNORM, DINIT, DSTNRM, DTINIT, DTOL,          
     1        DTYPE, D0INIT, F, F0, FDIF, GTSTEP, INCFAC, IRC, KAGQT,   
     2        LMAT, LMAX0, LMAXS, MODE, MODEL, MXFCAL, MXITER, NEXTV,   
     3        NFCALL, NFGCAL, NGCALL, NITER, PHMXFC, PREDUC, RADFAC,    
     4        RADINC, RADIUS, RAD0, RELDX, RESTOR, STEP, STGLIM, STLSTG,
     5        STPPAR, TOOBIG, TUNER4, TUNER5, VNEED, W, XIRC, X0        
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, DG/37/, DTOL/59/, DTYPE/16/, IRC/29/, KAGQT/33/, 
C    1     LMAT/42/, MODE/35/, MODEL/5/, MXFCAL/17/, MXITER/18/,        
C    2     NEXTV/47/, NFCALL/6/, NFGCAL/7/, NGCALL/30/, NITER/31/,      
C    3     RADINC/8/, RESTOR/9/, STEP/40/, STGLIM/11/, STLSTG/41/,      
C    4     TOOBIG/2/, VNEED/4/, W/34/, XIRC/13/, X0/43/                 
C/7                                                                     
      PARAMETER (CNVCOD=55, DG=37, DTOL=59, DTYPE=16, IRC=29, KAGQT=33, 
     1           LMAT=42, MODE=35, MODEL=5, MXFCAL=17, MXITER=18,       
     2           NEXTV=47, NFCALL=6, NFGCAL=7, NGCALL=30, NITER=31,     
     3           RADINC=8, RESTOR=9, STEP=40, STGLIM=11, STLSTG=41,     
     4           TOOBIG=2, VNEED=4, W=34, XIRC=13, X0=43)               
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA DGNORM/1/, DINIT/38/, DSTNRM/2/, DTINIT/39/, D0INIT/40/,     
C    1     F/10/, F0/13/, FDIF/11/, GTSTEP/4/, INCFAC/23/, LMAX0/35/,   
C    2     LMAXS/36/, PHMXFC/21/, PREDUC/7/, RADFAC/16/, RADIUS/8/,     
C    3     RAD0/9/, RELDX/17/, STPPAR/5/, TUNER4/29/, TUNER5/30/        
C/7                                                                     
      PARAMETER (DGNORM=1, DINIT=38, DSTNRM=2, DTINIT=39, D0INIT=40,    
     1           F=10, F0=13, FDIF=11, GTSTEP=4, INCFAC=23, LMAX0=35,   
     2           LMAXS=36, PHMXFC=21, PREDUC=7, RADFAC=16, RADIUS=8,    
     3           RAD0=9, RELDX=17, STPPAR=5, TUNER4=29, TUNER5=30)      
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA ONE/1.E+0/, ONEP2/1.2E+0/, ZERO/0.E+0/                       
C/7                                                                     
      PARAMETER (ONE=1.E+0, ONEP2=1.2E+0, ZERO=0.E+0)                   
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      I = IV(1)                                                         
      IF (I .EQ. 1) GO TO 30                                            
      IF (I .EQ. 2) GO TO 40                                            
C                                                                       
C  ***  CHECK VALIDITY OF IV AND V INPUT VALUES  ***                    
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IF (IV(1) .EQ. 12 .OR. IV(1) .EQ. 13)                             
     1     IV(VNEED) = IV(VNEED) + N*(N+21)/2 + 7                       
      CALL PARCK(2, D, IV, LIV, LV, N, V)                               
      I = IV(1) - 2                                                     
      IF (I .GT. 12) GO TO 999                                          
      NN1O2 = N * (N + 1) / 2                                           
      IF (LH .GE. NN1O2) GO TO (220,220,220,220,220,220,160,120,160,    
     1                          10,10,20), I                            
         IV(1) = 66                                                     
         GO TO 400                                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
 10   IV(DTOL) = IV(LMAT) + NN1O2                                       
      IV(X0) = IV(DTOL) + 2*N                                           
      IV(STEP) = IV(X0) + N                                             
      IV(STLSTG) = IV(STEP) + N                                         
      IV(DG) = IV(STLSTG) + N                                           
      IV(W) = IV(DG) + N                                                
      IV(NEXTV) = IV(W) + 4*N + 7                                       
      IF (IV(1) .NE. 13) GO TO 20                                       
         IV(1) = 14                                                     
         GO TO 999                                                      
C                                                                       
C  ***  INITIALIZATION  ***                                             
C                                                                       
 20   IV(NITER) = 0                                                     
      IV(NFCALL) = 1                                                    
      IV(NGCALL) = 1                                                    
      IV(NFGCAL) = 1                                                    
      IV(MODE) = -1                                                     
      IV(MODEL) = 1                                                     
      IV(STGLIM) = 1                                                    
      IV(TOOBIG) = 0                                                    
      IV(CNVCOD) = 0                                                    
      IV(RADINC) = 0                                                    
      V(RAD0) = ZERO                                                    
      V(STPPAR) = ZERO                                                  
      IF (V(DINIT) .GE. ZERO) CALL  V7SCP(N, D, V(DINIT))               
      K = IV(DTOL)                                                      
      IF (V(DTINIT) .GT. ZERO) CALL  V7SCP(N, V(K), V(DTINIT))          
      K = K + N                                                         
      IF (V(D0INIT) .GT. ZERO) CALL  V7SCP(N, V(K), V(D0INIT))          
      IV(1) = 1                                                         
      GO TO 999                                                         
C                                                                       
 30   V(F) = FX                                                         
      IF (IV(MODE) .GE. 0) GO TO 220                                    
      IV(1) = 2                                                         
      IF (IV(TOOBIG) .EQ. 0) GO TO 999                                  
         IV(1) = 63                                                     
         GO TO 400                                                      
C                                                                       
C  ***  MAKE SURE GRADIENT COULD BE COMPUTED  ***                       
C                                                                       
 40   IF (IV(TOOBIG) .EQ. 0) GO TO 50                                   
         IV(1) = 65                                                     
         GO TO 400                                                      
C                                                                       
C  ***  UPDATE THE SCALE VECTOR D  ***                                  
C                                                                       
 50   DG1 = IV(DG)                                                      
      IF (IV(DTYPE) .LE. 0) GO TO 70                                    
      K = DG1                                                           
      J = 0                                                             
      DO 60 I = 1, N                                                    
         J = J + I                                                      
         V(K) = H(J)                                                    
         K = K + 1                                                      
 60      CONTINUE                                                       
      CALL D7DUP(D, V(DG1), IV, LIV, LV, N, V)                          
C                                                                       
C  ***  COMPUTE SCALED GRADIENT AND ITS NORM  ***                       
C                                                                       
 70   DG1 = IV(DG)                                                      
      K = DG1                                                           
      DO 80 I = 1, N                                                    
         V(K) = G(I) / D(I)                                             
         K = K + 1                                                      
 80      CONTINUE                                                       
      V(DGNORM) =  V2NRM(N, V(DG1))                                     
C                                                                       
C  ***  COMPUTE SCALED HESSIAN  ***                                     
C                                                                       
      K = 1                                                             
      DO 100 I = 1, N                                                   
         T = ONE / D(I)                                                 
         DO 90 J = 1, I                                                 
              H(K) = T * H(K) / D(J)                                    
              K = K + 1                                                 
 90           CONTINUE                                                  
 100     CONTINUE                                                       
C                                                                       
      IF (IV(CNVCOD) .NE. 0) GO TO 390                                  
      IF (IV(MODE) .EQ. 0) GO TO 350                                    
C                                                                       
C  ***  ALLOW FIRST STEP TO HAVE SCALED 2-NORM AT MOST V(LMAX0)  ***    
C                                                                       
      V(RADIUS) = V(LMAX0) / (ONE + V(PHMXFC))                          
C                                                                       
      IV(MODE) = 0                                                      
C                                                                       
C                                                                       
C-----------------------------  MAIN LOOP  -----------------------------
C                                                                       
C                                                                       
C  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***             
C                                                                       
 110  CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
 120  K = IV(NITER)                                                     
      IF (K .LT. IV(MXITER)) GO TO 130                                  
         IV(1) = 10                                                     
         GO TO 400                                                      
C                                                                       
 130  IV(NITER) = K + 1                                                 
C                                                                       
C  ***  INITIALIZE FOR START OF NEXT ITERATION  ***                     
C                                                                       
      DG1 = IV(DG)                                                      
      X01 = IV(X0)                                                      
      V(F0) = V(F)                                                      
      IV(IRC) = 4                                                       
      IV(KAGQT) = -1                                                    
C                                                                       
C     ***  COPY X TO X0  ***                                            
C                                                                       
      CALL V7CPY(N, V(X01), X)                                          
C                                                                       
C  ***  UPDATE RADIUS  ***                                              
C                                                                       
      IF (K .EQ. 0) GO TO 150                                           
      STEP1 = IV(STEP)                                                  
      K = STEP1                                                         
      DO 140 I = 1, N                                                   
         V(K) = D(I) * V(K)                                             
         K = K + 1                                                      
 140     CONTINUE                                                       
      V(RADIUS) = V(RADFAC) *  V2NRM(N, V(STEP1))                       
C                                                                       
C  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***                  
C                                                                       
 150  IF (.NOT. STOPX(DUMMY)) GO TO 170                                 
         IV(1) = 11                                                     
         GO TO 180                                                      
C                                                                       
C     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.  
C                                                                       
 160  IF (V(F) .GE. V(F0)) GO TO 170                                    
         V(RADFAC) = ONE                                                
         K = IV(NITER)                                                  
         GO TO 130                                                      
C                                                                       
 170  IF (IV(NFCALL) .LT. IV(MXFCAL)) GO TO 190                         
         IV(1) = 9                                                      
 180     IF (V(F) .GE. V(F0)) GO TO 400                                 
C                                                                       
C        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH        
C        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.                
C                                                                       
              IV(CNVCOD) = IV(1)                                        
              GO TO 340                                                 
C                                                                       
C. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . . 
C                                                                       
 190  STEP1 = IV(STEP)                                                  
      DG1 = IV(DG)                                                      
      L = IV(LMAT)                                                      
      W1 = IV(W)                                                        
      CALL G7QTS(D, V(DG1), H, IV(KAGQT), V(L), N, V(STEP1), V, V(W1))  
      IF (IV(IRC) .NE. 6) GO TO 200                                     
         IF (IV(RESTOR) .NE. 2) GO TO 220                               
         RSTRST = 2                                                     
         GO TO 230                                                      
C                                                                       
C  ***  CHECK WHETHER EVALUATING F(X0 + STEP) LOOKS WORTHWHILE  ***     
C                                                                       
 200  IV(TOOBIG) = 0                                                    
      IF (V(DSTNRM) .LE. ZERO) GO TO 220                                
      IF (IV(IRC) .NE. 5) GO TO 210                                     
      IF (V(RADFAC) .LE. ONE) GO TO 210                                 
      IF (V(PREDUC) .GT. ONEP2 * V(FDIF)) GO TO 210                     
         IF (IV(RESTOR) .NE. 2) GO TO 220                               
         RSTRST = 0                                                     
         GO TO 230                                                      
C                                                                       
C  ***  COMPUTE F(X0 + STEP)  ***                                       
C                                                                       
 210  X01 = IV(X0)                                                      
      STEP1 = IV(STEP)                                                  
      CALL V2AXY(N, X, ONE, V(STEP1), V(X01))                           
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 999                                                         
C                                                                       
C. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
C                                                                       
 220  RSTRST = 3                                                        
 230  X01 = IV(X0)                                                      
      V(RELDX) =  RLDST(N, D, X, V(X01))                                
      CALL A7SST(IV, LIV, LV, V)                                        
      STEP1 = IV(STEP)                                                  
      LSTGST = IV(STLSTG)                                               
      I = IV(RESTOR) + 1                                                
      GO TO (270, 240, 250, 260), I                                     
 240  CALL V7CPY(N, X, V(X01))                                          
      GO TO 270                                                         
 250   CALL V7CPY(N, V(LSTGST), V(STEP1))                               
       GO TO 270                                                        
 260     CALL V7CPY(N, V(STEP1), V(LSTGST))                             
         CALL V2AXY(N, X, ONE, V(STEP1), V(X01))                        
         V(RELDX) =  RLDST(N, D, X, V(X01))                             
         IV(RESTOR) = RSTRST                                            
C                                                                       
 270  K = IV(IRC)                                                       
      GO TO (280,310,310,310,280,290,300,300,300,300,300,300,380,350), K
C                                                                       
C     ***  RECOMPUTE STEP WITH NEW RADIUS  ***                          
C                                                                       
 280     V(RADIUS) = V(RADFAC) * V(DSTNRM)                              
         GO TO 150                                                      
C                                                                       
C  ***  COMPUTE STEP OF LENGTH V(LMAXS) FOR SINGULAR CONVERGENCE TEST.  
C                                                                       
 290  V(RADIUS) = V(LMAXS)                                              
      GO TO 190                                                         
C                                                                       
C  ***  CONVERGENCE OR FALSE CONVERGENCE  ***                           
C                                                                       
 300  IV(CNVCOD) = K - 4                                                
      IF (V(F) .GE. V(F0)) GO TO 390                                    
         IF (IV(XIRC) .EQ. 14) GO TO 390                                
              IV(XIRC) = 14                                             
C                                                                       
C. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
C                                                                       
 310  IF (IV(IRC) .NE. 3) GO TO 340                                     
         TEMP1 = LSTGST                                                 
C                                                                       
C     ***  PREPARE FOR GRADIENT TESTS  ***                              
C     ***  SET  TEMP1 = HESSIAN * STEP + G(X0)                          
C     ***             = DIAG(D) * (H * STEP + G(X0))                    
C                                                                       
C        USE X0 VECTOR AS TEMPORARY.                                    
         K = X01                                                        
         DO 320 I = 1, N                                                
              V(K) = D(I) * V(STEP1)                                    
              K = K + 1                                                 
              STEP1 = STEP1 + 1                                         
 320          CONTINUE                                                  
         CALL  S7LVM(N, V(TEMP1), H, V(X01))                            
         DO 330 I = 1, N                                                
              V(TEMP1) = D(I) * V(TEMP1) + G(I)                         
              TEMP1 = TEMP1 + 1                                         
 330          CONTINUE                                                  
C                                                                       
C  ***  COMPUTE GRADIENT AND HESSIAN  ***                               
C                                                                       
 340  IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(TOOBIG) = 0                                                    
      IV(1) = 2                                                         
      GO TO 999                                                         
C                                                                       
 350  IV(1) = 2                                                         
      IF (IV(IRC) .NE. 3) GO TO 110                                     
C                                                                       
C  ***  SET V(RADFAC) BY GRADIENT TESTS  ***                            
C                                                                       
      TEMP1 = IV(STLSTG)                                                
      STEP1 = IV(STEP)                                                  
C                                                                       
C     ***  SET  TEMP1 = DIAG(D)**-1 * (HESSIAN*STEP + (G(X0)-G(X)))  ***
C                                                                       
      K = TEMP1                                                         
      DO 360 I = 1, N                                                   
         V(K) = (V(K) - G(I)) / D(I)                                    
         K = K + 1                                                      
 360     CONTINUE                                                       
C                                                                       
C     ***  DO GRADIENT TESTS  ***                                       
C                                                                       
      IF ( V2NRM(N, V(TEMP1)) .LE. V(DGNORM) * V(TUNER4)) GO TO 370     
           IF ( D7TPR(N, G, V(STEP1))                                   
     1               .GE. V(GTSTEP) * V(TUNER5))  GO TO 110             
 370            V(RADFAC) = V(INCFAC)                                   
                GO TO 110                                               
C                                                                       
C. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
C                                                                       
C  ***  BAD PARAMETERS TO ASSESS  ***                                   
C                                                                       
 380  IV(1) = 64                                                        
      GO TO 400                                                         
C                                                                       
C  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  *** 
C                                                                       
 390  IV(1) = IV(CNVCOD)                                                
      IV(CNVCOD) = 0                                                    
 400  CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF  RMNH FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  RMNHB(B, D, FX, G, H, IV, LH, LIV, LV, N, V, X)       
C                                                                       
C  ***  CARRY OUT   MNHB (SIMPLY BOUNDED MINIMIZATION) ITERATIONS,      
C  ***  USING HESSIAN MATRIX PROVIDED BY THE CALLER.                    
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LH, LIV, LV, N                                            
      INTEGER IV(LIV)                                                   
      REAL B(2,N), D(N), FX, G(N), H(LH), V(LV), X(N)                   
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C D.... SCALE VECTOR.                                                   
C FX... FUNCTION VALUE.                                                 
C G.... GRADIENT VECTOR.                                                
C H.... LOWER TRIANGLE OF THE HESSIAN, STORED ROWWISE.                  
C IV... INTEGER VALUE ARRAY.                                            
C LH... LENGTH OF H = P*(P+1)/2.                                        
C LIV.. LENGTH OF IV (AT LEAST 60).                                     
C LV... LENGTH OF V (AT LEAST 78 + N*(N+21)/2).                         
C N.... NUMBER OF VARIABLES (COMPONENTS IN X AND G).                    
C V.... FLOATING-POINT VALUE ARRAY.                                     
C X.... PARAMETER VECTOR.                                               
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        PARAMETERS IV, N, V, AND X ARE THE SAME AS THE CORRESPONDING   
C     ONES TO   MNHB (WHICH SEE), EXCEPT THAT V CAN BE SHORTER (SINCE   
C     THE PART OF V THAT   MNHB USES FOR STORING G AND H IS NOT NEEDED).
C     MOREOVER, COMPARED WITH   MNHB, IV(1) MAY HAVE THE TWO ADDITIONAL 
C     OUTPUT VALUES 1 AND 2, WHICH ARE EXPLAINED BELOW, AS IS THE USE   
C     OF IV(TOOBIG) AND IV(NFGCAL).  THE VALUE IV(G), WHICH IS AN       
C     OUTPUT VALUE FROM   MNHB, IS NOT REFERENCED BY  RMNHB OR THE      
C     SUBROUTINES IT CALLS.                                             
C                                                                       
C IV(1) = 1 MEANS THE CALLER SHOULD SET FX TO F(X), THE FUNCTION VALUE  
C             AT X, AND CALL  RMNHB AGAIN, HAVING CHANGED NONE OF THE   
C             OTHER PARAMETERS.  AN EXCEPTION OCCURS IF F(X) CANNOT BE  
C             COMPUTED (E.G. IF OVERFLOW WOULD OCCUR), WHICH MAY HAPPEN 
C             BECAUSE OF AN OVERSIZED STEP.  IN THIS CASE THE CALLER    
C             SHOULD SET IV(TOOBIG) = IV(2) TO 1, WHICH WILL CAUSE      
C              RMNHB TO IGNORE FX AND TRY A SMALLER STEP.  THE PARA-    
C             METER NF THAT   MNH PASSES TO CALCF (FOR POSSIBLE USE BY  
C             CALCGH) IS A COPY OF IV(NFCALL) = IV(6).                  
C IV(1) = 2 MEANS THE CALLER SHOULD SET G TO G(X), THE GRADIENT OF F AT 
C             X, AND H TO THE LOWER TRIANGLE OF H(X), THE HESSIAN OF F  
C             AT X, AND CALL  RMNHB AGAIN, HAVING CHANGED NONE OF THE   
C             OTHER PARAMETERS EXCEPT PERHAPS THE SCALE VECTOR D.       
C                  THE PARAMETER NF THAT   MNHB PASSES TO CALCG IS      
C             IV(NFGCAL) = IV(7).  IF G(X) AND H(X) CANNOT BE EVALUATED,
C             THEN THE CALLER MAY SET IV(NFGCAL) TO 0, IN WHICH CASE    
C              RMNHB WILL RETURN WITH IV(1) = 65.                       
C                  NOTE --  RMNHB OVERWRITES H WITH THE LOWER TRIANGLE  
C             OF  DIAG(D)**-1 * H(X) * DIAG(D)**-1.                     
C.                                                                      
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (WINTER, SPRING 1983).                      
C                                                                       
C        (SEE   MNG AND   MNH FOR REFERENCES.)                          
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER DG1, DUMMY, I, IPI, IPIV2, IPN, J, K, L, LSTGST, NN1O2,   
     1        RSTRST, STEP0, STEP1, TD1, TEMP0, TEMP1, TG1, W1, X01, X11
      REAL GI, T, XI                                                    
C                                                                       
C     ***  CONSTANTS  ***                                               
C                                                                       
      REAL NEGONE, ONE, ONEP2, ZERO                                     
C                                                                       
C  ***  NO INTRINSIC FUNCTIONS  ***                                     
C                                                                       
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      LOGICAL STOPX                                                     
      REAL  D7TPR,  RLDST,  V2NRM                                       
      EXTERNAL A7SST, IVSET,  D7TPR, D7DUP,  G7QSB, I7PNVR, ITSUM,      
     1         PARCK,  RLDST,  S7IPR,  S7LVM, STOPX,  V2NRM, V2AXY,     
     2         V7CPY,  V7IPR,  V7SCP,  V7VMP                            
C                                                                       
C A7SST.... ASSESSES CANDIDATE STEP.                                    
C IVSET.... PROVIDES DEFAULT IV AND V INPUT VALUES.                     
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C D7DUP.... UPDATES SCALE VECTOR D.                                     
C  G7QSB... COMPUTES APPROXIMATE OPTIMAL BOUNDED STEP.                  
C I7PNVR... INVERTS PERMUTATION ARRAY.                                  
C ITSUM.... PRINTS ITERATION SUMMARY AND INFO ON INITIAL AND FINAL X.   
C PARCK.... CHECKS VALIDITY OF INPUT IV AND V VALUES.                   
C  RLDST... COMPUTES V(RELDX) = RELATIVE STEP SIZE.                     
C  S7IPR... APPLIES PERMUTATION TO LOWER TRIANG. OF SYM. MATRIX.        
C  S7LVM... MULTIPLIES SYMMETRIC MATRIX TIMES VECTOR, GIVEN THE LOWER   
C             TRIANGLE OF THE MATRIX.                                   
C STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.           
C  V2NRM... RETURNS THE 2-NORM OF A VECTOR.                             
C V2AXY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.              
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7IPR... APPLIES PERMUTATION TO VECTOR.                              
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C  V7VMP... MULTIPLIES (OR DIVIDES) TWO VECTORS COMPONENTWISE.          
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, DG, DGNORM, DINIT, DSTNRM, DTINIT, DTOL, DTYPE,   
     1        D0INIT, F, F0, FDIF, GTSTEP, INCFAC, IVNEED, IRC, KAGQT,  
     2        LMAT, LMAX0, LMAXS, MODE, MODEL, MXFCAL, MXITER, N0, NC,  
     3        NEXTIV, NEXTV, NFCALL, NFGCAL, NGCALL, NITER, PERM,       
     4        PHMXFC, PREDUC, RADFAC, RADINC, RADIUS, RAD0, RELDX,      
     5        RESTOR, STEP, STGLIM, STPPAR, TOOBIG, TUNER4, TUNER5,     
     6        VNEED, W, XIRC, X0                                        
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C  ***  (NOTE THAT NC AND N0 ARE STORED IN IV(G0) AND IV(STLSTG) RESP.) 
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, DG/37/, DTOL/59/, DTYPE/16/, IRC/29/, IVNEED/3/, 
C    1     KAGQT/33/, LMAT/42/, MODE/35/, MODEL/5/, MXFCAL/17/,         
C    2     MXITER/18/, N0/41/, NC/48/, NEXTIV/46/, NEXTV/47/, NFCALL/6/,
C    3     NFGCAL/7/, NGCALL/30/, NITER/31/, PERM/58/, RADINC/8/,       
C    4     RESTOR/9/, STEP/40/, STGLIM/11/, TOOBIG/2/, VNEED/4/, W/34/, 
C    5     XIRC/13/, X0/43/                                             
C/7                                                                     
      PARAMETER (CNVCOD=55, DG=37, DTOL=59, DTYPE=16, IRC=29, IVNEED=3, 
     1           KAGQT=33, LMAT=42, MODE=35, MODEL=5, MXFCAL=17,        
     2           MXITER=18, N0=41, NC=48, NEXTIV=46, NEXTV=47, NFCALL=6,
     3           NFGCAL=7, NGCALL=30, NITER=31, PERM=58, RADINC=8,      
     4           RESTOR=9, STEP=40, STGLIM=11, TOOBIG=2, VNEED=4, W=34, 
     5           XIRC=13, X0=43)                                        
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA DGNORM/1/, DINIT/38/, DSTNRM/2/, DTINIT/39/, D0INIT/40/,     
C    1     F/10/, F0/13/, FDIF/11/, GTSTEP/4/, INCFAC/23/, LMAX0/35/,   
C    2     LMAXS/36/, PHMXFC/21/, PREDUC/7/, RADFAC/16/, RADIUS/8/,     
C    3     RAD0/9/, RELDX/17/, STPPAR/5/, TUNER4/29/, TUNER5/30/        
C/7                                                                     
      PARAMETER (DGNORM=1, DINIT=38, DSTNRM=2, DTINIT=39, D0INIT=40,    
     1           F=10, F0=13, FDIF=11, GTSTEP=4, INCFAC=23, LMAX0=35,   
     2           LMAXS=36, PHMXFC=21, PREDUC=7, RADFAC=16, RADIUS=8,    
     3           RAD0=9, RELDX=17, STPPAR=5, TUNER4=29, TUNER5=30)      
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA NEGONE/-1.E+0/, ONE/1.E+0/, ONEP2/1.2E+0/, ZERO/0.E+0/       
C/7                                                                     
      PARAMETER (NEGONE=-1.E+0, ONE=1.E+0, ONEP2=1.2E+0, ZERO=0.E+0)    
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      I = IV(1)                                                         
      IF (I .EQ. 1) GO TO 50                                            
      IF (I .EQ. 2) GO TO 60                                            
C                                                                       
C  ***  CHECK VALIDITY OF IV AND V INPUT VALUES  ***                    
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(2, IV, LIV, LV, V)                   
      IF (IV(1) .LT. 12) GO TO 10                                       
      IF (IV(1) .GT. 13) GO TO 10                                       
         IV(VNEED) = IV(VNEED) + N*(N+27)/2 + 7                         
         IV(IVNEED) = IV(IVNEED) + 3*N                                  
 10   CALL PARCK(2, D, IV, LIV, LV, N, V)                               
      I = IV(1) - 2                                                     
      IF (I .GT. 12) GO TO 999                                          
      NN1O2 = N * (N + 1) / 2                                           
      IF (LH .GE. NN1O2) GO TO (250,250,250,250,250,250,190,150,190,    
     1                          20,20,30), I                            
         IV(1) = 81                                                     
         GO TO 440                                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
 20   IV(DTOL) = IV(LMAT) + NN1O2                                       
      IV(X0) = IV(DTOL) + 2*N                                           
      IV(STEP) = IV(X0) + 2*N                                           
      IV(DG) = IV(STEP) + 3*N                                           
      IV(W) = IV(DG) + 2*N                                              
      IV(NEXTV) = IV(W) + 4*N + 7                                       
      IV(NEXTIV) = IV(PERM) + 3*N                                       
      IF (IV(1) .NE. 13) GO TO 30                                       
         IV(1) = 14                                                     
         GO TO 999                                                      
C                                                                       
C  ***  INITIALIZATION  ***                                             
C                                                                       
 30   IV(NITER) = 0                                                     
      IV(NFCALL) = 1                                                    
      IV(NGCALL) = 1                                                    
      IV(NFGCAL) = 1                                                    
      IV(MODE) = -1                                                     
      IV(MODEL) = 1                                                     
      IV(STGLIM) = 1                                                    
      IV(TOOBIG) = 0                                                    
      IV(CNVCOD) = 0                                                    
      IV(RADINC) = 0                                                    
      IV(NC) = N                                                        
      V(RAD0) = ZERO                                                    
      V(STPPAR) = ZERO                                                  
      IF (V(DINIT) .GE. ZERO) CALL  V7SCP(N, D, V(DINIT))               
      K = IV(DTOL)                                                      
      IF (V(DTINIT) .GT. ZERO) CALL  V7SCP(N, V(K), V(DTINIT))          
      K = K + N                                                         
      IF (V(D0INIT) .GT. ZERO) CALL  V7SCP(N, V(K), V(D0INIT))          
C                                                                       
C  ***  CHECK CONSISTENCY OF B AND INITIALIZE IP ARRAY  ***             
C                                                                       
      IPI = IV(PERM)                                                    
      DO 40 I = 1, N                                                    
         IV(IPI) = I                                                    
         IPI = IPI + 1                                                  
         IF (B(1,I) .GT. B(2,I)) GO TO 420                              
 40      CONTINUE                                                       
C                                                                       
C  ***  GET INITIAL FUNCTION VALUE  ***                                 
C                                                                       
      IV(1) = 1                                                         
      GO TO 450                                                         
C                                                                       
 50   V(F) = FX                                                         
      IF (IV(MODE) .GE. 0) GO TO 250                                    
      IV(1) = 2                                                         
      IF (IV(TOOBIG) .EQ. 0) GO TO 999                                  
         IV(1) = 63                                                     
         GO TO 440                                                      
C                                                                       
C  ***  MAKE SURE GRADIENT COULD BE COMPUTED  ***                       
C                                                                       
 60   IF (IV(TOOBIG) .EQ. 0) GO TO 70                                   
         IV(1) = 65                                                     
         GO TO 440                                                      
C                                                                       
C  ***  UPDATE THE SCALE VECTOR D  ***                                  
C                                                                       
 70   DG1 = IV(DG)                                                      
      IF (IV(DTYPE) .LE. 0) GO TO 90                                    
      K = DG1                                                           
      J = 0                                                             
      DO 80 I = 1, N                                                    
         J = J + I                                                      
         V(K) = H(J)                                                    
         K = K + 1                                                      
 80      CONTINUE                                                       
      CALL D7DUP(D, V(DG1), IV, LIV, LV, N, V)                          
C                                                                       
C  ***  COMPUTE SCALED GRADIENT AND ITS NORM  ***                       
C                                                                       
 90   DG1 = IV(DG)                                                      
      CALL  V7VMP(N, V(DG1), G, D, -1)                                  
C                                                                       
C  ***  COMPUTE SCALED HESSIAN  ***                                     
C                                                                       
      K = 1                                                             
      DO 110 I = 1, N                                                   
         T = ONE / D(I)                                                 
         DO 100 J = 1, I                                                
              H(K) = T * H(K) / D(J)                                    
              K = K + 1                                                 
 100          CONTINUE                                                  
 110     CONTINUE                                                       
C                                                                       
C  ***  CHOOSE INITIAL PERMUTATION  ***                                 
C                                                                       
      IPI = IV(PERM)                                                    
      IPN = IPI + N                                                     
      IPIV2 = IPN - 1                                                   
C     *** INVERT OLD PERMUTATION ARRAY ***                              
      CALL I7PNVR(N, IV(IPN), IV(IPI))                                  
      K = IV(NC)                                                        
      DO 130 I = 1, N                                                   
         IF (B(1,I) .GE. B(2,I)) GO TO 120                              
         XI = X(I)                                                      
         GI = G(I)                                                      
         IF (XI .LE. B(1,I) .AND. GI .GT. ZERO) GO TO 120               
         IF (XI .GE. B(2,I) .AND. GI .LT. ZERO) GO TO 120               
            IV(IPI) = I                                                 
            IPI = IPI + 1                                               
            J = IPIV2 + I                                               
C           *** DISALLOW CONVERGENCE IF X(I) HAS JUST BEEN FREED ***    
            IF (IV(J) .GT. K) IV(CNVCOD) = 0                            
            GO TO 130                                                   
 120     IPN = IPN - 1                                                  
         IV(IPN) = I                                                    
 130     CONTINUE                                                       
      IV(NC) = IPN - IV(PERM)                                           
C                                                                       
C  ***  PERMUTE SCALED GRADIENT AND HESSIAN ACCORDINGLY  ***            
C                                                                       
      IPI = IV(PERM)                                                    
      CALL  S7IPR(N, IV(IPI), H)                                        
      CALL  V7IPR(N, IV(IPI), V(DG1))                                   
      V(DGNORM) = ZERO                                                  
      IF (IV(NC) .GT. 0) V(DGNORM) =  V2NRM(IV(NC), V(DG1))             
C                                                                       
      IF (IV(CNVCOD) .NE. 0) GO TO 430                                  
      IF (IV(MODE) .EQ. 0) GO TO 380                                    
C                                                                       
C  ***  ALLOW FIRST STEP TO HAVE SCALED 2-NORM AT MOST V(LMAX0)  ***    
C                                                                       
      V(RADIUS) = V(LMAX0) / (ONE + V(PHMXFC))                          
C                                                                       
      IV(MODE) = 0                                                      
C                                                                       
C                                                                       
C-----------------------------  MAIN LOOP  -----------------------------
C                                                                       
C                                                                       
C  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***             
C                                                                       
 140  CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
 150  K = IV(NITER)                                                     
      IF (K .LT. IV(MXITER)) GO TO 160                                  
         IV(1) = 10                                                     
         GO TO 440                                                      
C                                                                       
 160  IV(NITER) = K + 1                                                 
C                                                                       
C  ***  INITIALIZE FOR START OF NEXT ITERATION  ***                     
C                                                                       
      X01 = IV(X0)                                                      
      V(F0) = V(F)                                                      
      IV(IRC) = 4                                                       
      IV(KAGQT) = -1                                                    
C                                                                       
C     ***  COPY X TO X0  ***                                            
C                                                                       
      CALL V7CPY(N, V(X01), X)                                          
C                                                                       
C  ***  UPDATE RADIUS  ***                                              
C                                                                       
      IF (K .EQ. 0) GO TO 180                                           
      STEP1 = IV(STEP)                                                  
      K = STEP1                                                         
      DO 170 I = 1, N                                                   
         V(K) = D(I) * V(K)                                             
         K = K + 1                                                      
 170     CONTINUE                                                       
      T = V(RADFAC) *  V2NRM(N, V(STEP1))                               
      IF (V(RADFAC) .LT. ONE .OR. T .GT. V(RADIUS)) V(RADIUS) = T       
C                                                                       
C  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***                  
C                                                                       
 180  IF (.NOT. STOPX(DUMMY)) GO TO 200                                 
         IV(1) = 11                                                     
         GO TO 210                                                      
C                                                                       
C     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.  
C                                                                       
 190  IF (V(F) .GE. V(F0)) GO TO 200                                    
         V(RADFAC) = ONE                                                
         K = IV(NITER)                                                  
         GO TO 160                                                      
C                                                                       
 200  IF (IV(NFCALL) .LT. IV(MXFCAL)) GO TO 220                         
         IV(1) = 9                                                      
 210     IF (V(F) .GE. V(F0)) GO TO 440                                 
C                                                                       
C        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH        
C        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.                
C                                                                       
              IV(CNVCOD) = IV(1)                                        
              GO TO 370                                                 
C                                                                       
C. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . . 
C                                                                       
 220  STEP1 = IV(STEP)                                                  
      L = IV(LMAT)                                                      
      W1 = IV(W)                                                        
      IPI = IV(PERM)                                                    
      IPN = IPI + N                                                     
      IPIV2 = IPN + N                                                   
      TG1 = IV(DG)                                                      
      TD1 = TG1 + N                                                     
      X01 = IV(X0)                                                      
      X11 = X01 + N                                                     
      CALL  G7QSB(B, D, H, G, IV(IPI), IV(IPN), IV(IPIV2), IV(KAGQT),   
     1            V(L), LV, N, IV(N0), IV(NC), V(STEP1), V(TD1), V(TG1),
     2            V, V(W1), V(X11), V(X01))                             
      IF (IV(IRC) .NE. 6) GO TO 230                                     
         IF (IV(RESTOR) .NE. 2) GO TO 250                               
         RSTRST = 2                                                     
         GO TO 260                                                      
C                                                                       
C  ***  CHECK WHETHER EVALUATING F(X0 + STEP) LOOKS WORTHWHILE  ***     
C                                                                       
 230  IV(TOOBIG) = 0                                                    
      IF (V(DSTNRM) .LE. ZERO) GO TO 250                                
      IF (IV(IRC) .NE. 5) GO TO 240                                     
      IF (V(RADFAC) .LE. ONE) GO TO 240                                 
      IF (V(PREDUC) .GT. ONEP2 * V(FDIF)) GO TO 240                     
         IF (IV(RESTOR) .NE. 2) GO TO 250                               
         RSTRST = 0                                                     
         GO TO 260                                                      
C                                                                       
C  ***  COMPUTE F(X0 + STEP)  ***                                       
C                                                                       
 240  CALL V2AXY(N, X, ONE, V(STEP1), V(X01))                           
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 450                                                         
C                                                                       
C. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
C                                                                       
 250  RSTRST = 3                                                        
 260  X01 = IV(X0)                                                      
      V(RELDX) =  RLDST(N, D, X, V(X01))                                
      CALL A7SST(IV, LIV, LV, V)                                        
      STEP1 = IV(STEP)                                                  
      LSTGST = STEP1 + 2*N                                              
      I = IV(RESTOR) + 1                                                
      GO TO (300, 270, 280, 290), I                                     
 270  CALL V7CPY(N, X, V(X01))                                          
      GO TO 300                                                         
 280   CALL V7CPY(N, V(LSTGST), X)                                      
       GO TO 300                                                        
 290     CALL V7CPY(N, X, V(LSTGST))                                    
         CALL V2AXY(N, V(STEP1), NEGONE, V(X01), X)                     
         V(RELDX) =  RLDST(N, D, X, V(X01))                             
         IV(RESTOR) = RSTRST                                            
C                                                                       
 300  K = IV(IRC)                                                       
      GO TO (310,340,340,340,310,320,330,330,330,330,330,330,410,380), K
C                                                                       
C     ***  RECOMPUTE STEP WITH NEW RADIUS  ***                          
C                                                                       
 310     V(RADIUS) = V(RADFAC) * V(DSTNRM)                              
         GO TO 180                                                      
C                                                                       
C  ***  COMPUTE STEP OF LENGTH V(LMAXS) FOR SINGULAR CONVERGENCE TEST.  
C                                                                       
 320  V(RADIUS) = V(LMAXS)                                              
      GO TO 220                                                         
C                                                                       
C  ***  CONVERGENCE OR FALSE CONVERGENCE  ***                           
C                                                                       
 330  IV(CNVCOD) = K - 4                                                
      IF (V(F) .GE. V(F0)) GO TO 430                                    
         IF (IV(XIRC) .EQ. 14) GO TO 430                                
              IV(XIRC) = 14                                             
C                                                                       
C. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
C                                                                       
 340  IF (IV(IRC) .NE. 3) GO TO 370                                     
         TEMP1 = LSTGST                                                 
C                                                                       
C     ***  PREPARE FOR GRADIENT TESTS  ***                              
C     ***  SET  TEMP1 = HESSIAN * STEP + G(X0)                          
C     ***             = DIAG(D) * (H * STEP + G(X0))                    
C                                                                       
         K = TEMP1                                                      
         STEP0 = STEP1 - 1                                              
         IPI = IV(PERM)                                                 
         DO 350 I = 1, N                                                
              J = IV(IPI)                                               
              IPI = IPI + 1                                             
              STEP1 = STEP0 + J                                         
              V(K) = D(J) * V(STEP1)                                    
              K = K + 1                                                 
 350          CONTINUE                                                  
C        USE X0 VECTOR AS TEMPORARY.                                    
         CALL  S7LVM(N, V(X01), H, V(TEMP1))                            
         TEMP0 = TEMP1 - 1                                              
         IPI = IV(PERM)                                                 
         DO 360 I = 1, N                                                
              J = IV(IPI)                                               
              IPI = IPI + 1                                             
              TEMP1 = TEMP0 + J                                         
              V(TEMP1) = D(J) * V(X01) + G(J)                           
              X01 = X01 + 1                                             
 360          CONTINUE                                                  
C                                                                       
C  ***  COMPUTE GRADIENT AND HESSIAN  ***                               
C                                                                       
 370  IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(TOOBIG) = 0                                                    
      IV(1) = 2                                                         
      GO TO 450                                                         
C                                                                       
 380  IV(1) = 2                                                         
      IF (IV(IRC) .NE. 3) GO TO 140                                     
C                                                                       
C  ***  SET V(RADFAC) BY GRADIENT TESTS  ***                            
C                                                                       
      STEP1 = IV(STEP)                                                  
C     *** TEMP1 = STLSTG ***                                            
      TEMP1 = STEP1 + 2*N                                               
C                                                                       
C     ***  SET  TEMP1 = DIAG(D)**-1 * (HESSIAN*STEP + (G(X0)-G(X)))  ***
C                                                                       
      K = TEMP1                                                         
      DO 390 I = 1, N                                                   
         V(K) = (V(K) - G(I)) / D(I)                                    
         K = K + 1                                                      
 390     CONTINUE                                                       
C                                                                       
C     ***  DO GRADIENT TESTS  ***                                       
C                                                                       
      IF ( V2NRM(N, V(TEMP1)) .LE. V(DGNORM) * V(TUNER4)) GO TO 400     
           IF ( D7TPR(N, G, V(STEP1))                                   
     1               .GE. V(GTSTEP) * V(TUNER5))  GO TO 140             
 400            V(RADFAC) = V(INCFAC)                                   
                GO TO 140                                               
C                                                                       
C. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
C                                                                       
C  ***  BAD PARAMETERS TO ASSESS  ***                                   
C                                                                       
 410  IV(1) = 64                                                        
      GO TO 440                                                         
C                                                                       
C  ***  INCONSISTENT B  ***                                             
C                                                                       
 420  IV(1) = 82                                                        
      GO TO 440                                                         
C                                                                       
C  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  *** 
C                                                                       
 430  IV(1) = IV(CNVCOD)                                                
      IV(CNVCOD) = 0                                                    
 440  CALL ITSUM(D, G, IV, LIV, LV, N, V, X)                            
      GO TO 999                                                         
C                                                                       
C  ***  PROJECT X INTO FEASIBLE REGION (PRIOR TO COMPUTING F OR G)  *** 
C                                                                       
 450  DO 460 I = 1, N                                                   
         IF (X(I) .LT. B(1,I)) X(I) = B(1,I)                            
         IF (X(I) .GT. B(2,I)) X(I) = B(2,I)                            
 460     CONTINUE                                                       
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF  RMNHB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   RNSG(A, ALF, C, DA, IN, IV, L, L1, LA, LIV, LV,      
     1                  N, NDA, P, V, Y)                                
C                                                                       
C  ***  ITERATION DRIVER FOR SEPARABLE NONLINEAR LEAST SQUARES.         
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER L, L1, LA, LIV, LV, N, NDA, P                             
      INTEGER IN(2,NDA), IV(LIV)                                        
C     DIMENSION UIPARM(*)                                               
      REAL A(LA,L1), ALF(P), C(L), DA(LA,NDA), V(LV), Y(N)              
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),   RNSG ATTEMPTS TO COMPUTE A LEAST SQUARES FIT           
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )).                       
C                       I=1    I             I                          
C                                                                       
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C      A (IN)  MATRIX PHI(ALF,T) OF THE MODEL.                          
C    ALF (I/O) NONLINEAR PARAMETERS.                                    
C                 INPUT = INITIAL GUESS,                                
C                 OUTPUT = BEST ESTIMATE FOUND.                         
C      C (OUT) LINEAR PARAMETERS (ESTIMATED).                           
C     DA (IN)  DERIVATIVES OF COLUMNS OF A WITH RESPECT TO COMPONENTS   
C                 OF ALF, AS SPECIFIED BY THE IN ARRAY...               
C     IN (IN)  WHEN   RNSG IS CALLED WITH IV(1) = 2 OR -2, THEN FOR     
C                 I = 1(1)NDA, COLUMN I OF DA IS THE PARTIAL            
C                 DERIVATIVE WITH RESPECT TO ALF(IN(1,I)) OF COLUMN     
C                 IN(2,I) OF A, UNLESS IV(1,I) IS NOT POSITIVE (IN      
C                 WHICH CASE COLUMN I OF DA IS IGNORED.  IV(1) = -2     
C                 MEANS THERE ARE MORE COLUMNS OF DA TO COME AND        
C                   RNSG SHOULD RETURN FOR THEM.                        
C     IV (I/O) INTEGER PARAMETER AND SCRATCH VECTOR.    RNSG RETURNS    
C                 WITH IV(1) = 1 WHEN IT WANTS A TO BE EVALUATED AT     
C                 ALF AND WITH IV(1) = 2 WHEN IT WANTS DA TO BE         
C                 EVALUATED AT ALF.  WHEN CALLED WITH IV(1) = -2        
C                 (AFTER A RETURN WITH IV(1) = 2),   RNSG RETURNS       
C                 WITH IV(1) = -2 TO GET MORE COLUMNS OF DA.            
C      L (IN)  NUMBER OF LINEAR PARAMETERS TO BE ESTIMATED.             
C     L1 (IN)  L+1 IF PHI(L+1) IS IN THE MODEL, L IF NOT.               
C     LA (IN)  LEAD DIMENSION OF A.  MUST BE AT LEAST N.                
C    LIV (IN)  LENGTH OF IV.  MUST BE AT LEAST 110 + L + P.             
C     LV (IN)  LENGTH OF V.  MUST BE AT LEAST                           
C                 105 + 2*N + JLEN + L*(L+3)/2 + P*(2*P + 17),          
C                 WHERE  JLEN = (L+P)*(N+L+P+1),  UNLESS NEITHER A      
C                 COVARIANCE MATRIX NOR REGRESSION DIAGNOSTICS ARE      
C                 REQUESTED, IN WHICH CASE  JLEN = N*P.                 
C      N (IN)  NUMBER OF OBSERVATIONS.                                  
C    NDA (IN)  NUMBER OF COLUMNS IN DA AND IN.                          
C      P (IN)  NUMBER OF NONLINEAR PARAMETERS TO BE ESTIMATED.          
C      V (I/O) FLOATING-POINT PARAMETER AND SCRATCH VECTOR.             
C      Y (IN)  RIGHT-HAND SIDE VECTOR.                                  
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      REAL  D7TPR,  L7SVX,  L7SVN,  R7MDC                               
      EXTERNAL  C7VFN, IVSET,  D7TPR, ITSUM,  L7ITV, L7SRT,  L7SVX,     
     1          L7SVN,  N2CVP,  N2LRD,  N2RDP,   RN2G,  Q7APL, Q7RAD,   
     2         Q7RFH,  R7MDC,  S7CPR, V2AXY, V7CPY, V7PRM,  V7SCL,      
     3          V7SCP                                                   
C                                                                       
C  C7VFN... FINISHES COVARIANCE COMPUTATION.                            
C IVSET.... SUPPLIES DEFAULT PARAMETER VALUES.                          
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C ITSUM.... PRINTS ITERATION SUMMARY, INITIAL AND FINAL ALF.            
C  L7ITV... APPLIES INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.  
C L7SRT.... COMPUTES (PARTIAL) CHOLESKY FACTORIZATION.                  
C  L7SVX... ESTIMATES LARGEST SING. VALUE OF LOWER TRIANG. MATRIX.      
C  L7SVN... ESTIMATES SMALLEST SING. VALUE OF LOWER TRIANG. MATRIX.     
C  N2CVP... PRINTS COVARIANCE MATRIX.                                   
C  N2LRD... COMPUTES COVARIANCE AND REGRESSION DIAGNOSTICS.             
C  N2RDP... PRINTS REGRESSION DIAGNOSTICS.                              
C   RN2G... UNDERLYING NONLINEAR LEAST-SQUARES SOLVER.                  
C  Q7APL... APPLIES HOUSEHOLDER TRANSFORMS STORED BY Q7RFH.             
C Q7RFH.... COMPUTES QR FACT. VIA HOUSEHOLDER TRANSFORMS WITH PIVOTING. 
C Q7RAD.... QR FACT., NO PIVOTING.                                      
C  R7MDC... RETURNS MACHINE-DEP. CONSTANTS.                             
C  S7CPR... PRINTS LINEAR PARAMETERS AT SOLUTION.                       
C V2AXY.... ADDS MULTIPLE OF ONE VECTOR TO ANOTHER.                     
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C V7PRM.... PERMUTES A VECTOR.                                          
C  V7SCL... SCALES AND COPIES ONE VECTOR TO ANOTHER.                    
C  V7SCP... SETS ALL COMPONENTS OF A VECTOR TO A SCALAR.                
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      LOGICAL NOCOV                                                     
      INTEGER AR1, CSAVE1, D1, DR1, DR1L, DRI, DRI1, FDH0, HSAVE, I, I1,
     1        IPIV1, IER, IV1, J1, JLEN, K, LH, LI, LL1O2, MD, N1,      
     2        NML, NRAN, PP, PP1, R1, R1L, RD1, TEMP1                   
      REAL SINGTL, T                                                    
      REAL MACHEP, NEGONE, SNGFAC, ZERO                                 
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AR, CNVCOD, COVMAT, COVREQ, CSAVE, CVRQSV, D, FDH, H,     
     1        IERS, IPIVS, IV1SAV, IVNEED, J, LMAT, MODE, NEXTIV, NEXTV,
     2        NFCALL, NFCOV, NFGCAL, NGCALL, NGCOV, PERM, R, RCOND,     
     3        RDREQ, RDRQSV, REGD, REGD0, RESTOR, TOOBIG, VNEED         
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AR/110/, CNVCOD/55/, COVMAT/26/, COVREQ/15/, CSAVE/105/,     
C    1     CVRQSV/106/, D/27/, FDH/74/, H/56/, IERS/108/, IPIVS/109/,   
C    2     IV1SAV/104/, IVNEED/3/, J/70/, LMAT/42/, MODE/35/,           
C    3     NEXTIV/46/, NEXTV/47/, NFCALL/6/, NFCOV/52/, NFGCAL/7/,      
C    4     NGCALL/30/, NGCOV/53/, PERM/58/, R/61/, RCOND/53/, RDREQ/57/,
C    5     RDRQSV/107/, REGD/67/, REGD0/82/, RESTOR/9/, TOOBIG/2/,      
C    6     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (AR=110, CNVCOD=55, COVMAT=26, COVREQ=15, CSAVE=105,    
     1           CVRQSV=106, D=27, FDH=74, H=56, IERS=108, IPIVS=109,   
     2           IV1SAV=104, IVNEED=3, J=70, LMAT=42, MODE=35,          
     3           NEXTIV=46, NEXTV=47, NFCALL=6, NFCOV=52, NFGCAL=7,     
     4           NGCALL=30, NGCOV=53, PERM=58, R=61, RCOND=53, RDREQ=57,
     5           RDRQSV=107, REGD=67, REGD0=82, RESTOR=9, TOOBIG=2,     
     6           VNEED=4)                                               
C/                                                                      
      DATA MACHEP/-1.E+0/, NEGONE/-1.E+0/, SNGFAC/1.E+2/, ZERO/0.E+0/   
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      N1 = 1                                                            
      NML = N                                                           
      IV1 = IV(1)                                                       
      IF (IV1 .LE. 2) GO TO 20                                          
C                                                                       
C  ***  CHECK INPUT INTEGERS  ***                                       
C                                                                       
      IF (P .LE. 0) GO TO 370                                           
      IF (L .LT. 0) GO TO 370                                           
      IF (N .LE. L) GO TO 370                                           
      IF (LA .LT. N) GO TO 370                                          
      IF (IV1 .LT. 12) GO TO 20                                         
      IF (IV1 .EQ. 14) GO TO 20                                         
      IF (IV1 .EQ. 12) IV(1) = 13                                       
C                                                                       
C  ***  FRESH START -- COMPUTE STORAGE REQUIREMENTS  ***                
C                                                                       
      IF (IV(1) .GT. 16) GO TO 370                                      
      LL1O2 = L*(L+1)/2                                                 
      JLEN = N*P                                                        
      I = L + P                                                         
      IF (IV(RDREQ) .GT. 0 .AND. IV(COVREQ) .NE. 0) JLEN = I*(N + I + 1)
      IF (IV(1) .NE. 13) GO TO 10                                       
         IV(IVNEED) = IV(IVNEED) + L                                    
         IV(VNEED) = IV(VNEED) + P + 2*N + JLEN + LL1O2 + L             
 10   IF (IV(PERM) .LE. AR) IV(PERM) = AR + 1                           
      CALL   RN2G(V, V, IV, LIV, LV, N, N, N1, NML, P, V, V, V, ALF)    
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IPIVS) = IV(NEXTIV)                                            
      IV(NEXTIV) = IV(NEXTIV) + L                                       
      IV(D) = IV(NEXTV)                                                 
      IV(REGD0) = IV(D) + P                                             
      IV(AR) = IV(REGD0) + N                                            
      IV(CSAVE) = IV(AR) + LL1O2                                        
      IV(J) = IV(CSAVE) + L                                             
      IV(R) = IV(J) + JLEN                                              
      IV(NEXTV) = IV(R) + N                                             
      IV(IERS) = 0                                                      
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
C  ***  SET POINTERS INTO IV AND V  ***                                 
C                                                                       
 20   AR1 = IV(AR)                                                      
      D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      DR1L = DR1 + L                                                    
      R1 = IV(R)                                                        
      R1L = R1 + L                                                      
      RD1 = IV(REGD0)                                                   
      CSAVE1 = IV(CSAVE)                                                
      NML = N - L                                                       
      IF (IV1 .LE. 2) GO TO 50                                          
C                                                                       
C  ***  IF F.D. HESSIAN WILL BE NEEDED (FOR COVARIANCE OR REG.          
C  ***  DIAGNOSTICS), HAVE   RN2G COMPUTE ONLY THE PART CORRESP.        
C  ***  TO ALF WITH C FIXED...                                          
C                                                                       
      IF (L .LE. 0) GO TO 30                                            
      IV(CVRQSV) = IV(COVREQ)                                           
      IF (IABS(IV(COVREQ)) .GE. 3) IV(COVREQ) = 0                       
      IV(RDRQSV) = IV(RDREQ)                                            
      IF (IV(RDREQ) .GT. 0) IV(RDREQ) = -1                              
C                                                                       
 30   CALL   RN2G(V(D1), V(DR1L), IV, LIV, LV, NML, N, N1, NML, P,      
     1            V(R1L), V(RD1), V, ALF)                               
      IF (IABS(IV(RESTOR)-2) .EQ. 1 .AND. L .GT. 0)                     
     1        CALL V7CPY(L, C, V(CSAVE1))                               
      IV1 = IV(1)                                                       
      IF (IV1-2) 40, 150, 230                                           
C                                                                       
C  ***  NEW FUNCTION VALUE (RESIDUAL) NEEDED  ***                       
C                                                                       
 40   IV(IV1SAV) = IV(1)                                                
      IV(1) = IABS(IV1)                                                 
      IF (IV(RESTOR) .EQ. 2 .AND. L .GT. 0) CALL V7CPY(L, V(CSAVE1), C) 
      GO TO 999                                                         
C                                                                       
C  ***  COMPUTE NEW RESIDUAL OR GRADIENT  ***                           
C                                                                       
 50   IV(1) = IV(IV1SAV)                                                
      MD = IV(MODE)                                                     
      IF (MD .LE. 0) GO TO 60                                           
         NML = N                                                        
         DR1L = DR1                                                     
         R1L = R1                                                       
 60   IF (IV(TOOBIG) .NE. 0) GO TO 30                                   
      IF (IABS(IV1) .EQ. 2) GO TO 170                                   
C                                                                       
C  ***  COMPUTE NEW RESIDUAL  ***                                       
C                                                                       
      IF (L1 .LE. L) CALL V7CPY(N, V(R1), Y)                            
      IF (L1 .GT. L) CALL V2AXY(N, V(R1), NEGONE, A(1,L1), Y)           
      IF (MD .GT. 0) GO TO 120                                          
      IER = 0                                                           
      IF (L .LE. 0) GO TO 110                                           
      LL1O2 = L * (L + 1) / 2                                           
      IPIV1 = IV(IPIVS)                                                 
      CALL Q7RFH(IER, IV(IPIV1), N, LA, 0, L, A, V(AR1), LL1O2, C)      
C                                                                       
C *** DETERMINE NUMERICAL RANK OF A ***                                 
C                                                                       
      IF (MACHEP .LE. ZERO) MACHEP =  R7MDC(3)                          
      SINGTL = SNGFAC * FLOAT(MAX0(L,N)) * MACHEP                       
      K = L                                                             
      IF (IER .NE. 0) K = IER - 1                                       
 70   IF (K .LE. 0) GO TO 90                                            
         T =  L7SVX(K, V(AR1), C, C)                                    
         IF (T .GT. ZERO) T =  L7SVN(K, V(AR1), C, C) / T               
         IF (T .GT. SINGTL) GO TO 80                                    
         K = K - 1                                                      
         GO TO 70                                                       
C                                                                       
C *** RECORD RANK IN IV(IERS)... IV(IERS) = 0 MEANS FULL RANK,          
C *** IV(IERS) .GT. 0 MEANS RANK IV(IERS) - 1.                          
C                                                                       
 80   IF (K .GE. L) GO TO 100                                           
 90      IER = K + 1                                                    
         CALL  V7SCP(L-K, C(K+1), ZERO)                                 
 100  IV(IERS) = IER                                                    
      IF (K .LE. 0) GO TO 110                                           
C                                                                       
C *** APPLY HOUSEHOLDER TRANSFORMATONS TO RESIDUALS...                  
C                                                                       
      CALL  Q7APL(LA, N, K, A, V(R1), IER)                              
C                                                                       
C *** COMPUTING C NOW MAY SAVE A FUNCTION EVALUATION AT                 
C *** THE LAST ITERATION.                                               
C                                                                       
      CALL  L7ITV(K, C, V(AR1), V(R1))                                  
      CALL V7PRM(L, IV(IPIV1), C)                                       
C                                                                       
 110  IF(IV(1) .LT. 2) GO TO 220                                        
      GO TO 999                                                         
C                                                                       
C                                                                       
C  ***  RESIDUAL COMPUTATION FOR F.D. HESSIAN  ***                      
C                                                                       
 120  IF (L .LE. 0) GO TO 140                                           
      DO 130 I = 1, L                                                   
 130     CALL V2AXY(N, V(R1), -C(I), A(1,I), V(R1))                     
 140  IF (IV(1) .GT. 0) GO TO 30                                        
         IV(1) = 2                                                      
         GO TO 160                                                      
C                                                                       
C  ***  NEW GRADIENT (JACOBIAN) NEEDED  ***                             
C                                                                       
 150  IV(IV1SAV) = IV1                                                  
      IF (IV(NFGCAL) .NE. IV(NFCALL)) IV(1) = 1                         
 160  CALL  V7SCP(N*P, V(DR1), ZERO)                                    
      GO TO 999                                                         
C                                                                       
C  ***  COMPUTE NEW JACOBIAN  ***                                       
C                                                                       
 170  NOCOV = MD .LE. P .OR. IABS(IV(COVREQ)) .GE. 3                    
      FDH0 = DR1 + N*(P+L)                                              
      IF (NDA .LE. 0) GO TO 370                                         
      DO 180 I = 1, NDA                                                 
         I1 = IN(1,I) - 1                                               
         IF (I1 .LT. 0) GO TO 180                                       
         J1 = IN(2,I)                                                   
         K = DR1 + I1*N                                                 
         T = NEGONE                                                     
         IF (J1 .LE. L) T = -C(J1)                                      
         CALL V2AXY(N, V(K), T, DA(1,I), V(K))                          
         IF (NOCOV) GO TO 180                                           
         IF (J1 .GT. L) GO TO 180                                       
C        ***  ADD IN (L,P) PORTION OF SECOND-ORDER PART OF HESSIAN      
C        ***  FOR COVARIANCE OR REG. DIAG. COMPUTATIONS...              
         J1 = J1 + P                                                    
         K = FDH0 + J1*(J1-1)/2 + I1                                    
         V(K) = V(K) -  D7TPR(N, V(R1), DA(1,I))                        
 180     CONTINUE                                                       
      IF (IV1 .EQ. 2) GO TO 190                                         
         IV(1) = IV1                                                    
         GO TO 999                                                      
 190  IF (L .LE. 0) GO TO 30                                            
      IF (MD .GT. P) GO TO 240                                          
      IF (MD .GT. 0) GO TO 30                                           
      K = DR1                                                           
      IER = IV(IERS)                                                    
      NRAN = L                                                          
      IF (IER .GT. 0) NRAN = IER - 1                                    
      IF (NRAN .LE. 0) GO TO 210                                        
      DO 200 I = 1, P                                                   
         CALL  Q7APL(LA, N, NRAN, A, V(K), IER)                         
         K = K + N                                                      
 200     CONTINUE                                                       
 210  CALL V7CPY(L, V(CSAVE1), C)                                       
 220  IF (IER .EQ. 0) GO TO 30                                          
C                                                                       
C     *** ADJUST SUBSCRIPTS DESCRIBING R AND DR...                      
C                                                                       
         NRAN = IER - 1                                                 
         DR1L = DR1 + NRAN                                              
         NML = N - NRAN                                                 
         R1L = R1 + NRAN                                                
         GO TO 30                                                       
C                                                                       
C  ***  CONVERGENCE OR LIMIT REACHED  ***                               
C                                                                       
 230  IF (L .LE. 0) GO TO 350                                           
      IV(COVREQ) = IV(CVRQSV)                                           
      IV(RDREQ) = IV(RDRQSV)                                            
      IF (IV(1) .GT. 6) GO TO 360                                       
      IF (MOD(IV(RDREQ),4) .EQ. 0) GO TO 360                            
      IF (IV(FDH) .LE. 0 .AND. IABS(IV(COVREQ)) .LT. 3) GO TO 360       
      IF (IV(REGD) .GT. 0) GO TO 360                                    
      IF (IV(COVMAT) .GT. 0) GO TO 360                                  
C                                                                       
C  *** PREPARE TO FINISH COMPUTING COVARIANCE MATRIX AND REG. DIAG. *** 
C                                                                       
      PP = L + P                                                        
      I = 0                                                             
      IF (MOD(IV(RDREQ),4) .GE. 2) I = 1                                
      IF (MOD(IV(RDREQ),2) .EQ. 1 .AND. IABS(IV(COVREQ)) .EQ. 1) I = I+2
      IV(MODE) = PP + I                                                 
      I = DR1 + N*PP                                                    
      K = P * (P + 1) / 2                                               
      I1 = IV(LMAT)                                                     
      CALL V7CPY(K, V(I), V(I1))                                        
      I = I + K                                                         
      CALL  V7SCP(PP*(PP+1)/2 - K, V(I), ZERO)                          
      IV(NFCOV) = IV(NFCOV) + 1                                         
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(NFGCAL) = IV(NFCALL)                                           
      IV(CNVCOD) = IV(1)                                                
      IV(IV1SAV) = -1                                                   
      IV(1) = 1                                                         
      IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(NGCOV) = IV(NGCOV) + 1                                         
      GO TO 999                                                         
C                                                                       
C  ***  FINISH COVARIANCE COMPUTATION  ***                              
C                                                                       
 240  I = DR1 + N*P                                                     
      DO 250 I1 = 1, L                                                  
         CALL  V7SCL(N, V(I), NEGONE, A(1,I1))                          
         I = I + N                                                      
 250     CONTINUE                                                       
      PP = L + P                                                        
      HSAVE = IV(H)                                                     
      K = DR1 + N*PP                                                    
      LH = PP * (PP + 1) / 2                                            
      IF (IABS(IV(COVREQ)) .LT. 3) GO TO 270                            
      I = IV(MODE) - 4                                                  
      IF (I .GE. PP) GO TO 260                                          
      CALL  V7SCP(LH, V(K), ZERO)                                       
      CALL Q7RAD(N, N, PP, V, .FALSE., V(K), V(DR1), V)                 
      IV(MODE) = I + 8                                                  
      IV(1) = 2                                                         
      IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(NGCOV) = IV(NGCOV) + 1                                         
      GO TO 160                                                         
C                                                                       
 260  IV(MODE) = I                                                      
      GO TO 300                                                         
C                                                                       
 270  PP1 = P + 1                                                       
      DRI = DR1 + N*P                                                   
      LI = K + P*PP1/2                                                  
      DO 290 I = PP1, PP                                                
         DRI1 = DR1                                                     
         DO 280 I1 = 1, I                                               
            V(LI) = V(LI) +  D7TPR(N, V(DRI), V(DRI1))                  
            LI = LI + 1                                                 
            DRI1 = DRI1 + N                                             
 280        CONTINUE                                                    
         DRI = DRI + N                                                  
 290     CONTINUE                                                       
      CALL L7SRT(PP1, PP, V(K), V(K), I)                                
      IF (I .NE. 0) GO TO 310                                           
 300  TEMP1 = K + LH                                                    
      T =  L7SVN(PP, V(K), V(TEMP1), V(TEMP1))                          
      IF (T .LE. ZERO) GO TO 310                                        
      T = T /  L7SVX(PP, V(K), V(TEMP1), V(TEMP1))                      
      V(RCOND) = T                                                      
      IF (T .GT.  R7MDC(4)) GO TO 320                                   
 310     IV(REGD) = -1                                                  
         IV(COVMAT) = -1                                                
         IV(FDH) = -1                                                   
         GO TO 340                                                      
 320  IV(H) = TEMP1                                                     
      IV(FDH) = IABS(HSAVE)                                             
      IF (IV(MODE) - PP .LT. 2) GO TO 330                               
         I = IV(H)                                                      
         CALL  V7SCP(LH, V(I), ZERO)                                    
 330  CALL  N2LRD(V(DR1), IV, V(K), LH, LIV, LV, N, N, PP, V(R1),       
     1            V(RD1), V)                                            
 340  CALL  C7VFN(IV, V(K), LH, LIV, LV, N, PP, V)                      
      IV(H) = HSAVE                                                     
C                                                                       
 350  IF (IV(REGD) .EQ. 1) IV(REGD) = RD1                               
 360  IF (IV(1) .LE. 11) CALL  S7CPR(C, IV, L, LIV)                     
      IF (IV(1) .GT. 6) GO TO 999                                       
         CALL  N2CVP(IV, LIV, LV, P+L, V)                               
         CALL  N2RDP(IV, LIV, LV, N, V(RD1), V)                         
         GO TO 999                                                      
C                                                                       
 370  IV(1) = 66                                                        
      CALL ITSUM(V, V, IV, LIV, LV, P, V, ALF)                          
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF   RNSG FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   RN2G(D, DR, IV, LIV, LV, N, ND, N1, N2, P, R,        
     1                  RD, V, X)                                       
C                                                                       
C *** REVISED ITERATION DRIVER FOR NL2SOL (VERSION 2.3) ***             
C                                                                       
      INTEGER LIV, LV, N, ND, N1, N2, P                                 
      INTEGER IV(LIV)                                                   
      REAL D(P), DR(ND,P), R(ND), RD(ND), V(LV), X(P)                   
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C D........ SCALE VECTOR.                                               
C DR....... DERIVATIVES OF R AT X.                                      
C IV....... INTEGER VALUES ARRAY.                                       
C LIV...... LENGTH OF IV... LIV MUST BE AT LEAST P + 82.                
C LV....... LENGTH OF V...  LV  MUST BE AT LEAST 105 + P*(2*P+16).      
C N........ TOTAL NUMBER OF RESIDUALS.                                  
C ND....... MAX. NO. OF RESIDUALS PASSED ON ONE CALL.                   
C N1....... LOWEST  ROW INDEX FOR RESIDUALS SUPPLIED THIS TIME.         
C N2....... HIGHEST ROW INDEX FOR RESIDUALS SUPPLIED THIS TIME.         
C P........ NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.     
C R........ RESIDUALS.                                                  
C RD....... RD(I) = SQRT(G(I)**T * H(I)**-1 * G(I)) ON OUTPUT WHEN      
C        IV(RDREQ) IS NONZERO.    RN2G SETS IV(REGD) = 1 IF RD          
C        IS SUCCESSFULLY COMPUTED, TO 0 IF NO ATTEMPT WAS MADE          
C        TO COMPUTE IT, AND TO -1 IF H (THE FINITE-DIFFERENCE HESSIAN)  
C        WAS INDEFINITE.  IF ND .GE. N, THEN RD IS ALSO USED AS         
C        TEMPORARY STORAGE.                                             
C V........ FLOATING-POINT VALUES ARRAY.                                
C X........ PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,    
C             OUTPUT = BEST VALUE FOUND).                               
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C  NOTE... NL2SOL AND NL2ITR (MENTIONED BELOW) ARE DESCRIBED IN         
C  ACM TRANS. MATH. SOFTWARE, VOL. 7, PP. 369-383 (AN ADAPTIVE          
C  NONLINEAR LEAST-SQUARES ALGORITHM, BY J.E. DENNIS, D.M. GAY,         
C  AND R.E. WELSCH).                                                    
C                                                                       
C     THIS ROUTINE CARRIES OUT ITERATIONS FOR SOLVING NONLINEAR         
C  LEAST SQUARES PROBLEMS.  WHEN ND = N, IT IS SIMILAR TO NL2ITR        
C  (WITH J = DR), EXCEPT THAT R(X) AND DR(X) NEED NOT BE INITIALIZED    
C  WHEN   RN2G IS CALLED WITH IV(1) = 0 OR 12.    RN2G ALSO ALLOWS      
C  R AND DR TO BE SUPPLIED ROW-WISE -- JUST SET ND = 1 AND CALL         
C    RN2G ONCE FOR EACH ROW WHEN PROVIDING RESIDUALS AND JACOBIANS.     
C     ANOTHER NEW FEATURE IS THAT CALLING   RN2G WITH IV(1) = 13        
C  CAUSES STORAGE ALLOCATION ONLY TO BE PERFORMED -- ON RETURN, SUCH    
C  COMPONENTS AS IV(G) (THE FIRST SUBSCRIPT IN G OF THE GRADIENT)       
C  AND IV(S) (THE FIRST SUBSCRIPT IN V OF THE S LOWER TRIANGLE OF       
C  THE S MATRIX) WILL HAVE BEEN SET (UNLESS LIV OR LV IS TOO SMALL),    
C  AND IV(1) WILL HAVE BEEN SET TO 14. CALLING   RN2G WITH IV(1) = 14   
C  CAUSES EXECUTION OF THE ALGORITHM TO BEGIN UNDER THE ASSUMPTION      
C  THAT STORAGE HAS BEEN ALLOCATED.                                     
C                                                                       
C ***  SUPPLYING R AND DR  ***                                          
C                                                                       
C       RN2G USES IV AND V IN THE SAME WAY AS NL2SOL, WITH A SMALL      
C  NUMBER OF OBVIOUS CHANGES.  ONE DIFFERENCE BETWEEN   RN2G AND        
C  NL2ITR IS THAT INITIAL FUNCTION AND GRADIENT INFORMATION NEED NOT    
C  BE SUPPLIED IN THE VERY FIRST CALL ON   RN2G, THE ONE WITH           
C  IV(1) = 0 OR 12.  ANOTHER DIFFERENCE IS THAT   RN2G RETURNS WITH     
C  IV(1) = -2 WHEN IT WANTS ANOTHER LOOK AT THE OLD JACOBIAN MATRIX     
C  AND THE CURRENT RESIDUAL -- THE ONE CORRESPONDING TO X AND           
C  IV(NFGCAL).  IT THEN RETURNS WITH IV(1) = -3 WHEN IT WANTS TO SEE    
C  BOTH THE NEW RESIDUAL AND THE NEW JACOBIAN MATRIX AT ONCE.  NOTE     
C  THAT IV(NFGCAL) = IV(7) CONTAINS THE VALUE THAT IV(NFCALL) = IV(6)   
C  HAD WHEN THE CURRENT RESIDUAL WAS EVALUATED.  ALSO NOTE THAT THE     
C  VALUE OF X CORRESPONDING TO THE OLD JACOBIAN MATRIX IS STORED IN     
C  V, STARTING AT V(IV(X0)) = V(IV(43)).                                
C     ANOTHER NEW RETURN...   RN2G IV(1) = -1 WHEN IT WANTS BOTH THE    
C  RESIDUAL AND THE JACOBIAN TO BE EVALUATED AT X.                      
C     A NEW RESIDUAL VECTOR MUST BE SUPPLIED WHEN   RN2G RETURNS WITH   
C  IV(1) = 1 OR -1.  THIS TAKES THE FORM OF VALUES OF R(I,X) PASSED     
C  IN R(I-N1+1), I = N1(1)N2.  YOU MAY PASS ALL THESE VALUES AT ONCE    
C  (I.E., N1 = 1 AND N2 = N) OR IN PIECES BY MAKING SEVERAL CALLS ON    
C    RN2G.  EACH TIME   RN2G RETURNS WITH IV(1) = 1, N1 WILL HAVE       
C  BEEN SET TO THE INDEX OF THE NEXT RESIDUAL THAT   RN2G EXPECTS TO    
C  SEE, AND N2 WILL BE SET TO THE INDEX OF THE HIGHEST RESIDUAL THAT    
C  COULD BE GIVEN ON THE NEXT CALL, I.E., N2 = N1 + ND - 1.  (THUS      
C  WHEN   RN2G FIRST RETURNS WITH IV(1) = 1 FOR A NEW X, IT WILL        
C  HAVE SET N1 TO 1 AND N2 TO MIN(ND,N).)  THE CALLER MAY PROVIDE       
C  FEWER THAN N2-N1+1 RESIDUALS ON THE NEXT CALL BY SETTING N2 TO       
C  A SMALLER VALUE.    RN2G ASSUMES IT HAS SEEN ALL THE RESIDUALS       
C  FOR THE CURRENT X WHEN IT IS CALLED WITH N2 .GE. N.                  
C    EXAMPLE... SUPPOSE N = 80 AND THAT R IS TO BE PASSED IN 8          
C  BLOCKS OF SIZE 10.  THE FOLLOWING CODE WOULD DO THE JOB.             
C                                                                       
C      N = 80                                                           
C      ND = 10                                                          
C      ...                                                              
C      DO 10 K = 1, 8                                                   
C           ***  COMPUTE R(I,X) FOR I = 10*K-9 TO 10*K  ***             
C           ***  AND STORE THEM IN R(1),...,R(10)  ***                  
C           CALL   RN2G(..., R, ...)                                    
C   10      CONTINUE                                                    
C                                                                       
C     THE SITUATION IS SIMILAR WHEN GRADIENT INFORMATION IS             
C  REQUIRED, I.E., WHEN   RN2G RETURNS WITH IV(1) = 2, -1, OR -2.       
C  NOTE THAT   RN2G OVERWRITES R, BUT THAT IN THE SPECIAL CASE OF       
C  N1 = 1 AND N2 = N ON PREVIOUS CALLS,   RN2G NEVER RETURNS WITH       
C  IV(1) = -2.  IT SHOULD BE CLEAR THAT THE PARTIAL DERIVATIVE OF       
C  R(I,X) WITH RESPECT TO X(L) IS TO BE STORED IN DR(I-N1+1,L),         
C  L = 1(1)P, I = N1(1)N2.  IT IS ESSENTIAL THAT R(I) AND DR(I,L)       
C  ALL CORRESPOND TO THE SAME RESIDUALS WHEN IV(1) = -1 OR -2.          
C                                                                       
C  ***  COVARIANCE MATRIX  ***                                          
C                                                                       
C     IV(RDREQ) = IV(57) TELLS WHETHER TO COMPUTE A COVARIANCE          
C  MATRIX AND/OR REGRESSION DIAGNOSTICS... 0 MEANS NEITHER,             
C  1 MEANS COVARIANCE MATRIX ONLY, 2 MEANS REG. DIAGNOSTICS ONLY,       
C  3 MEANS BOTH.  AS WITH NL2SOL, IV(COVREQ) = IV(15) TELLS WHAT        
C  HESSIAN APPROXIMATION TO USE IN THIS COMPUTING.                      
C                                                                       
C  ***  REGRESSION DIAGNOSTICS  ***                                     
C                                                                       
C     SEE THE COMMENTS IN SUBROUTINE    N2G.                            
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C                                                                       
C+++++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++
C                                                                       
C  ***  INTRINSIC FUNCTIONS  ***                                        
C/+                                                                     
      INTEGER IABS, MOD                                                 
C/                                                                      
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      REAL  D7TPR,  V2NRM                                               
      EXTERNAL  C7VFN, IVSET,  D7TPR, D7UPD, G7LIT, ITSUM, L7VML,       
     1          N2CVP,  N2LRD,  Q7APL, Q7RAD, V7CPY,  V7SCP,  V2NRM     
C                                                                       
C  C7VFN... FINISHES COVARIANCE COMPUTATION.                            
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C  D7TPR... COMPUTES INNER PRODUCT OF TWO VECTORS.                      
C D7UPD...  UPDATES SCALE VECTOR D.                                     
C G7LIT.... PERFORMS BASIC MINIMIZATION ALGORITHM.                      
C ITSUM.... PRINTS ITERATION SUMMARY, INFO ABOUT INITIAL AND FINAL X.   
C L7VML.... COMPUTES L * V, V = VECTOR, L = LOWER TRIANGULAR MATRIX.    
C  N2CVP... PRINTS COVARIANCE MATRIX.                                   
C  N2LRD... COMPUTES REGRESSION DIAGNOSTICS.                            
C  Q7APL... APPLIES QR TRANSFORMATIONS STORED BY Q7RAD.                 
C Q7RAD.... ADDS A NEW BLOCK OF ROWS TO QR DECOMPOSITION.               
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER G1, GI, I, IV1, IVMODE, JTOL1, K, L, LH, NN, QTR1,        
     1        RMAT1, YI, Y1                                             
      REAL T                                                            
C                                                                       
      REAL HALF, ZERO                                                   
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, COVMAT, COVREQ, DINIT, DTYPE, DTINIT, D0INIT, F,  
     1        FDH, G, H, IPIVOT, IVNEED, JCN, JTOL, LMAT, MODE,         
     2        NEXTIV, NEXTV, NF0, NF00, NF1, NFCALL, NFCOV, NFGCAL,     
     3        NGCALL, NGCOV, QTR, RDREQ, REGD, RESTOR, RLIMIT, RMAT,    
     4        TOOBIG, VNEED, Y                                          
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, COVMAT/26/, COVREQ/15/, DTYPE/16/, FDH/74/,      
C    1     G/28/, H/56/, IPIVOT/76/, IVNEED/3/, JCN/66/, JTOL/59/,      
C    2     LMAT/42/, MODE/35/, NEXTIV/46/, NEXTV/47/, NFCALL/6/,        
C    3     NFCOV/52/, NF0/68/, NF00/81/, NF1/69/, NFGCAL/7/, NGCALL/30/,
C    4     NGCOV/53/, QTR/77/, RESTOR/9/, RMAT/78/, RDREQ/57/, REGD/67/,
C    5     TOOBIG/2/, VNEED/4/, Y/48/                                   
C/7                                                                     
      PARAMETER (CNVCOD=55, COVMAT=26, COVREQ=15, DTYPE=16, FDH=74,     
     1           G=28, H=56, IPIVOT=76, IVNEED=3, JCN=66, JTOL=59,      
     2           LMAT=42, MODE=35, NEXTIV=46, NEXTV=47, NFCALL=6,       
     3           NFCOV=52, NF0=68, NF00=81, NF1=69, NFGCAL=7, NGCALL=30,
     4           NGCOV=53, QTR=77, RESTOR=9, RMAT=78, RDREQ=57, REGD=67,
     5           TOOBIG=2, VNEED=4, Y=48)                               
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA DINIT/38/, DTINIT/39/, D0INIT/40/, F/10/, RLIMIT/46/         
C/7                                                                     
      PARAMETER (DINIT=38, DTINIT=39, D0INIT=40, F=10, RLIMIT=46)       
C/                                                                      
C/6                                                                     
C     DATA HALF/0.5E+0/, ZERO/0.E+0/                                    
C/7                                                                     
      PARAMETER (HALF=0.5E+0, ZERO=0.E+0)                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = P * (P+1) / 2                                                
      NN = N2 - N1 + 1                                                  
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .GT. 2) GO TO 10                                          
         IV(RESTOR) = 0                                                 
         I = IV1 + 4                                                    
         IF (IV(TOOBIG) .EQ. 0) GO TO (150, 130, 150, 120, 120, 150), I 
         IF (I .NE. 5) IV(1) = 2                                        
         GO TO 40                                                       
C                                                                       
C  ***  FRESH START OR RESTART -- CHECK INPUT INTEGERS  ***             
C                                                                       
 10   IF (ND .LE. 0) GO TO 210                                          
      IF (P .LE. 0) GO TO 210                                           
      IF (N .LE. 0) GO TO 210                                           
      IF (IV1 .EQ. 14) GO TO 30                                         
      IF (IV1 .GT. 16) GO TO 300                                        
      IF (IV1 .LT. 12) GO TO 40                                         
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 20                                       
      IV(IVNEED) = IV(IVNEED) + P                                       
      IV(VNEED) = IV(VNEED) + P*(P+13)/2                                
 20   CALL G7LIT(D, X, IV, LIV, LV, P, P, V, X, X)                      
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IPIVOT) = IV(NEXTIV)                                           
      IV(NEXTIV) = IV(IPIVOT) + P                                       
      IV(Y) = IV(NEXTV)                                                 
      IV(G) = IV(Y) + P                                                 
      IV(JCN) = IV(G) + P                                               
      IV(RMAT) = IV(JCN) + P                                            
      IV(QTR) = IV(RMAT) + LH                                           
      IV(JTOL) = IV(QTR) + P                                            
      IV(NEXTV) = IV(JTOL) + 2*P                                        
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 30   JTOL1 = IV(JTOL)                                                  
      IF (V(DINIT) .GE. ZERO) CALL  V7SCP(P, D, V(DINIT))               
      IF (V(DTINIT) .GT. ZERO) CALL  V7SCP(P, V(JTOL1), V(DTINIT))      
      I = JTOL1 + P                                                     
      IF (V(D0INIT) .GT. ZERO) CALL  V7SCP(P, V(I), V(D0INIT))          
      IV(NF0) = 0                                                       
      IV(NF1) = 0                                                       
      IF (ND .GE. N) GO TO 40                                           
C                                                                       
C  ***  SPECIAL CASE HANDLING OF FIRST FUNCTION AND GRADIENT EVALUATION 
C  ***  -- ASK FOR BOTH RESIDUAL AND JACOBIAN AT ONCE                   
C                                                                       
      G1 = IV(G)                                                        
      Y1 = IV(Y)                                                        
      CALL G7LIT(D, V(G1), IV, LIV, LV, P, P, V, X, V(Y1))              
      IF (IV(1) .NE. 1) GO TO 220                                       
      V(F) = ZERO                                                       
      CALL  V7SCP(P, V(G1), ZERO)                                       
      IV(1) = -1                                                        
      QTR1 = IV(QTR)                                                    
      CALL  V7SCP(P, V(QTR1), ZERO)                                     
      IV(REGD) = 0                                                      
      RMAT1 = IV(RMAT)                                                  
      GO TO 100                                                         
C                                                                       
 40   G1 = IV(G)                                                        
      Y1 = IV(Y)                                                        
      CALL G7LIT(D, V(G1), IV, LIV, LV, P, P, V, X, V(Y1))              
      IF (IV(1) - 2) 50, 60, 220                                        
C                                                                       
 50   V(F) = ZERO                                                       
      IF (IV(NF1) .EQ. 0) GO TO 260                                     
      IF (IV(RESTOR) .NE. 2) GO TO 260                                  
      IV(NF0) = IV(NF1)                                                 
      CALL V7CPY(N, RD, R)                                              
      IV(REGD) = 0                                                      
      GO TO 260                                                         
C                                                                       
 60   CALL  V7SCP(P, V(G1), ZERO)                                       
      IF (IV(MODE) .GT. 0) GO TO 230                                    
      RMAT1 = IV(RMAT)                                                  
      QTR1 = IV(QTR)                                                    
      CALL  V7SCP(P, V(QTR1), ZERO)                                     
      IV(REGD) = 0                                                      
      IF (ND .LT. N) GO TO 90                                           
      IF (N1 .NE. 1) GO TO 90                                           
      IF (IV(MODE) .LT. 0) GO TO 100                                    
      IF (IV(NF1) .EQ. IV(NFGCAL)) GO TO 70                             
         IF (IV(NF0) .NE. IV(NFGCAL)) GO TO 90                          
            CALL V7CPY(N, R, RD)                                        
            GO TO 80                                                    
 70   CALL V7CPY(N, RD, R)                                              
 80   CALL  Q7APL(ND, N, P, DR, RD, 0)                                  
      CALL L7VML(P, V(Y1), V(RMAT1), RD)                                
      GO TO 110                                                         
C                                                                       
 90   IV(1) = -2                                                        
      IF (IV(MODE) .LT. 0) IV(1) = -1                                   
 100  CALL  V7SCP(P, V(Y1), ZERO)                                       
 110  CALL  V7SCP(LH, V(RMAT1), ZERO)                                   
      GO TO 260                                                         
C                                                                       
C  ***  COMPUTE F(X)  ***                                               
C                                                                       
 120  T =  V2NRM(NN, R)                                                 
      IF (T .GT. V(RLIMIT)) GO TO 200                                   
      V(F) = V(F)  +  HALF * T**2                                       
      IF (N2 .LT. N) GO TO 270                                          
      IF (N1 .EQ. 1) IV(NF1) = IV(NFCALL)                               
      GO TO 40                                                          
C                                                                       
C  ***  COMPUTE Y  ***                                                  
C                                                                       
 130  Y1 = IV(Y)                                                        
      YI = Y1                                                           
      DO 140 L = 1, P                                                   
         V(YI) = V(YI) +  D7TPR(NN, DR(1,L), R)                         
         YI = YI + 1                                                    
 140     CONTINUE                                                       
      IF (N2 .LT. N) GO TO 270                                          
         IV(1) = 2                                                      
         IF (N1 .GT. 1) IV(1) = -3                                      
         GO TO 260                                                      
C                                                                       
C  ***  COMPUTE GRADIENT INFORMATION  ***                               
C                                                                       
 150  IF (IV(MODE) .GT. P) GO TO 240                                    
      G1 = IV(G)                                                        
      IVMODE = IV(MODE)                                                 
      IF (IVMODE .LT. 0) GO TO 170                                      
      IF (IVMODE .EQ. 0) GO TO 180                                      
      IV(1) = 2                                                         
C                                                                       
C  ***  COMPUTE GRADIENT ONLY (FOR USE IN COVARIANCE COMPUTATION)  ***  
C                                                                       
      GI = G1                                                           
      DO 160 L = 1, P                                                   
         V(GI) = V(GI) +  D7TPR(NN, R, DR(1,L))                         
         GI = GI + 1                                                    
 160     CONTINUE                                                       
      GO TO 190                                                         
C                                                                       
C  *** COMPUTE INITIAL FUNCTION VALUE WHEN ND .LT. N ***                
C                                                                       
 170  IF (N .LE. ND) GO TO 180                                          
         T =  V2NRM(NN, R)                                              
         IF (T .GT. V(RLIMIT)) GO TO 200                                
         V(F) = V(F)  +  HALF * T**2                                    
C                                                                       
C  ***  UPDATE D IF DESIRED  ***                                        
C                                                                       
 180  IF (IV(DTYPE) .GT. 0)                                             
     1      CALL D7UPD(D, DR, IV, LIV, LV, N, ND, NN, N2, P, V)         
C                                                                       
C  ***  COMPUTE RMAT AND QTR  ***                                       
C                                                                       
      QTR1 = IV(QTR)                                                    
      RMAT1 = IV(RMAT)                                                  
      CALL Q7RAD(NN, ND, P, V(QTR1), .TRUE., V(RMAT1), DR, R)           
      IV(NF1) = 0                                                       
C                                                                       
 190  IF (N2 .LT. N) GO TO 270                                          
      IF (IVMODE .GT. 0) GO TO 40                                       
      IV(NF00) = IV(NFGCAL)                                             
C                                                                       
C  ***  COMPUTE G FROM RMAT AND QTR  ***                                
C                                                                       
      CALL L7VML(P, V(G1), V(RMAT1), V(QTR1))                           
      IV(1) = 2                                                         
      IF (IVMODE .EQ. 0) GO TO 40                                       
      IF (N .LE. ND) GO TO 40                                           
C                                                                       
C  ***  FINISH SPECIAL CASE HANDLING OF FIRST FUNCTION AND GRADIENT     
C                                                                       
      Y1 = IV(Y)                                                        
      IV(1) = 1                                                         
      CALL G7LIT(D, V(G1), IV, LIV, LV, P, P, V, X, V(Y1))              
      IF (IV(1) .NE. 2) GO TO 220                                       
      GO TO 40                                                          
C                                                                       
C  ***  MISC. DETAILS  ***                                              
C                                                                       
C     ***  X IS OUT OF RANGE (OVERSIZE STEP)  ***                       
C                                                                       
 200  IV(TOOBIG) = 1                                                    
      GO TO 40                                                          
C                                                                       
C     ***  BAD N, ND, OR P  ***                                         
C                                                                       
 210  IV(1) = 66                                                        
      GO TO 300                                                         
C                                                                       
C  ***  CONVERGENCE OBTAINED -- SEE WHETHER TO COMPUTE COVARIANCE  ***  
C                                                                       
 220  IF (IV(COVMAT) .NE. 0) GO TO 290                                  
      IF (IV(REGD) .NE. 0) GO TO 290                                    
C                                                                       
C     ***  SEE IF CHOLESKY FACTOR OF HESSIAN IS AVAILABLE  ***          
C                                                                       
      K = IV(FDH)                                                       
      IF (K .LE. 0) GO TO 280                                           
      IF (IV(RDREQ) .LE. 0) GO TO 290                                   
C                                                                       
C     ***  COMPUTE REGRESSION DIAGNOSTICS AND DEFAULT COVARIANCE IF     
C          DESIRED  ***                                                 
C                                                                       
      I = 0                                                             
      IF (MOD(IV(RDREQ),4) .GE. 2) I = 1                                
      IF (MOD(IV(RDREQ),2) .EQ. 1 .AND. IABS(IV(COVREQ)) .LE. 1) I = I+2
      IF (I .EQ. 0) GO TO 250                                           
      IV(MODE) = P + I                                                  
      IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(NGCOV) = IV(NGCOV) + 1                                         
      IV(CNVCOD) = IV(1)                                                
      IF (I .LT. 2) GO TO 230                                           
         L = IABS(IV(H))                                                
         CALL  V7SCP(LH, V(L), ZERO)                                    
 230  IV(NFCOV) = IV(NFCOV) + 1                                         
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(NFGCAL) = IV(NFCALL)                                           
      IV(1) = -1                                                        
      GO TO 260                                                         
C                                                                       
 240  L = IV(LMAT)                                                      
      CALL  N2LRD(DR, IV, V(L), LH, LIV, LV, ND, NN, P, R, RD, V)       
      IF (N2 .LT. N) GO TO 270                                          
      IF (N1 .GT. 1) GO TO 250                                          
C                                                                       
C     ***  ENSURE WE CAN RESTART -- AND MAKE RETURN STATE OF DR         
C     ***  INDEPENDENT OF WHETHER REGRESSION DIAGNOSTICS ARE COMPUTED.  
C     ***  USE STEP VECTOR (ALLOCATED BY G7LIT) FOR SCRATCH.            
C                                                                       
      RMAT1 = IV(RMAT)                                                  
      CALL  V7SCP(LH, V(RMAT1), ZERO)                                   
      CALL Q7RAD(NN, ND, P, R, .FALSE., V(RMAT1), DR, R)                
      IV(NF1) = 0                                                       
C                                                                       
C  ***  FINISH COMPUTING COVARIANCE  ***                                
C                                                                       
 250  L = IV(LMAT)                                                      
      CALL  C7VFN(IV, V(L), LH, LIV, LV, N, P, V)                       
      GO TO 290                                                         
C                                                                       
C  ***  RETURN FOR MORE FUNCTION OR GRADIENT INFORMATION  ***           
C                                                                       
 260  N2 = 0                                                            
 270  N1 = N2 + 1                                                       
      N2 = N2 + ND                                                      
      IF (N2 .GT. N) N2 = N                                             
      GO TO 999                                                         
C                                                                       
C  ***  COME HERE FOR INDEFINITE FINITE-DIFFERENCE HESSIAN  ***         
C                                                                       
 280  IV(COVMAT) = K                                                    
      IV(REGD) = K                                                      
C                                                                       
C  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  *** 
C                                                                       
 290  G1 = IV(G)                                                        
 300  CALL ITSUM(D, V(G1), IV, LIV, LV, P, V, X)                        
      IF (IV(1) .LE. 6 .AND. IV(RDREQ) .GT. 0)                          
     1     CALL  N2CVP(IV, LIV, LV, P, V)                               
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF   RN2G FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  N2RDP(IV, LIV, LV, N, RD, V)                          
C                                                                       
C  ***  PRINT REGRESSION DIAGNOSTICS FOR MLPSL AND NL2S1 ***            
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      REAL RD(N), V(LV)                                                 
C                                                                       
C     ***  NOTE -- V IS PASSED FOR POSSIBLE USE BY REVISED VERSIONS OF  
C     ***  THIS ROUTINE.                                                
C                                                                       
      INTEGER PU                                                        
C                                                                       
C  ***  IV AND V SUBSCRIPTS  ***                                        
C                                                                       
      INTEGER COVPRT, F, NEEDHD, PRUNIT, REGD                           
C                                                                       
C/6                                                                     
C     DATA COVPRT/14/, F/10/, NEEDHD/36/, PRUNIT/21/, REGD/67/          
C/7                                                                     
      PARAMETER (COVPRT=14, F=10, NEEDHD=36, PRUNIT=21, REGD=67)        
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      PU = IV(PRUNIT)                                                   
      IF (PU .EQ. 0) GO TO 999                                          
      IF (IV(COVPRT) .LT. 2) GO TO 999                                  
      IF (IV(REGD) .LE. 0) GO TO 999                                    
      IV(NEEDHD) = 1                                                    
      IF (V(F)) 10, 30, 10                                              
 10   WRITE(PU,20) RD                                                   
 20   FORMAT(/70H REGRESSION DIAGNOSTIC = SQRT( G(I)**T * H(I)**-1 * G(I
     1) / ABS(F) ).../(6E12.3))                                         
      GO TO 999                                                         
 30   WRITE(PU,40) RD                                                   
 40   FORMAT(/61H REGRESSION DIAGNOSTIC = SQRT( G(I)**T * H(I)**-1 * G(I
     1) ).../(6E12.3))                                                  
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  N2RDP FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  S3GRD(ALPHA, B, D, ETA0, FX, G, IRC, P, W, X)         
C                                                                       
C  ***  COMPUTE FINITE DIFFERENCE GRADIENT BY STWEART*S SCHEME  ***     
C                                                                       
C     ***  PARAMETERS  ***                                              
C                                                                       
      INTEGER IRC, P                                                    
      REAL ALPHA(P), B(2,P), D(P), ETA0, FX, G(P), W(6),                
     1                 X(P)                                             
C                                                                       
C.......................................................................
C                                                                       
C     ***  PURPOSE  ***                                                 
C                                                                       
C        THIS SUBROUTINE USES AN EMBELLISHED FORM OF THE FINITE-DIFFER- 
C     ENCE SCHEME PROPOSED BY STEWART (REF. 1) TO APPROXIMATE THE       
C     GRADIENT OF THE FUNCTION F(X), WHOSE VALUES ARE SUPPLIED BY       
C     REVERSE COMMUNICATION.                                            
C                                                                       
C     ***  PARAMETER DESCRIPTION  ***                                   
C                                                                       
C  ALPHA IN  (APPROXIMATE) DIAGONAL ELEMENTS OF THE HESSIAN OF F(X).    
C      B IN  ARRAY OF SIMPLE LOWER AND UPPER BOUNDS ON X.  X MUST       
C             SATISFY B(1,I) .LE. X(I) .LE. B(2,I), I = 1(1)P.          
C             FOR ALL I WITH B(1,I) .GE. B(2,I),  S3GRD SIMPLY          
C             SETS G(I) TO 0.                                           
C      D IN  SCALE VECTOR SUCH THAT D(I)*X(I), I = 1,...,P, ARE IN      
C             COMPARABLE UNITS.                                         
C   ETA0 IN  ESTIMATED BOUND ON RELATIVE ERROR IN THE FUNCTION VALUE... 
C             (TRUE VALUE) = (COMPUTED VALUE)*(1+E),   WHERE            
C             ABS(E) .LE. ETA0.                                         
C     FX I/O ON INPUT,  FX  MUST BE THE COMPUTED VALUE OF F(X).  ON     
C             OUTPUT WITH IRC = 0, FX HAS BEEN RESTORED TO ITS ORIGINAL 
C             VALUE, THE ONE IT HAD WHEN  S3GRD WAS LAST CALLED WITH    
C             IRC = 0.                                                  
C      G I/O ON INPUT WITH IRC = 0, G SHOULD CONTAIN AN APPROXIMATION   
C             TO THE GRADIENT OF F NEAR X, E.G., THE GRADIENT AT THE    
C             PREVIOUS ITERATE.  WHEN  S3GRD RETURNS WITH IRC = 0, G IS 
C             THE DESIRED FINITE-DIFFERENCE APPROXIMATION TO THE        
C             GRADIENT AT X.                                            
C    IRC I/O INPUT/RETURN CODE... BEFORE THE VERY FIRST CALL ON  S3GRD, 
C             THE CALLER MUST SET IRC TO 0.  WHENEVER  S3GRD RETURNS A  
C             NONZERO VALUE (OF AT MOST P) FOR IRC, IT HAS PERTURBED    
C             SOME COMPONENT OF X... THE CALLER SHOULD EVALUATE F(X)    
C             AND CALL  S3GRD AGAIN WITH FX = F(X).  IF B PREVENTS      
C             ESTIMATING G(I) I.E., IF THERE IS AN I WITH               
C             B(1,I) .LT. B(2,I) BUT WITH B(1,I) SO CLOSE TO B(2,I)     
C             THAT THE FINITE-DIFFERENCING STEPS CANNOT BE CHOSEN,      
C             THEN  S3GRD RETURNS WITH IRC .GT. P.                      
C      P IN  THE NUMBER OF VARIABLES (COMPONENTS OF X) ON WHICH F       
C             DEPENDS.                                                  
C      X I/O ON INPUT WITH IRC = 0, X IS THE POINT AT WHICH THE         
C             GRADIENT OF F IS DESIRED.  ON OUTPUT WITH IRC NONZERO, X  
C             IS THE POINT AT WHICH F SHOULD BE EVALUATED.  ON OUTPUT   
C             WITH IRC = 0, X HAS BEEN RESTORED TO ITS ORIGINAL VALUE   
C             (THE ONE IT HAD WHEN  S3GRD WAS LAST CALLED WITH IRC = 0) 
C             AND G CONTAINS THE DESIRED GRADIENT APPROXIMATION.        
C      W I/O WORK VECTOR OF LENGTH 6 IN WHICH  S3GRD SAVES CERTAIN      
C             QUANTITIES WHILE THE CALLER IS EVALUATING F(X) AT A       
C             PERTURBED X.                                              
C                                                                       
C     ***  APPLICATION AND USAGE RESTRICTIONS  ***                      
C                                                                       
C        THIS ROUTINE IS INTENDED FOR USE WITH QUASI-NEWTON ROUTINES    
C     FOR UNCONSTRAINED MINIMIZATION (IN WHICH CASE  ALPHA  COMES FROM  
C     THE DIAGONAL OF THE QUASI-NEWTON HESSIAN APPROXIMATION).          
C                                                                       
C     ***  ALGORITHM NOTES  ***                                         
C                                                                       
C        THIS CODE DEPARTS FROM THE SCHEME PROPOSED BY STEWART (REF. 1) 
C     IN ITS GUARDING AGAINST OVERLY LARGE OR SMALL STEP SIZES AND ITS  
C     HANDLING OF SPECIAL CASES (SUCH AS ZERO COMPONENTS OF ALPHA OR G).
C                                                                       
C     ***  REFERENCES  ***                                              
C                                                                       
C 1. STEWART, G.W. (1967), A MODIFICATION OF DAVIDON*S MINIMIZATION     
C        METHOD TO ACCEPT DIFFERENCE APPROXIMATIONS OF DERIVATIVES,     
C        J. ASSOC. COMPUT. MACH. 14, PP. 72-83.                         
C                                                                       
C     ***  HISTORY  ***                                                 
C                                                                       
C     DESIGNED AND CODED BY DAVID M. GAY (SUMMER 1977/SUMMER 1980).     
C                                                                       
C     ***  GENERAL  ***                                                 
C                                                                       
C        THIS ROUTINE WAS PREPARED IN CONNECTION WITH WORK SUPPORTED BY 
C     THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS MCS76-00324 AND      
C     MCS-7906671.                                                      
C                                                                       
C.......................................................................
C                                                                       
C     *****  EXTERNAL FUNCTION  *****                                   
C                                                                       
      REAL  R7MDC                                                       
      EXTERNAL  R7MDC                                                   
C  R7MDC... RETURNS MACHINE-DEPENDENT CONSTANTS.                        
C                                                                       
C     ***** INTRINSIC FUNCTIONS *****                                   
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C     ***** LOCAL VARIABLES *****                                       
C                                                                       
      LOGICAL HIT                                                       
      INTEGER FH, FX0, HSAVE, I, XISAVE                                 
      REAL AAI, AFX, AFXETA, AGI, ALPHAI, AXI, AXIBAR,                  
     1                 DISCON, ETA, GI, H, HMIN, XI, XIH                
      REAL C2000, FOUR, HMAX0, HMIN0, H0, MACHEP, ONE, P002,            
     1                 THREE, TWO, ZERO                                 
C                                                                       
C/6                                                                     
C     DATA C2000/2.0E+3/, FOUR/4.0E+0/, HMAX0/0.02E+0/, HMIN0/5.0E+1/,  
C    1     ONE/1.0E+0/, P002/0.002E+0/, THREE/3.0E+0/,                  
C    2     TWO/2.0E+0/, ZERO/0.0E+0/                                    
C/7                                                                     
      PARAMETER (C2000=2.0E+3, FOUR=4.0E+0, HMAX0=0.02E+0, HMIN0=5.0E+1,
     1     ONE=1.0E+0, P002=0.002E+0, THREE=3.0E+0,                     
     2     TWO=2.0E+0, ZERO=0.0E+0)                                     
C/                                                                      
C/6                                                                     
C     DATA FH/3/, FX0/4/, HSAVE/5/, XISAVE/6/                           
C/7                                                                     
      PARAMETER (FH=3, FX0=4, HSAVE=5, XISAVE=6)                        
C/                                                                      
C                                                                       
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IRC) 80, 10, 210                                              
C                                                                       
C     ***  FRESH START -- GET MACHINE-DEPENDENT CONSTANTS  ***          
C                                                                       
C     STORE MACHEP IN W(1) AND H0 IN W(2), WHERE MACHEP IS THE UNIT     
C     ROUNDOFF (THE SMALLEST POSITIVE NUMBER SUCH THAT                  
C     1 + MACHEP .GT. 1  AND  1 - MACHEP .LT. 1),  AND  H0 IS THE       
C     SQUARE-ROOT OF MACHEP.                                            
C                                                                       
 10   W(1) =  R7MDC(3)                                                  
      W(2) =  SQRT(W(1))                                                
C                                                                       
      W(FX0) = FX                                                       
C                                                                       
C     ***  INCREMENT  I  AND START COMPUTING  G(I)  ***                 
C                                                                       
 20   I = IABS(IRC) + 1                                                 
      IF (I .GT. P) GO TO 220                                           
         IRC = I                                                        
         IF (B(1,I) .LT. B(2,I)) GO TO 30                               
            G(I) = ZERO                                                 
            GO TO 20                                                    
 30      AFX =  ABS(W(FX0))                                             
         MACHEP = W(1)                                                  
         H0 = W(2)                                                      
         HMIN = HMIN0 * MACHEP                                          
         XI = X(I)                                                      
         W(XISAVE) = XI                                                 
         AXI =  ABS(XI)                                                 
         AXIBAR = AMAX1(AXI, ONE/D(I))                                  
         GI = G(I)                                                      
         AGI =  ABS(GI)                                                 
         ETA =  ABS(ETA0)                                               
         IF (AFX .GT. ZERO) ETA = AMAX1(ETA, AGI*AXI*MACHEP/AFX)        
         ALPHAI = ALPHA(I)                                              
         IF (ALPHAI .EQ. ZERO) GO TO 130                                
         IF (GI .EQ. ZERO .OR. FX .EQ. ZERO) GO TO 140                  
         AFXETA = AFX*ETA                                               
         AAI =  ABS(ALPHAI)                                             
C                                                                       
C        *** COMPUTE H = STEWART*S FORWARD-DIFFERENCE STEP SIZE.        
C                                                                       
         IF (GI**2 .LE. AFXETA*AAI) GO TO 40                            
              H = TWO* SQRT(AFXETA/AAI)                                 
              H = H*(ONE - AAI*H/(THREE*AAI*H + FOUR*AGI))              
              GO TO 50                                                  
C40      H = TWO*(AFXETA*AGI/(AAI**2))**(ONE/THREE)                     
 40      H = TWO * (AFXETA*AGI)**(ONE/THREE) * AAI**(-TWO/THREE)        
         H = H*(ONE - TWO*AGI/(THREE*AAI*H + FOUR*AGI))                 
C                                                                       
C        ***  ENSURE THAT  H  IS NOT INSIGNIFICANTLY SMALL  ***         
C                                                                       
 50      H = AMAX1(H, HMIN*AXIBAR)                                      
C                                                                       
C        *** USE FORWARD DIFFERENCE IF BOUND ON TRUNCATION ERROR IS AT  
C        *** MOST 10**-3.                                               
C                                                                       
         IF (AAI*H .LE. P002*AGI) GO TO 120                             
C                                                                       
C        *** COMPUTE H = STEWART*S STEP FOR CENTRAL DIFFERENCE.         
C                                                                       
         DISCON = C2000*AFXETA                                          
         H = DISCON/(AGI +  SQRT(GI**2 + AAI*DISCON))                   
C                                                                       
C        ***  ENSURE THAT  H  IS NEITHER TOO SMALL NOR TOO BIG  ***     
C                                                                       
         H = AMAX1(H, HMIN*AXIBAR)                                      
         IF (H .GE. HMAX0*AXIBAR) H = AXIBAR * H0**(TWO/THREE)          
C                                                                       
C        ***  COMPUTE CENTRAL DIFFERENCE  ***                           
C                                                                       
         XIH = XI + H                                                   
         IF (XI - H .LT. B(1,I)) GO TO 60                               
         IRC = -I                                                       
         IF (XIH .LE. B(2,I)) GO TO 200                                 
            H = -H                                                      
            XIH = XI + H                                                
            IF (XI + TWO*H .LT. B(1,I)) GO TO 190                       
            GO TO 70                                                    
 60      IF (XI + TWO*H .GT. B(2,I)) GO TO 190                          
C        *** MUST DO OFF-SIDE CENTRAL DIFFERENCE ***                    
 70      IRC = -(I + P)                                                 
         GO TO 200                                                      
C                                                                       
 80      I = -IRC                                                       
         IF (I .LE. P) GO TO 100                                        
         I = I - P                                                      
         IF (I .GT. P) GO TO 90                                         
         W(FH) = FX                                                     
         H = TWO * W(HSAVE)                                             
         XIH = W(XISAVE) + H                                            
         IRC = IRC - P                                                  
         GO TO 200                                                      
C                                                                       
C    *** FINISH OFF-SIDE CENTRAL DIFFERENCE ***                         
C                                                                       
 90      I = I - P                                                      
         G(I) = (FOUR*W(FH) - FX - THREE*W(FX0)) / W(HSAVE)             
         IRC = I                                                        
         X(I) = W(XISAVE)                                               
         GO TO 20                                                       
C                                                                       
 100     H = -W(HSAVE)                                                  
         IF (H .GT. ZERO) GO TO 110                                     
         W(FH) = FX                                                     
         XIH = W(XISAVE) + H                                            
         GO TO 200                                                      
C                                                                       
 110     G(I) = (W(FH) - FX) / (TWO * H)                                
         X(I) = W(XISAVE)                                               
         GO TO 20                                                       
C                                                                       
C     ***  COMPUTE FORWARD DIFFERENCES IN VARIOUS CASES  ***            
C                                                                       
 120     IF (H .GE. HMAX0*AXIBAR) H = H0 * AXIBAR                       
         IF (ALPHAI*GI .LT. ZERO) H = -H                                
         GO TO 150                                                      
 130     H = AXIBAR                                                     
         GO TO 150                                                      
 140     H = H0 * AXIBAR                                                
C                                                                       
 150     HIT = .FALSE.                                                  
 160     XIH = XI + H                                                   
         IF (H .GT. ZERO) GO TO 170                                     
            IF (XIH .GE. B(1,I)) GO TO 200                              
            GO TO 180                                                   
 170     IF (XIH .LE. B(2,I)) GO TO 200                                 
 180        IF (HIT) GO TO 190                                          
            HIT = .TRUE.                                                
            H = -H                                                      
            GO TO 160                                                   
C                                                                       
C        *** ERROR RETURN...                                            
 190     IRC = I + P                                                    
         GO TO 230                                                      
C                                                                       
C        *** RETURN FOR NEW FUNCTION VALUE...                           
 200     X(I) = XIH                                                     
         W(HSAVE) = H                                                   
         GO TO 999                                                      
C                                                                       
C     ***  COMPUTE ACTUAL FORWARD DIFFERENCE  ***                       
C                                                                       
 210     G(IRC) = (FX - W(FX0)) / W(HSAVE)                              
         X(IRC) = W(XISAVE)                                             
         GO TO 20                                                       
C                                                                       
C  ***  RESTORE FX AND INDICATE THAT G HAS BEEN COMPUTED  ***           
C                                                                       
 220  IRC = 0                                                           
 230  FX = W(FX0)                                                       
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  S3GRD FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  S7GRD (ALPHA, D, ETA0, FX, G, IRC, N, W, X)           
C                                                                       
C  ***  COMPUTE FINITE DIFFERENCE GRADIENT BY STWEART*S SCHEME  ***     
C                                                                       
C     ***  PARAMETERS  ***                                              
C                                                                       
      INTEGER IRC, N                                                    
      REAL ALPHA(N), D(N), ETA0, FX, G(N), W(6), X(N)                   
C                                                                       
C.......................................................................
C                                                                       
C     ***  PURPOSE  ***                                                 
C                                                                       
C        THIS SUBROUTINE USES AN EMBELLISHED FORM OF THE FINITE-DIFFER- 
C     ENCE SCHEME PROPOSED BY STEWART (REF. 1) TO APPROXIMATE THE       
C     GRADIENT OF THE FUNCTION F(X), WHOSE VALUES ARE SUPPLIED BY       
C     REVERSE COMMUNICATION.                                            
C                                                                       
C     ***  PARAMETER DESCRIPTION  ***                                   
C                                                                       
C  ALPHA IN  (APPROXIMATE) DIAGONAL ELEMENTS OF THE HESSIAN OF F(X).    
C      D IN  SCALE VECTOR SUCH THAT D(I)*X(I), I = 1,...,N, ARE IN      
C             COMPARABLE UNITS.                                         
C   ETA0 IN  ESTIMATED BOUND ON RELATIVE ERROR IN THE FUNCTION VALUE... 
C             (TRUE VALUE) = (COMPUTED VALUE)*(1+E),   WHERE            
C             ABS(E) .LE. ETA0.                                         
C     FX I/O ON INPUT,  FX  MUST BE THE COMPUTED VALUE OF F(X).  ON     
C             OUTPUT WITH IRC = 0, FX HAS BEEN RESTORED TO ITS ORIGINAL 
C             VALUE, THE ONE IT HAD WHEN  S7GRD WAS LAST CALLED WITH    
C             IRC = 0.                                                  
C      G I/O ON INPUT WITH IRC = 0, G SHOULD CONTAIN AN APPROXIMATION   
C             TO THE GRADIENT OF F NEAR X, E.G., THE GRADIENT AT THE    
C             PREVIOUS ITERATE.  WHEN  S7GRD RETURNS WITH IRC = 0, G IS 
C             THE DESIRED FINITE-DIFFERENCE APPROXIMATION TO THE        
C             GRADIENT AT X.                                            
C    IRC I/O INPUT/RETURN CODE... BEFORE THE VERY FIRST CALL ON  S7GRD, 
C             THE CALLER MUST SET IRC TO 0.  WHENEVER  S7GRD RETURNS A  
C             NONZERO VALUE FOR IRC, IT HAS PERTURBED SOME COMPONENT OF 
C             X... THE CALLER SHOULD EVALUATE F(X) AND CALL  S7GRD      
C             AGAIN WITH FX = F(X).                                     
C      N IN  THE NUMBER OF VARIABLES (COMPONENTS OF X) ON WHICH F       
C             DEPENDS.                                                  
C      X I/O ON INPUT WITH IRC = 0, X IS THE POINT AT WHICH THE         
C             GRADIENT OF F IS DESIRED.  ON OUTPUT WITH IRC NONZERO, X  
C             IS THE POINT AT WHICH F SHOULD BE EVALUATED.  ON OUTPUT   
C             WITH IRC = 0, X HAS BEEN RESTORED TO ITS ORIGINAL VALUE   
C             (THE ONE IT HAD WHEN  S7GRD WAS LAST CALLED WITH IRC = 0) 
C             AND G CONTAINS THE DESIRED GRADIENT APPROXIMATION.        
C      W I/O WORK VECTOR OF LENGTH 6 IN WHICH  S7GRD SAVES CERTAIN      
C             QUANTITIES WHILE THE CALLER IS EVALUATING F(X) AT A       
C             PERTURBED X.                                              
C                                                                       
C     ***  APPLICATION AND USAGE RESTRICTIONS  ***                      
C                                                                       
C        THIS ROUTINE IS INTENDED FOR USE WITH QUASI-NEWTON ROUTINES    
C     FOR UNCONSTRAINED MINIMIZATION (IN WHICH CASE  ALPHA  COMES FROM  
C     THE DIAGONAL OF THE QUASI-NEWTON HESSIAN APPROXIMATION).          
C                                                                       
C     ***  ALGORITHM NOTES  ***                                         
C                                                                       
C        THIS CODE DEPARTS FROM THE SCHEME PROPOSED BY STEWART (REF. 1) 
C     IN ITS GUARDING AGAINST OVERLY LARGE OR SMALL STEP SIZES AND ITS  
C     HANDLING OF SPECIAL CASES (SUCH AS ZERO COMPONENTS OF ALPHA OR G).
C                                                                       
C     ***  REFERENCES  ***                                              
C                                                                       
C 1. STEWART, G.W. (1967), A MODIFICATION OF DAVIDON*S MINIMIZATION     
C        METHOD TO ACCEPT DIFFERENCE APPROXIMATIONS OF DERIVATIVES,     
C        J. ASSOC. COMPUT. MACH. 14, PP. 72-83.                         
C                                                                       
C     ***  HISTORY  ***                                                 
C                                                                       
C     DESIGNED AND CODED BY DAVID M. GAY (SUMMER 1977/SUMMER 1980).     
C                                                                       
C     ***  GENERAL  ***                                                 
C                                                                       
C        THIS ROUTINE WAS PREPARED IN CONNECTION WITH WORK SUPPORTED BY 
C     THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS MCS76-00324 AND      
C     MCS-7906671.                                                      
C                                                                       
C.......................................................................
C                                                                       
C     *****  EXTERNAL FUNCTION  *****                                   
C                                                                       
      REAL  R7MDC                                                       
      EXTERNAL  R7MDC                                                   
C  R7MDC... RETURNS MACHINE-DEPENDENT CONSTANTS.                        
C                                                                       
C     ***** INTRINSIC FUNCTIONS *****                                   
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C     ***** LOCAL VARIABLES *****                                       
C                                                                       
      INTEGER FH, FX0, HSAVE, I, XISAVE                                 
      REAL AAI, AFX, AFXETA, AGI, ALPHAI, AXI, AXIBAR,                  
     1                 DISCON, ETA, GI, H, HMIN                         
      REAL C2000, FOUR, HMAX0, HMIN0, H0, MACHEP, ONE, P002,            
     1                 THREE, TWO, ZERO                                 
C                                                                       
C/6                                                                     
C     DATA C2000/2.0E+3/, FOUR/4.0E+0/, HMAX0/0.02E+0/, HMIN0/5.0E+1/,  
C    1     ONE/1.0E+0/, P002/0.002E+0/, THREE/3.0E+0/,                  
C    2     TWO/2.0E+0/, ZERO/0.0E+0/                                    
C/7                                                                     
      PARAMETER (C2000=2.0E+3, FOUR=4.0E+0, HMAX0=0.02E+0, HMIN0=5.0E+1,
     1     ONE=1.0E+0, P002=0.002E+0, THREE=3.0E+0,                     
     2     TWO=2.0E+0, ZERO=0.0E+0)                                     
C/                                                                      
C/6                                                                     
C     DATA FH/3/, FX0/4/, HSAVE/5/, XISAVE/6/                           
C/7                                                                     
      PARAMETER (FH=3, FX0=4, HSAVE=5, XISAVE=6)                        
C/                                                                      
C                                                                       
C---------------------------------  BODY  ------------------------------
C                                                                       
      IF (IRC) 140, 100, 210                                            
C                                                                       
C     ***  FRESH START -- GET MACHINE-DEPENDENT CONSTANTS  ***          
C                                                                       
C     STORE MACHEP IN W(1) AND H0 IN W(2), WHERE MACHEP IS THE UNIT     
C     ROUNDOFF (THE SMALLEST POSITIVE NUMBER SUCH THAT                  
C     1 + MACHEP .GT. 1  AND  1 - MACHEP .LT. 1),  AND  H0 IS THE       
C     SQUARE-ROOT OF MACHEP.                                            
C                                                                       
 100  W(1) =  R7MDC(3)                                                  
      W(2) =  SQRT(W(1))                                                
C                                                                       
      W(FX0) = FX                                                       
C                                                                       
C     ***  INCREMENT  I  AND START COMPUTING  G(I)  ***                 
C                                                                       
 110  I = IABS(IRC) + 1                                                 
      IF (I .GT. N) GO TO 300                                           
         IRC = I                                                        
         AFX =  ABS(W(FX0))                                             
         MACHEP = W(1)                                                  
         H0 = W(2)                                                      
         HMIN = HMIN0 * MACHEP                                          
         W(XISAVE) = X(I)                                               
         AXI =  ABS(X(I))                                               
         AXIBAR = AMAX1(AXI, ONE/D(I))                                  
         GI = G(I)                                                      
         AGI =  ABS(GI)                                                 
         ETA =  ABS(ETA0)                                               
         IF (AFX .GT. ZERO) ETA = AMAX1(ETA, AGI*AXI*MACHEP/AFX)        
         ALPHAI = ALPHA(I)                                              
         IF (ALPHAI .EQ. ZERO) GO TO 170                                
         IF (GI .EQ. ZERO .OR. FX .EQ. ZERO) GO TO 180                  
         AFXETA = AFX*ETA                                               
         AAI =  ABS(ALPHAI)                                             
C                                                                       
C        *** COMPUTE H = STEWART*S FORWARD-DIFFERENCE STEP SIZE.        
C                                                                       
         IF (GI**2 .LE. AFXETA*AAI) GO TO 120                           
              H = TWO* SQRT(AFXETA/AAI)                                 
              H = H*(ONE - AAI*H/(THREE*AAI*H + FOUR*AGI))              
              GO TO 130                                                 
C120     H = TWO*(AFXETA*AGI/(AAI**2))**(ONE/THREE)                     
 120     H = TWO * (AFXETA*AGI)**(ONE/THREE) * AAI**(-TWO/THREE)        
         H = H*(ONE - TWO*AGI/(THREE*AAI*H + FOUR*AGI))                 
C                                                                       
C        ***  ENSURE THAT  H  IS NOT INSIGNIFICANTLY SMALL  ***         
C                                                                       
 130     H = AMAX1(H, HMIN*AXIBAR)                                      
C                                                                       
C        *** USE FORWARD DIFFERENCE IF BOUND ON TRUNCATION ERROR IS AT  
C        *** MOST 10**-3.                                               
C                                                                       
         IF (AAI*H .LE. P002*AGI) GO TO 160                             
C                                                                       
C        *** COMPUTE H = STEWART*S STEP FOR CENTRAL DIFFERENCE.         
C                                                                       
         DISCON = C2000*AFXETA                                          
         H = DISCON/(AGI +  SQRT(GI**2 + AAI*DISCON))                   
C                                                                       
C        ***  ENSURE THAT  H  IS NEITHER TOO SMALL NOR TOO BIG  ***     
C                                                                       
         H = AMAX1(H, HMIN*AXIBAR)                                      
         IF (H .GE. HMAX0*AXIBAR) H = AXIBAR * H0**(TWO/THREE)          
C                                                                       
C        ***  COMPUTE CENTRAL DIFFERENCE  ***                           
C                                                                       
         IRC = -I                                                       
         GO TO 200                                                      
C                                                                       
 140     H = -W(HSAVE)                                                  
         I = IABS(IRC)                                                  
         IF (H .GT. ZERO) GO TO 150                                     
         W(FH) = FX                                                     
         GO TO 200                                                      
C                                                                       
 150     G(I) = (W(FH) - FX) / (TWO * H)                                
         X(I) = W(XISAVE)                                               
         GO TO 110                                                      
C                                                                       
C     ***  COMPUTE FORWARD DIFFERENCES IN VARIOUS CASES  ***            
C                                                                       
 160     IF (H .GE. HMAX0*AXIBAR) H = H0 * AXIBAR                       
         IF (ALPHAI*GI .LT. ZERO) H = -H                                
         GO TO 200                                                      
 170     H = AXIBAR                                                     
         GO TO 200                                                      
 180     H = H0 * AXIBAR                                                
C                                                                       
 200     X(I) = W(XISAVE) + H                                           
         W(HSAVE) = H                                                   
         GO TO 999                                                      
C                                                                       
C     ***  COMPUTE ACTUAL FORWARD DIFFERENCE  ***                       
C                                                                       
 210     G(IRC) = (FX - W(FX0)) / W(HSAVE)                              
         X(IRC) = W(XISAVE)                                             
         GO TO 110                                                      
C                                                                       
C  ***  RESTORE FX AND INDICATE THAT G HAS BEEN COMPUTED  ***           
C                                                                       
 300  FX = W(FX0)                                                       
      IRC = 0                                                           
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF  S7GRD FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  W7ZBF (L, N, S, W, Y, Z)                              
C                                                                       
C  ***  COMPUTE  Y  AND  Z  FOR   L7UPD  CORRESPONDING TO BFGS UPDATE.  
C                                                                       
      INTEGER N                                                         
      REAL L(1), S(N), W(N), Y(N), Z(N)                                 
C     DIMENSION L(N*(N+1)/2)                                            
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C L (I/O) CHOLESKY FACTOR OF HESSIAN, A LOWER TRIANG. MATRIX STORED     
C             COMPACTLY BY ROWS.                                        
C N (INPUT) ORDER OF  L  AND LENGTH OF  S,  W,  Y,  Z.                  
C S (INPUT) THE STEP JUST TAKEN.                                        
C W (OUTPUT) RIGHT SINGULAR VECTOR OF RANK 1 CORRECTION TO L.           
C Y (INPUT) CHANGE IN GRADIENTS CORRESPONDING TO S.                     
C Z (OUTPUT) LEFT SINGULAR VECTOR OF RANK 1 CORRECTION TO L.            
C                                                                       
C-------------------------------  NOTES  -------------------------------
C                                                                       
C  ***  ALGORITHM NOTES  ***                                            
C                                                                       
C        WHEN  S  IS COMPUTED IN CERTAIN WAYS, E.G. BY  GQTSTP  OR      
C     DBLDOG,  IT IS POSSIBLE TO SAVE N**2/2 OPERATIONS SINCE  (L**T)*S 
C     OR  L*(L**T)*S IS THEN KNOWN.                                     
C        IF THE BFGS UPDATE TO L*(L**T) WOULD REDUCE ITS DETERMINANT TO 
C     LESS THAN EPS TIMES ITS OLD VALUE, THEN THIS ROUTINE IN EFFECT    
C     REPLACES  Y  BY  THETA*Y + (1 - THETA)*L*(L**T)*S,  WHERE  THETA  
C     (BETWEEN 0 AND 1) IS CHOSEN TO MAKE THE REDUCTION FACTOR = EPS.   
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY (FALL 1979).                                
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH SUPPORTED 
C     BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS MCS-7600324 AND   
C     MCS-7906671.                                                      
C                                                                       
C------------------------  EXTERNAL QUANTITIES  ------------------------
C                                                                       
C  ***  FUNCTIONS AND SUBROUTINES CALLED  ***                           
C                                                                       
      REAL  D7TPR                                                       
      EXTERNAL  D7TPR,  L7IVM,  L7TVM                                   
C  D7TPR RETURNS INNER PRODUCT OF TWO VECTORS.                          
C  L7IVM MULTIPLIES L**-1 TIMES A VECTOR.                               
C  L7TVM MULTIPLIES L**T TIMES A VECTOR.                                
C                                                                       
C  ***  INTRINSIC FUNCTIONS  ***                                        
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C--------------------------  LOCAL VARIABLES  --------------------------
C                                                                       
      INTEGER I                                                         
      REAL CS, CY, EPS, EPSRT, ONE, SHS, YS, THETA                      
C                                                                       
C  ***  DATA INITIALIZATIONS  ***                                       
C                                                                       
C/6                                                                     
C     DATA EPS/0.1E+0/, ONE/1.E+0/                                      
C/7                                                                     
      PARAMETER (EPS=0.1E+0, ONE=1.E+0)                                 
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      CALL  L7TVM(N, W, L, S)                                           
      SHS =  D7TPR(N, W, W)                                             
      YS =  D7TPR(N, Y, S)                                              
      IF (YS .GE. EPS*SHS) GO TO 10                                     
         THETA = (ONE - EPS) * SHS / (SHS - YS)                         
         EPSRT =  SQRT(EPS)                                             
         CY = THETA / (SHS * EPSRT)                                     
         CS = (ONE + (THETA-ONE)/EPSRT) / SHS                           
         GO TO 20                                                       
 10   CY = ONE / ( SQRT(YS) *  SQRT(SHS))                               
      CS = ONE / SHS                                                    
 20   CALL  L7IVM(N, Z, L, Y)                                           
      DO 30 I = 1, N                                                    
 30      Z(I) = CY * Z(I)  -  CS * W(I)                                 
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF  W7ZBF FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   NSFB(N, P, L, ALF, B, C, Y, CALCA, INC, IINC, IV,    
     1                  LIV, LV, V, UIPARM, URPARM, UFPARM)             
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING                   
C  ***  FINITE-DIFFERENCE DERIVATIVES.                                  
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
C/6                                                                     
C     INTEGER INC(IINC,P), IV(LIV), UIPARM(1)                           
C     REAL ALF(P), C(L), B(2,P), URPARM(1), V(LV), Y(N)                 
C/7                                                                     
      INTEGER INC(IINC,P), IV(LIV), UIPARM(*)                           
      REAL ALF(P), C(L), B(2,P), URPARM(*), V(LV), Y(N)                 
C/                                                                      
      EXTERNAL CALCA, UFPARM                                            
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C      N (IN)  NUMBER OF OBSERVATIONS.                                  
C      P (IN)  NUMBER OF NONLINEAR PARAMETERS TO BE ESTIMATED.          
C      L (IN)  NUMBER OF LINEAR PARAMETERS TO BE ESTIMATED.             
C    ALF (I/O) NONLINEAR PARAMETERS.                                    
C                 INPUT = INITIAL GUESS,                                
C                 OUTPUT = BEST ESTIMATE FOUND.                         
C      B (IN)  SIMBLE BOUNDS ON ALF.. B(1,I) .LE. ALF(I) .LE. B(2,I).   
C      C (OUT) LINEAR PARAMETERS (ESTIMATED).                           
C      Y (IN)  RIGHT-HAND SIDE VECTOR.                                  
C  CALCA (IN)  SUBROUTINE TO COMPUTE A MATRIX.                          
C    INC (IN)  INCIDENCE MATRIX OF DEPENDENCIES OF COLUMNS OF A ON      
C                 COMPONENTS OF ALF -- INC(I,J) = 1 MEANS COLUMN I      
C                 OF A DEPENDS ON ALF(J).                               
C   IINC (IN)  DECLARED LEAD DIMENSION OF INC.  MUST BE AT LEAST L+1.   
C     IV (I/O) INTEGER PARAMETER AND SCRATCH VECTOR.                    
C    LIV (IN)  LENGTH OF IV.  MUST BE AT LEAST                          
C                 122 + 2*M + 7*P + 2*L + MAX(L+1,6*P), WHERE  M  IS    
C                 THE NUMBER OF ONES IN INC.                            
C     LV (IN)  LENGTH OF V.  MUST BE AT LEAST                           
C                 105 + N*(2*L+6+P) + L*(L+3)/2 + P*(2*P + 22).         
C                 IF THE LAST ROW OF INC CONTAINS ONLY ZEROS, THEN LV   
C                 CAN BE 4*N LESS THAN JUST DESCRIBED.                  
C      V (I/O) FLOATING-POINT PARAMETER AND SCRATCH VECTOR.             
C UIPARM (I/O) INTEGER VECTOR PASSED WITHOUT CHANGE TO CALCA.           
C URPARM (I/O) FLOATING-POINT VECTOR PASSED WITHOUT CHANGE TO CALCA.    
C UFPARM (I/O) SUBROUTINE PASSED (WITHOUT HAVING BEEN CALLED) TO CALCA. 
C                                                                       
C                                                                       
C--------------------------  DECLARATIONS  ---------------------------- 
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET, DSM,  RNSGB, V2AXY, V7CPY,  V7SCL                 
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V VALUES.                           
C DSM...... DETERMINES EFFICIENT ORDER FOR FINITE DIFFERENCES.          
C  RNSGB... CARRIES OUT NL2SOL ALGORITHM.                               
C V2AXY.... ADDS A MULTIPLE OF ONE VECTOR TO ANOTHER.                   
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7SCL... SCALES AND COPIES ONE VECTOR TO ANOTHER.                    
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      LOGICAL PARTJ                                                     
      INTEGER A0, A1, AJ, ALP1, BWA1, D0, DA0, DA1, DAJ, GPTR1, GRP1,   
     1        GRP2, I, I1, IN0, IN1, IN2, INI, INLEN, IPNTR1, IV1, IWA1,
     2        IWALEN, J1, JN1, JPNTR1, K, L1, LP1, M, M0, NF, NG, NGRP0,
     3        NGRP1, NGRP2, RSAVE0, RSAVE1, RSVLEN, X0I, XSAVE0, XSAVE1 
      REAL DELTA, DI, H, XI, XI1                                        
      REAL NEGONE, ONE, ZERO                                            
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, COVREQ, D, DAMAT, DLTFDJ, GPTR, GRP, IN, IVNEED,    
     1        L1SAV, MAXGRP, MODE, MSAVE, NEXTIV, NEXTV, NFCALL, NFGCAL,
     2        PERM, RESTOR, TOOBIG, VNEED, XSAVE                        
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, COVREQ/15/, D/27/, DAMAT/114/, DLTFDJ/43/,        
C    1     GPTR/117/, GRP/118/, IN/112/, IVNEED/3/, L1SAV/111/,         
C    2     MAXGRP/116/, MODE/35/, MSAVE/115/, NEXTIV/46/, NEXTV/47/,    
C    3     NFCALL/6/, NFGCAL/7/, PERM/58/, RESTOR/9/, TOOBIG/2/,        
C    4     VNEED/4/, XSAVE/119/                                         
C/7                                                                     
      PARAMETER (AMAT=113, COVREQ=15, D=27, DAMAT=114, DLTFDJ=43,       
     1           GPTR=117, GRP=118, IN=112, IVNEED=3, L1SAV=111,        
     2           MAXGRP=116, MODE=35, MSAVE=115, NEXTIV=46, NEXTV=47,   
     3           NFCALL=6, NFGCAL=7, PERM=58, RESTOR=9, TOOBIG=2,       
     4           VNEED=4, XSAVE=119)                                    
C/                                                                      
      DATA NEGONE/-1.E+0/, ONE/1.E+0/, ZERO/0.E+0/                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      LP1 = L + 1                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 80             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 120                                        
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 120                       
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 50                                       
C                                                                       
C  ***  FRESH START ***                                                 
C                                                                       
      IF (IV(PERM) .LE. XSAVE) IV(PERM) = XSAVE + 1                     
C                                                                       
C  ***  CHECK INC, COUNT ITS NONZEROS                                   
C                                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         IF (B(1,I) .GE. B(2,I)) GO TO 40                               
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 80          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
            GO TO 40                                                    
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 80                 
 40      CONTINUE                                                       
C                                                                       
C     *** NOW L1 = 1 MEANS A HAS COLUMN L+1 ***                         
C                                                                       
C     *** COMPUTE STORAGE REQUIREMENTS ***                              
C                                                                       
      IWALEN = MAX0(LP1, 6*P)                                           
      INLEN = 2 * M                                                     
      IV(IVNEED) = IV(IVNEED) + INLEN + 3*P + L + IWALEN + 3            
      RSVLEN = 2 * L1 * N                                               
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + 2*N*L1 + RSVLEN + P                       
C                                                                       
 50   CALL  RNSGB(V, ALF, B, C, V, IV, IV, L, 1, N, LIV, LV, N, M, P, V,
     1            Y)                                                    
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(XSAVE) = IV(DAMAT) + N*L1                                      
      IV(NEXTV) = IV(XSAVE) + P + RSVLEN                                
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  DETERMINE HOW MANY GROUPS FOR FINITE DIFFERENCES                
C  ***  (SET UP TO CALL DSM)                                            
C                                                                       
      IN1 = IV(IN)                                                      
      JN1 = IN1 + M                                                     
      DO 70 K = 1, P                                                    
         IF (B(1,K) .GE. B(2,K)) GO TO 70                               
         DO 60 I = 1, LP1                                               
            IF (INC(I,K) .EQ. 0) GO TO 60                               
               IV(IN1) = I                                              
               IN1 = IN1 + 1                                            
               IV(JN1) = K                                              
               JN1 = JN1 + 1                                            
 60         CONTINUE                                                    
 70      CONTINUE                                                       
      IN1 = IV(IN)                                                      
      JN1 = IN1 + M                                                     
      IWA1 = IN1 + INLEN                                                
      NGRP1 = IWA1 + IWALEN                                             
      BWA1 = NGRP1 + P                                                  
      IPNTR1 = BWA1 + P                                                 
      JPNTR1 = IPNTR1 + L + 2                                           
      CALL DSM(LP1, P, M, IV(IN1), IV(JN1), IV(NGRP1), NG, K, I,        
     1         IV(IPNTR1), IV(JPNTR1), IV(IWA1), IWALEN, IV(BWA1))      
      IF (I .EQ. 1) GO TO 90                                            
         IV(1) = 69                                                     
         GO TO 50                                                       
 80   IV(1) = 66                                                        
      GO TO 50                                                          
C                                                                       
C  ***  SET UP GRP AND GPTR ARRAYS FOR COMPUTING FINITE DIFFERENCES     
C                                                                       
C  ***  THERE ARE NG GROUPS.  GROUP I CONTAINS ALF(GRP(J)) FOR          
C  ***  GPTR(I) .LE. J .LE. GPTR(I+1)-1.                                
C                                                                       
 90   IV(MAXGRP) = NG                                                   
      IV(GPTR) = IN1 + 2*L1                                             
      GPTR1 = IV(GPTR)                                                  
      IV(GRP) = GPTR1 + NG + 1                                          
      IV(NEXTIV) = IV(GRP) + P                                          
      GRP1 = IV(GRP)                                                    
      NGRP0 = NGRP1 - 1                                                 
      NGRP2 = NGRP0 + P                                                 
      DO 110 I = 1, NG                                                  
         IV(GPTR1) = GRP1                                               
         GPTR1 = GPTR1 + 1                                              
         DO 100 I1 = NGRP1, NGRP2                                       
            IF (IV(I1) .NE. I) GO TO 100                                
            K = I1 - NGRP0                                              
            IF (B(1,K) .GE. B(2,K)) GO TO 100                           
            IV(GRP1) = K                                                
            GRP1 = GRP1 + 1                                             
 100        CONTINUE                                                    
 110     CONTINUE                                                       
      IV(GPTR1) = GRP1                                                  
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
C  ***  INITIALIZE POINTERS  ***                                        
C                                                                       
 120  A1 = IV(AMAT)                                                     
      A0 = A1 - N                                                       
      DA1 = IV(DAMAT)                                                   
      DA0 = DA1 - N                                                     
      IN1 = IV(IN)                                                      
      IN0 = IN1 - 2                                                     
      L1 = IV(L1SAV)                                                    
      IN2 = IN1 + 2*L1 - 1                                              
      D0 = IV(D) - 1                                                    
      NG = IV(MAXGRP)                                                   
      XSAVE1 = IV(XSAVE)                                                
      XSAVE0 = XSAVE1 - 1                                               
      RSAVE1 = XSAVE1 + P                                               
      RSAVE0 = RSAVE1 + N                                               
      ALP1 = A1 + L*N                                                   
      DELTA = V(DLTFDJ)                                                 
      IV(COVREQ) = -IABS(IV(COVREQ))                                    
C                                                                       
 130  CALL  RNSGB(V(A1), ALF, B, C, V(DA1), IV(IN1), IV, L, L1, N, LIV, 
     1            LV, N, L1, P, V, Y)                                   
      IF (IV(1)-2) 140, 150, 999                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 140  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF, NF, V(A1), UIPARM, URPARM, UFPARM)       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      IF (L1 .LE. L) GO TO 130                                          
      IF (IV(RESTOR) .EQ. 2) CALL V7CPY(N, V(RSAVE0), V(RSAVE1))        
      CALL V7CPY(N, V(RSAVE1), V(ALP1))                                 
      GO TO 130                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 150  IF (L1 .GT. L .AND. IV(NFGCAL) .EQ. IV(NFCALL))                   
     1      CALL V7CPY(N, V(RSAVE0), V(RSAVE1))                         
      GPTR1 = IV(GPTR)                                                  
      DO 260 K = 1, NG                                                  
         CALL V7CPY(P, V(XSAVE1), ALF)                                  
         GRP1 = IV(GPTR1)                                               
         GRP2 = IV(GPTR1+1) - 1                                         
         GPTR1 = GPTR1 + 1                                              
         DO 180 I1 = GRP1, GRP2                                         
            I = IV(I1)                                                  
            XI = ALF(I)                                                 
            J1 = D0 + I                                                 
            DI = V(J1)                                                  
            IF (DI .LE. ZERO) DI = ONE                                  
            H = DELTA * AMAX1( ABS(XI), ONE/DI)                         
            IF (XI .LT. ZERO) GO TO 160                                 
               XI1 = XI + H                                             
               IF (XI1 .LE. B(2,I)) GO TO 170                           
               XI1 = XI - H                                             
               IF (XI1 .GE. B(1,I)) GO TO 170                           
               GO TO 190                                                
 160         XI1 = XI - H                                               
             IF (XI1 .GE. B(1,I)) GO TO 170                             
             XI1 = XI + H                                               
             IF (XI1 .LE. B(2,I)) GO TO 170                             
             GO TO 190                                                  
 170        X0I = XSAVE0 + I                                            
            V(X0I) = XI1                                                
 180        CONTINUE                                                    
         CALL CALCA(N, P, L, V(XSAVE1), NF, V(DA1), UIPARM, URPARM,     
     1              UFPARM)                                             
         IF (IV(NFGCAL) .GT. 0) GO TO 200                               
 190        IV(TOOBIG) = 1                                              
            GO TO 130                                                   
 200     JN1 = IN1                                                      
         DO 210 I = IN1, IN2                                            
 210        IV(I) = 0                                                   
         PARTJ = IV(MODE) .LE. P                                        
         DO 250 I1 = GRP1, GRP2                                         
            I = IV(I1)                                                  
            DO 240 J1 = 1, L1                                           
               IF (INC(J1,I) .EQ. 0) GO TO 240                          
               INI = IN0 + 2*J1                                         
               IV(INI) = I                                              
               IV(INI+1) = J1                                           
               X0I = XSAVE0 + I                                         
               H = ONE / (V(X0I) - ALF(I))                              
               DAJ = DA0 + J1*N                                         
               IF (PARTJ) GO TO 220                                     
C                 *** FULL FINITE DIFFERENCE FOR COV. AND REG. DIAG. ***
                  AJ = A0 + J1*N                                        
                  CALL V2AXY(N, V(DAJ), NEGONE, V(AJ), V(DAJ))          
                  GO TO 230                                             
 220           IF (J1 .GT. L)                                           
     1            CALL V2AXY(N, V(DAJ), NEGONE, V(RSAVE0), V(DAJ))      
 230           CALL  V7SCL(N, V(DAJ), H, V(DAJ))                        
 240           CONTINUE                                                 
 250        CONTINUE                                                    
         IF (K .GE. NG) GO TO 270                                       
         IV(1) = -2                                                     
         CALL  RNSGB(V(A1), ALF, B, C, V(DA1), IV(IN1), IV, L, L1, N,   
     1               LIV, LV, N, L1, P, V, Y)                           
         IF (-2 .NE. IV(1)) GO TO 999                                   
 260     CONTINUE                                                       
 270  IV(1) = 2                                                         
      GO TO 130                                                         
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF   NSFB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE   NSGB(N, P, L, ALF, B, C, Y, CALCA, CALCB, INC, IINC, 
     1                  IV, LIV, LV, V, UIPARM, URPARM, UFPARM)         
C                                                                       
C  ***  SOLVE SEPARABLE NONLINEAR LEAST SQUARES USING  ***              
C  ***  ANALYTICALLY COMPUTED DERIVATIVES.             ***              
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER IINC, L, LIV, LV, N, P                                    
C/6                                                                     
C     INTEGER INC(IINC,P), IV(LIV), UIPARM(1)                           
C     REAL ALF(P), B(2,P), C(L), URPARM(1), V(LV), Y(N)                 
C/7                                                                     
      INTEGER INC(IINC,P), IV(LIV), UIPARM(*)                           
      REAL ALF(P), B(2,P), C(L), URPARM(*), V(LV), Y(N)                 
C/                                                                      
      EXTERNAL CALCA, CALCB, UFPARM                                     
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),   NSGB ATTEMPTS TO COMPUTE A LEAST SQUARES FIT           
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )) ,                      
C                       I=1    I             I                          
C                                                                       
C SUBJECT TO THE SIMPLE BOUND CONSTRAINTS                               
C B(1,I) .LE. ALF(I) .LE. B(2,I), C I = 1(1)P.                          
C                                                                       
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C--------------------------  PARAMETER USAGE  ------------------------- 
C                                                                       
C INPUT PARAMETERS                                                      
C                                                                       
C N     INTEGER        NUMBER OF OBSERVATIONS (MUST BE .GE. MAX(L,P)).  
C                                                                       
C P     INTEGER        NUMBER OF NONLINEAR PARAMETERS (MUST BE .GE. 1). 
C                                                                       
C L     INTEGER        NUMBER OF LINEAR PARAMETERS (MUST BE .GE. 0).    
C                                                                       
C ALF   D.P. ARRAY     P VECTOR = INITIAL ESTIMATE OF THE NONLINEAR     
C                      PARAMETERS.                                      
C                                                                       
C CALCA SUBROUTINE     USER PROVIDED FUNCTION TO CALCULATE THE MODEL    
C                      (I.E., TO CALCULATE PHI) -- SEE THE NOTE BELOW   
C                      ON THE CALLING SEQUENCE FOR CALCA.               
C                      CALCA MUST BE DECLARED EXTERNAL IN THE CALLING   
C                      PROGRAM.                                         
C                                                                       
C CALCB SUBROUTINE     USER PROVIDED FUNCTION TO CALCULATE THE DERIVA-  
C                      TIVE OF THE MODEL (I.E., OF PHI) WITH RESPECT TO 
C                      ALF -- SEE THE NOTE BELOW ON THE CALLING         
C                      SEQUENCE FOR CALCB.  CALCB MUST BE DECLARED      
C                      EXTERNAL IN THE CALLING PROGRAM.                 
C                                                                       
C Y     D.P. ARRAY     VECTOR OF OBSERVATIONS.                          
C                                                                       
C INC   INTEGER ARRAY  A 2 DIM. ARRAY OF DIMENSION AT LEAST (L+1,P)     
C                      INDICATING THE POSITION OF THE NONLINEAR PARA-   
C                      METERS IN THE MODEL.  SET INC(J,K) = 1 IF ALF(K) 
C                      APPEARS IN PHI(J).  OTHERWISE SET INC(J,K) = 0.  
C                      IF PHI((L+1)) IS NOT IN THE MODEL, SET THE L+1ST 
C                      ROW OF INC TO ALL ZEROS.  EVERY COLUMN OF INC    
C                      MUST CONTAIN AT LEAST ONE 1.                     
C                                                                       
C IINC   INTEGER       DECLARED ROW DIMENSION OF INC, WHICH MUST BE AT  
C                      LEAST L+1.                                       
C                                                                       
C IV     INTEGER       ARRAY OF LENGTH AT LEAST LIV THAT CONTAINS       
C                      VARIOUS PARAMETERS FOR THE SUBROUTINE, SUCH AS   
C                      THE ITERATION AND FUNCTION EVALUATION LIMITS AND 
C                      SWITCHES THAT CONTROL PRINTING.  THE INPUT COM-  
C                      PONENTS OF IV ARE DESCRIBED IN DETAIL IN THE     
C                      PORT OPTIMIZATION DOCUMENTATION.                 
C                         IF IV(1)=0 ON INPUT, THEN DEFAULT PARAMETERS  
C                      ARE SUPPLIED TO IV AND V.  THE CALLER MAY SUPPLY 
C                      NONDEFAULT PARAMETERS TO IV AND V BY EXECUTING A 
C                      CALL IVSET(1,IV,LIV,LV,V) AND THEN ASSIGNING     
C                      NONDEFAULT VALUES TO THE APPROPRIATE COMPONENTS  
C                      OF IV AND V BEFORE CALLING   NSGB.               
C                                                                       
C LIV     INTEGER      LENGTH OF IV.  MUST BE AT LEAST                  
C                      115 + 4*P + L + 2*M,                             
C                      WHERE  M  IS THE NUMBER OF ONES IN INC.          
C                                                                       
C LV      INTEGER      LENGTH OF V.  MUST BE AT LEAST                   
C                      105 + N*(L+M+P+3) + L*(L+3)/2 + P*(2*P+21),      
C                      WHERE  M  IS AS FOR LIV (SEE ABOVE).  IF THE     
C                      LAST ROW OF INC CONTAINS ONLY ZEROS, THEN LV     
C                      CAN BE N LESS THAN JUST DESCRIBED.               
C                                                                       
C V       D.P. ARRAY   WORK AND PARAMETER ARRAY OF LENGTH AT LEAST LV   
C                      THAT CONTAINS SUCH INPUT COMPONENTS AS THE       
C                      CONVERGENCE TOLERANCES.  THE INPUT COMPONENTS OF 
C                      V MAY BE SUPPLIED AS FOR IV (SEE ABOVE).  NOTE   
C                      THAT V(35) CONTAINS THE INITIAL STEP BOUND,      
C                      WHICH, IF TOO LARGE, MAY LEAD TO OVERFLOW.       
C                                                                       
C UIPARM INTEGER ARRAY SCRATCH SPACE FOR USER TO SEND INFORMATION       
C                      TO CALCA AND CALCB.                              
C                                                                       
C URPARM D.P. ARRAY    SCRATCH SPACE FOR USER TO SEND INFORMATION       
C                      TO CALCA AND CALCB.                              
C                                                                       
C UFPARM EXTERNAL      SUBROUTINE SENT TO CALCA AND CALCB FOR THEIR     
C                      USE.  NOTE THAT THE SUBROUTINE PASSED FOR UFPARM 
C                      MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.
C                                                                       
C                                                                       
C OUTPUT PARAMETERS                                                     
C                                                                       
C ALF    D.P. ARRAY    FINAL NONLINEAR PARAMETERS.                      
C                                                                       
C C      D.P. ARRAY    L VECTOR OF LINEAR PARAMETERS -- NOTE THAT NO    
C                      INITIAL GUESS FOR C IS REQUIRED.                 
C                                                                       
C IV                   IV(1) CONTAINS A RETURN CODE DESCRIBED IN THE    
C                      PORT OPTIMIZATION DOCUMENTATION.  IF IV(1) LIES  
C                      BETWEEN 3 AND 7, THEN THE ALGORITHM HAS          
C                      CONVERGED (BUT IV(1) = 7 INDICATES POSSIBLE      
C                      TROUBLE WITH THE MODEL).  IV(1) = 9 OR 10 MEANS  
C                      FUNCTION EVALUATION OR ITERATION LIMIT REACHED.  
C                      IV(1) = 66 MEANS BAD PARAMETERS (INCLUDING A     
C                      COLUMN OF ZEROS IN INC).  NOTE THAT THE          
C                      ALGORITHM CAN BE RESTARTED AFTER ANY RETURN WITH 
C                      IV(1) .LT. 12 -- SEE THE PORT DOCUMENTATION.     
C                                                                       
C V                    VARIOUS ITEMS OF INTEREST, INCLUDING THE NORM OF 
C                      THE GRADIENT(1) AND THE FUNCTION VALUE(10).  SEE 
C                      THE PORT DOCUMENTATION FOR A COMPLETE LIST.      
C                                                                       
C                                                                       
C                                                                       
C PARAMETERS FOR CALCA(N,P,L,ALF,NF,PHI, UIPARM,URPARM,UFPARM)          
C                                                                       
C N,L,P,ALF ARE INPUT PARAMETERS AS DESCRIBED ABOVE                     
C                                                                       
C PHI    D.P. ARRAY  N*(L+1) ARRAY WHOSE COLUMNS CONTAIN THE TERMS OF   
C                    THE MODEL.  CALCA MUST EVALUATE PHI(ALF) AND STORE 
C                    THE RESULT IN PHI.  IF THE (L+1)ST TERM IS NOT IN  
C                    THE MODEL, THEN NOTHING SHOULD BE STORED IN THE    
C                    (L+1)ST COLUMN OF PHI.                             
C                                                                       
C NF     INTEGER     CURRENT INVOCATION COUNT FOR CALCA.  IF PHI CANNOT 
C                    BE EVALUATED AT ALF (E.G. BECAUSE AN ARGUMENT TO   
C                    AN INTRINSIC FUNCTION IS OUT OF RANGE), THEN CALCA 
C                    SHOULD SIMPLY SET NF TO 0 AND RETURN.  THIS        
C                    TELLS THE ALGORITHM TO TRY A SMALLER STEP.         
C                                                                       
C UIPARM,URPARM,UFPARM ARE AS DESCRIBED ABOVE                           
C                                                                       
C N.B. THE DEPENDENT VARIABLE T IS NOT EXPLICITLY PASSED.  IF REQUIRED, 
C IT MAY BE PASSED IN UIPARM OR URPARM OR STORED IN NAMED COMMON.       
C                                                                       
C                                                                       
C PARAMETERS FOR CALCB(N,P,L,ALF,NF,DER, UIPARM,URPARM,UFPARM)          
C                                                                       
C N,P,L,ALF,NF,UIPARM,URPARM,UFPARM ARE AS FOR CALCA                    
C                                                                       
C DER   D.P. ARRAY   N*M ARRAY, WHERE M IS THE NUMBER OF ONES IN INC.   
C                    CALCB MUST SET DER TO THE DERIVATIVES OF THE MODEL 
C                    WITH RESPECT TO ALF.  IF THE MODEL HAS K TERMS THAT
C                    DEPEND ON ALF(I), THEN DER WILL HAVE K CONSECUTIVE 
C                    COLUMNS OF DERIVATIVES WITH RESPECT TO ALF(I).  THE
C                    COLUMNS OF DER CORRESPOND TO THE ONES IN INC WHEN  
C                    ONE TRAVELS THROUGH INC BY COLUMNS.  FOR EXAMPLE,  
C                    IF INC HAS THE FORM...                             
C                      1  1  0                                          
C                      0  1  0                                          
C                      1  0  0                                          
C                      0  0  1                                          
C                    THEN THE FIRST TWO COLUMNS OF DER ARE FOR THE      
C                    DERIVATIVES OF COLUMNS 1 AND 3 OF PHI WITH RESPECT 
C                    TO ALF(1), COLUMNS 3 AND 4 OF DER ARE FOR THE      
C                    DERIVATIVES OF COLUMNS 1 AND 2 OF PHI WITH RESPECT 
C                    TO ALF(2), AND COLUMN 5 OF DER IS FOR THE DERIVA-  
C                    TIVE OF COLUMN 4 OF PHI WITH RESPECT TO ALF(3).    
C                    MORE SPECIFICALLY, DER(I,2) IS FOR THE DERIVATIVE  
C                    OF PHI(I,3) WITH RESPECT TO ALF(1) AND DER(I,5) IS 
C                    FOR THE DERIVATIVE OF PHI(I,4) WITH RESPECT TO     
C                    ALF(3) (FOR I = 1,2,...,N).                        
C                       THE VALUE OF ALF PASSED TO CALCB IS THE SAME AS 
C                    THAT PASSED TO CALCA THE LAST TIME IT WAS CALLED.  
C                    (IF DER CANNOT BE EVALUATED, THEN CALCB SHOULD SET 
C                    NF TO 0.  THIS WILL CAUSE AN ERROR RETURN.)        
C                                                                       
C N.B. DER IS FOR DERIVATIVES WITH RESPECT TO ALF, NOT T.               
C                                                                       
C------------------------------  NOTES  ------------------------------- 
C                                                                       
C      THIS PROGRAM WAS WRITTEN BY LINDA KAUFMAN AT BELL LABS, MURRAY   
C HILL, N.J. IN 1977 AND EXTENSIVELY REVISED BY HER AND DAVID GAY IN    
C 1980, 1981, 1983, 1984.  THE WORK OF DAVID GAY WAS SUPPORTED IN PART  
C BY NATIONAL SCIENCE FOUNDATION GRANT MCS-7906671.                     
C                                                                       
C--------------------------  DECLARATIONS  ---------------------------- 
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      EXTERNAL IVSET,  RNSGB                                            
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V VALUES.                           
C  RNSGB... CARRIES OUT NL2SOL ALGORITHM.                               
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER A1, DA1, I, IN1, IV1, K, L1, LP1, M, M0, NF               
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AMAT, DAMAT, IN, IVNEED, L1SAV, MSAVE, NEXTIV,            
     1        NEXTV, NFCALL, NFGCAL, PERM, TOOBIG, VNEED                
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AMAT/113/, DAMAT/114/, IN/112/, IVNEED/3/, L1SAV/111/,       
C    1     MSAVE/115/, NEXTIV/46/, NEXTV/47/, NFCALL/6/, NFGCAL/7/,     
C    2     PERM/58/, TOOBIG/2/, VNEED/4/                                
C/7                                                                     
      PARAMETER (AMAT=113, DAMAT=114, IN=112, IVNEED=3, L1SAV=111,      
     1           MSAVE=115, NEXTIV=46, NEXTV=47, NFCALL=6, NFGCAL=7,    
     2           PERM=58, TOOBIG=2, VNEED=4)                            
C/                                                                      
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IF (P .LE. 0 .OR. L .LT. 0 .OR. IINC .LE. L) GO TO 50             
      IV1 = IV(1)                                                       
      IF (IV1 .EQ. 14) GO TO 90                                         
      IF (IV1 .GT. 2 .AND. IV1 .LT. 12) GO TO 90                        
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 60                                       
      IF (IV(PERM) .LE. MSAVE) IV(PERM) = MSAVE + 1                     
      LP1 = L + 1                                                       
      L1 = 0                                                            
      M = 0                                                             
      DO 40 I = 1, P                                                    
         M0 = M                                                         
         IF (L .EQ. 0) GO TO 20                                         
         DO 10 K = 1, L                                                 
            IF (INC(K,I) .LT. 0 .OR. INC(K,I) .GT. 1) GO TO 50          
            IF (INC(K,I) .EQ. 1) M = M + 1                              
 10         CONTINUE                                                    
 20      IF (INC(LP1,I) .NE. 1) GO TO 30                                
            M = M + 1                                                   
            L1 = 1                                                      
 30      IF (M .EQ. M0 .OR. INC(LP1,I) .LT. 0                           
     1                 .OR. INC(LP1,I) .GT. 1) GO TO 50                 
 40      CONTINUE                                                       
C                                                                       
      IV(IVNEED) = IV(IVNEED) + 2*M                                     
      L1 = L + L1                                                       
      IV(VNEED) = IV(VNEED) + N*(L1+M)                                  
      GO TO 60                                                          
C                                                                       
 50   IV(1) = 66                                                        
C                                                                       
 60   CALL  RNSGB(V, ALF, B, C, V, IV, IV, L, 1, N, LIV, LV, N, M, P, V,
     1            Y)                                                    
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IN) = IV(NEXTIV)                                               
      IV(NEXTIV) = IV(IN) + 2*M                                         
      IV(AMAT) = IV(NEXTV)                                              
      IV(DAMAT) = IV(AMAT) + N*L1                                       
      IV(NEXTV) = IV(DAMAT) + N*M                                       
      IV(L1SAV) = L1                                                    
      IV(MSAVE) = M                                                     
C                                                                       
C  ***  SET UP IN ARRAY  ***                                            
C                                                                       
      IN1 = IV(IN)                                                      
      DO 80 I = 1, P                                                    
         DO 70 K = 1, LP1                                               
            IF (INC(K,I) .EQ. 0) GO TO 70                               
               IV(IN1) = I                                              
               IV(IN1+1) = K                                            
               IN1 = IN1 + 2                                            
 70         CONTINUE                                                    
 80      CONTINUE                                                       
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 90   A1 = IV(AMAT)                                                     
      DA1 = IV(DAMAT)                                                   
      IN1 = IV(IN)                                                      
      L1 = IV(L1SAV)                                                    
      M = IV(MSAVE)                                                     
C                                                                       
 100  CALL  RNSGB(V(A1), ALF, B, C, V(DA1), IV(IN1), IV, L, L1, N, LIV, 
     1            LV, N, M, P, V, Y)                                    
      IF (IV(1)-2) 110, 120, 999                                        
C                                                                       
C  ***  NEW FUNCTION VALUE (R VALUE) NEEDED  ***                        
C                                                                       
 110  NF = IV(NFCALL)                                                   
      CALL CALCA(N, P, L, ALF, NF, V(A1), UIPARM, URPARM, UFPARM)       
      IF (NF .LE. 0) IV(TOOBIG) = 1                                     
      GO TO 100                                                         
C                                                                       
C  ***  COMPUTE DR = GRADIENT OF R COMPONENTS  ***                      
C                                                                       
 120  CALL CALCB(N, P, L, ALF, IV(NFGCAL), V(DA1), UIPARM, URPARM,      
     1           UFPARM)                                                
      IF (IV(NFGCAL) .EQ. 0) IV(TOOBIG) = 1                             
      GO TO 100                                                         
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF   NSGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  RNSGB(A, ALF, B, C, DA, IN, IV, L, L1, LA, LIV, LV,   
     1                  N, NDA, P, V, Y)                                
C                                                                       
C  ***  ITERATION DRIVER FOR SEPARABLE NONLINEAR LEAST SQUARES,         
C  ***  WITH SIMPLE BOUNDS ON THE NONLINEAR VARIABLES.                  
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER L, L1, LA, LIV, LV, N, NDA, P                             
      INTEGER IN(2,NDA), IV(LIV)                                        
C     DIMENSION UIPARM(*)                                               
      REAL A(LA,L1), ALF(P), B(2,P), C(L), DA(LA,NDA),                  
     1                 V(LV), Y(N)                                      
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C GIVEN A SET OF N OBSERVATIONS Y(1)....Y(N) OF A DEPENDENT VARIABLE    
C T(1)...T(N),  RNSGB ATTEMPTS TO COMPUTE A LEAST SQUARES FIT           
C TO A FUNCTION  ETA  (THE MODEL) WHICH IS A LINEAR COMBINATION         
C                                                                       
C                  L                                                    
C ETA(C,ALF,T) =  SUM C * PHI(ALF,T) +PHI   (ALF,T)                     
C                 J=1  J     J           L+1                            
C                                                                       
C OF NONLINEAR FUNCTIONS PHI(J) DEPENDENT ON T AND ALF(1),...,ALF(P)    
C (.E.G. A SUM OF EXPONENTIALS OR GAUSSIANS).  THAT IS, IT DETERMINES   
C NONLINEAR PARAMETERS ALF WHICH MINIMIZE                               
C                                                                       
C                   2    N                      2                       
C     NORM(RESIDUAL)  = SUM  (Y - ETA(C,ALF,T )) ,                      
C                       I=1    I             I                          
C                                                                       
C SUBJECT TO THE SIMPLE BOUND CONSTRAINTS                               
C B(1,I) .LE. ALF(I) .LE. B(2,I), I = 1(1)P.                            
C                                                                       
C THE (L+1)ST TERM IS OPTIONAL.                                         
C                                                                       
C                                                                       
C  ***  PARAMETERS  ***                                                 
C                                                                       
C      A (IN)  MATRIX PHI(ALF,T) OF THE MODEL.                          
C    ALF (I/O) NONLINEAR PARAMETERS.                                    
C                 INPUT = INITIAL GUESS,                                
C                 OUTPUT = BEST ESTIMATE FOUND.                         
C      C (OUT) LINEAR PARAMETERS (ESTIMATED).                           
C     DA (IN)  DERIVATIVES OF COLUMNS OF A WITH RESPECT TO COMPONENTS   
C                 OF ALF, AS SPECIFIED BY THE IN ARRAY...               
C     IN (IN)  WHEN  RNSGB IS CALLED WITH IV(1) = 2 OR -2, THEN FOR     
C                 I = 1(1)NDA, COLUMN I OF DA IS THE PARTIAL            
C                 DERIVATIVE WITH RESPECT TO ALF(IN(1,I)) OF COLUMN     
C                 IN(2,I) OF A, UNLESS IV(1,I) IS NOT POSITIVE (IN      
C                 WHICH CASE COLUMN I OF DA IS IGNORED.  IV(1) = -2     
C                 MEANS THERE ARE MORE COLUMNS OF DA TO COME AND        
C                  RNSGB SHOULD RETURN FOR THEM.                        
C     IV (I/O) INTEGER PARAMETER AND SCRATCH VECTOR.   RNSGB RETURNS    
C                 WITH IV(1) = 1 WHEN IT WANTS A TO BE EVALUATED AT     
C                 ALF AND WITH IV(1) = 2 WHEN IT WANTS DA TO BE         
C                 EVALUATED AT ALF.  WHEN CALLED WITH IV(1) = -2        
C                 (AFTER A RETURN WITH IV(1) = 2),  RNSGB RETURNS       
C                 WITH IV(1) = -2 TO GET MORE COLUMNS OF DA.            
C      L (IN)  NUMBER OF LINEAR PARAMETERS TO BE ESTIMATED.             
C     L1 (IN)  L+1 IF PHI(L+1) IS IN THE MODEL, L IF NOT.               
C     LA (IN)  LEAD DIMENSION OF A.  MUST BE AT LEAST N.                
C    LIV (IN)  LENGTH OF IV.  MUST BE AT LEAST 110 + L + 4*P.           
C     LV (IN)  LENGTH OF V.  MUST BE AT LEAST                           
C                 105 + 2*N + L*(L+3)/2 + P*(2*P + 21 + N).             
C      N (IN)  NUMBER OF OBSERVATIONS.                                  
C    NDA (IN)  NUMBER OF COLUMNS IN DA AND IN.                          
C      P (IN)  NUMBER OF NONLINEAR PARAMETERS TO BE ESTIMATED.          
C      V (I/O) FLOATING-POINT PARAMETER AND SCRATCH VECTOR.             
C      Y (IN)  RIGHT-HAND SIDE VECTOR.                                  
C                                                                       
C                                                                       
C  ***  EXTERNAL SUBROUTINES  ***                                       
C                                                                       
      REAL  L7SVX,  L7SVN,  R7MDC                                       
      EXTERNAL IVSET, ITSUM,  L7ITV,  L7SVX,  L7SVN,  RN2GB,  Q7APL,    
     1         Q7RFH,  R7MDC,  S7CPR, V2AXY, V7CPY, V7PRM,  V7SCP       
C                                                                       
C IVSET.... SUPPLIES DEFAULT PARAMETER VALUES.                          
C ITSUM.... PRINTS ITERATION SUMMARY, INITIAL AND FINAL ALF.            
C  L7ITV... APPLIES INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.  
C  L7SVX... ESTIMATES LARGEST SING. VALUE OF LOWER TRIANG. MATRIX.      
C  L7SVN... ESTIMATES SMALLEST SING. VALUE OF LOWER TRIANG. MATRIX.     
C  RN2GB... UNDERLYING NONLINEAR LEAST-SQUARES SOLVER.                  
C  Q7APL... APPLIES HOUSEHOLDER TRANSFORMS STORED BY Q7RFH.             
C Q7RFH.... COMPUTES QR FACT. VIA HOUSEHOLDER TRANSFORMS WITH PIVOTING. 
C  R7MDC... RETURNS MACHINE-DEP. CONSTANTS.                             
C  S7CPR... PRINTS LINEAR PARAMETERS AT SOLUTION.                       
C V2AXY.... ADDS MULTIPLE OF ONE VECTOR TO ANOTHER.                     
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C V7PRM.... PERMUTES VECTOR.                                            
C  V7SCL... SCALES AND COPIES ONE VECTOR TO ANOTHER.                    
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER AR1, CSAVE1, D1, DR1, DR1L, I, I1,                        
     1        IPIV1, IER, IV1, J1, JLEN, K, LL1O2, MD, N1,              
     2        NML, NRAN, R1, R1L, RD1                                   
      REAL SINGTL, T                                                    
      REAL MACHEP, NEGONE, SNGFAC, ZERO                                 
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AR, CSAVE, D, IERS, IPIVS, IV1SAV,                        
     2        IVNEED, J, MODE, NEXTIV, NEXTV,                           
     2        NFCALL, NFGCAL, PERM, R,                                  
     3        REGD, REGD0, RESTOR, TOOBIG, VNEED                        
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA AR/110/, CSAVE/105/, D/27/, IERS/108/, IPIVS/109/,           
C    1     IV1SAV/104/, IVNEED/3/, J/70/, MODE/35/, NEXTIV/46/,         
C    2     NEXTV/47/, NFCALL/6/, NFGCAL/7/, PERM/58/, R/61/, REGD/67/,  
C    3     REGD0/82/, RESTOR/9/, TOOBIG/2/, VNEED/4/                    
C/7                                                                     
      PARAMETER (AR=110, CSAVE=105, D=27, IERS=108, IPIVS=109,          
     1           IV1SAV=104, IVNEED=3, J=70, MODE=35, NEXTIV=46,        
     2           NEXTV=47, NFCALL=6, NFGCAL=7, PERM=58, R=61, REGD=67,  
     3           REGD0=82, RESTOR=9, TOOBIG=2, VNEED=4)                 
C/                                                                      
      DATA MACHEP/-1.E+0/, NEGONE/-1.E+0/, SNGFAC/1.E+2/, ZERO/0.E+0/   
C                                                                       
C++++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++ 
C                                                                       
C                                                                       
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      N1 = 1                                                            
      NML = N                                                           
      IV1 = IV(1)                                                       
      IF (IV1 .LE. 2) GO TO 20                                          
C                                                                       
C  ***  CHECK INPUT INTEGERS  ***                                       
C                                                                       
      IF (P .LE. 0) GO TO 240                                           
      IF (L .LT. 0) GO TO 240                                           
      IF (N .LE. L) GO TO 240                                           
      IF (LA .LT. N) GO TO 240                                          
      IF (IV1 .LT. 12) GO TO 20                                         
      IF (IV1 .EQ. 14) GO TO 20                                         
      IF (IV1 .EQ. 12) IV(1) = 13                                       
C                                                                       
C  ***  FRESH START -- COMPUTE STORAGE REQUIREMENTS  ***                
C                                                                       
      IF (IV(1) .GT. 16) GO TO 240                                      
      LL1O2 = L*(L+1)/2                                                 
      JLEN = N*P                                                        
      I = L + P                                                         
      IF (IV(1) .NE. 13) GO TO 10                                       
         IV(IVNEED) = IV(IVNEED) + L                                    
         IV(VNEED) = IV(VNEED) + P + 2*N + JLEN + LL1O2 + L             
 10   IF (IV(PERM) .LE. AR) IV(PERM) = AR + 1                           
      CALL  RN2GB(B, V, V, IV, LIV, LV, N, N, N1, NML, P, V, V, V, ALF) 
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(IPIVS) = IV(NEXTIV)                                            
      IV(NEXTIV) = IV(NEXTIV) + L                                       
      IV(D) = IV(NEXTV)                                                 
      IV(REGD0) = IV(D) + P                                             
      IV(AR) = IV(REGD0) + N                                            
      IV(CSAVE) = IV(AR) + LL1O2                                        
      IV(J) = IV(CSAVE) + L                                             
      IV(R) = IV(J) + JLEN                                              
      IV(NEXTV) = IV(R) + N                                             
      IV(IERS) = 0                                                      
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
C  ***  SET POINTERS INTO IV AND V  ***                                 
C                                                                       
 20   AR1 = IV(AR)                                                      
      D1 = IV(D)                                                        
      DR1 = IV(J)                                                       
      DR1L = DR1 + L                                                    
      R1 = IV(R)                                                        
      R1L = R1 + L                                                      
      RD1 = IV(REGD0)                                                   
      CSAVE1 = IV(CSAVE)                                                
      NML = N - L                                                       
      IF (IV1 .LE. 2) GO TO 50                                          
C                                                                       
 30   CALL  RN2GB(B, V(D1), V(DR1L), IV, LIV, LV, NML, N, N1, NML, P,   
     1            V(R1L), V(RD1), V, ALF)                               
      IF (IABS(IV(RESTOR)-2) .EQ. 1 .AND. L .GT. 0)                     
     1        CALL V7CPY(L, C, V(CSAVE1))                               
      IV1 = IV(1)                                                       
      IF (IV1-2) 40, 150, 230                                           
C                                                                       
C  ***  NEW FUNCTION VALUE (RESIDUAL) NEEDED  ***                       
C                                                                       
 40   IV(IV1SAV) = IV(1)                                                
      IV(1) = IABS(IV1)                                                 
      IF (IV(RESTOR) .EQ. 2 .AND. L .GT. 0) CALL V7CPY(L, V(CSAVE1), C) 
      GO TO 999                                                         
C                                                                       
C  ***  COMPUTE NEW RESIDUAL OR GRADIENT  ***                           
C                                                                       
 50   IV(1) = IV(IV1SAV)                                                
      MD = IV(MODE)                                                     
      IF (MD .LE. 0) GO TO 60                                           
         NML = N                                                        
         DR1L = DR1                                                     
         R1L = R1                                                       
 60   IF (IV(TOOBIG) .NE. 0) GO TO 30                                   
      IF (IABS(IV1) .EQ. 2) GO TO 170                                   
C                                                                       
C  ***  COMPUTE NEW RESIDUAL  ***                                       
C                                                                       
      IF (L1 .LE. L) CALL V7CPY(N, V(R1), Y)                            
      IF (L1 .GT. L) CALL V2AXY(N, V(R1), NEGONE, A(1,L1), Y)           
      IF (MD .GT. 0) GO TO 120                                          
      IER = 0                                                           
      IF (L .LE. 0) GO TO 110                                           
      LL1O2 = L * (L + 1) / 2                                           
      IPIV1 = IV(IPIVS)                                                 
      CALL Q7RFH(IER, IV(IPIV1), N, LA, 0, L, A, V(AR1), LL1O2, C)      
C                                                                       
C *** DETERMINE NUMERICAL RANK OF A ***                                 
C                                                                       
      IF (MACHEP .LE. ZERO) MACHEP =  R7MDC(3)                          
      SINGTL = SNGFAC * FLOAT(MAX0(L,N)) * MACHEP                       
      K = L                                                             
      IF (IER .NE. 0) K = IER - 1                                       
 70   IF (K .LE. 0) GO TO 90                                            
         T =  L7SVX(K, V(AR1), C, C)                                    
         IF (T .GT. ZERO) T =  L7SVN(K, V(AR1), C, C) / T               
         IF (T .GT. SINGTL) GO TO 80                                    
         K = K - 1                                                      
         GO TO 70                                                       
C                                                                       
C *** RECORD RANK IN IV(IERS)... IV(IERS) = 0 MEANS FULL RANK,          
C *** IV(IERS) .GT. 0 MEANS RANK IV(IERS) - 1.                          
C                                                                       
 80   IF (K .GE. L) GO TO 100                                           
 90      IER = K + 1                                                    
         CALL  V7SCP(L-K, C(K+1), ZERO)                                 
 100  IV(IERS) = IER                                                    
      IF (K .LE. 0) GO TO 110                                           
C                                                                       
C *** APPLY HOUSEHOLDER TRANSFORMATONS TO RESIDUALS...                  
C                                                                       
      CALL  Q7APL(LA, N, K, A, V(R1), IER)                              
C                                                                       
C *** COMPUTING C NOW MAY SAVE A FUNCTION EVALUATION AT                 
C *** THE LAST ITERATION.                                               
C                                                                       
      CALL  L7ITV(K, C, V(AR1), V(R1))                                  
      CALL V7PRM(L, IV(IPIV1), C)                                       
C                                                                       
 110  IF(IV(1) .LT. 2) GO TO 220                                        
      GO TO 999                                                         
C                                                                       
C                                                                       
C  ***  RESIDUAL COMPUTATION FOR F.D. HESSIAN  ***                      
C                                                                       
 120  IF (L .LE. 0) GO TO 140                                           
      DO 130 I = 1, L                                                   
 130     CALL V2AXY(N, V(R1), -C(I), A(1,I), V(R1))                     
 140  IF (IV(1) .GT. 0) GO TO 30                                        
         IV(1) = 2                                                      
         GO TO 160                                                      
C                                                                       
C  ***  NEW GRADIENT (JACOBIAN) NEEDED  ***                             
C                                                                       
 150  IV(IV1SAV) = IV1                                                  
      IF (IV(NFGCAL) .NE. IV(NFCALL)) IV(1) = 1                         
 160  CALL  V7SCP(N*P, V(DR1), ZERO)                                    
      GO TO 999                                                         
C                                                                       
C  ***  COMPUTE NEW JACOBIAN  ***                                       
C                                                                       
 170  IF (NDA .LE. 0) GO TO 240                                         
      DO 180 I = 1, NDA                                                 
         I1 = IN(1,I) - 1                                               
         IF (I1 .LT. 0) GO TO 180                                       
         J1 = IN(2,I)                                                   
         K = DR1 + I1*N                                                 
         T = NEGONE                                                     
         IF (J1 .LE. L) T = -C(J1)                                      
         CALL V2AXY(N, V(K), T, DA(1,I), V(K))                          
 180     CONTINUE                                                       
      IF (IV1 .EQ. 2) GO TO 190                                         
         IV(1) = IV1                                                    
         GO TO 999                                                      
 190  IF (L .LE. 0) GO TO 30                                            
      IF (MD .GT. 0) GO TO 30                                           
      K = DR1                                                           
      IER = IV(IERS)                                                    
      NRAN = L                                                          
      IF (IER .GT. 0) NRAN = IER - 1                                    
      IF (NRAN .LE. 0) GO TO 210                                        
      DO 200 I = 1, P                                                   
         CALL  Q7APL(LA, N, NRAN, A, V(K), IER)                         
         K = K + N                                                      
 200     CONTINUE                                                       
 210  CALL V7CPY(L, V(CSAVE1), C)                                       
 220  IF (IER .EQ. 0) GO TO 30                                          
C                                                                       
C     *** ADJUST SUBSCRIPTS DESCRIBING R AND DR...                      
C                                                                       
         NRAN = IER - 1                                                 
         DR1L = DR1 + NRAN                                              
         NML = N - NRAN                                                 
         R1L = R1 + NRAN                                                
         GO TO 30                                                       
C                                                                       
C  ***  CONVERGENCE OR LIMIT REACHED  ***                               
C                                                                       
 230  IF (IV(REGD) .EQ. 1) IV(REGD) = RD1                               
      IF (IV(1) .LE. 11) CALL  S7CPR(C, IV, L, LIV)                     
      GO TO 999                                                         
C                                                                       
 240  IV(1) = 66                                                        
      CALL ITSUM(V, V, IV, LIV, LV, P, V, ALF)                          
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF  RNSGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE V7PRM(N, IP, X)                                        
C                                                                       
C     PERMUTE X SO THAT X.OUTPUT(IP(I)) = X.INPUT(I).                   
C     IP IS UNCHANGED ON OUTPUT.                                        
C                                                                       
      INTEGER N                                                         
      INTEGER IP(N)                                                     
      REAL X(N)                                                         
C                                                                       
      INTEGER I, J, K                                                   
      REAL S, T                                                         
      DO 30 I = 1, N                                                    
         J = IP(I)                                                      
         IF (J .EQ. I) GO TO 30                                         
         IF (J .GT. 0) GO TO 10                                         
            IP(I) = -J                                                  
            GO TO 30                                                    
 10      T = X(I)                                                       
 20      S = X(J)                                                       
         X(J) = T                                                       
         T = S                                                          
         K = J                                                          
         J = IP(K)                                                      
         IP(K) = -J                                                     
         IF (J .GT. I) GO TO 20                                         
         X(J) = T                                                       
 30      CONTINUE                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF V7PRM FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  S7CPR(C, IV, L, LIV)                                  
C                                                                       
C  ***  PRINT C FOR    NSG (ETC.)  ***                                  
C                                                                       
      INTEGER L, LIV                                                    
      INTEGER IV(LIV)                                                   
      REAL C(L)                                                         
C                                                                       
      INTEGER I, PU                                                     
C                                                                       
      INTEGER PRUNIT, SOLPRT                                            
C                                                                       
C/6                                                                     
C     DATA PRUNIT/21/, SOLPRT/22/                                       
C/7                                                                     
      PARAMETER (PRUNIT=21, SOLPRT=22)                                  
C/                                                                      
C  ***  BODY  ***                                                       
C                                                                       
      IF (IV(1) .GT. 11) GO TO 999                                      
      IF (IV(SOLPRT) .EQ. 0) GO TO 999                                  
      PU = IV(PRUNIT)                                                   
      IF (PU .EQ. 0) GO TO 999                                          
      IF (L .GT. 0) WRITE(PU,10) (I, C(I), I = 1, L)                    
 10   FORMAT(/21H LINEAR PARAMETERS...//(1X,I5,E16.6))                  
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  S7CPR FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  RN2GB(B, D, DR, IV, LIV, LV, N, ND, N1, N2, P, R,     
     1                  RD, V, X)                                       
C                                                                       
C  ***  REVISED ITERATION DRIVER FOR NL2SOL WITH SIMPLE BOUNDS  ***     
C                                                                       
      INTEGER LIV, LV, N, ND, N1, N2, P                                 
      INTEGER IV(LIV)                                                   
      REAL B(2,P), D(P), DR(ND,P), R(ND), RD(ND), V(LV),                
     1                 X(P)                                             
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C B........ BOUNDS ON X.                                                
C D........ SCALE VECTOR.                                               
C DR....... DERIVATIVES OF R AT X.                                      
C IV....... INTEGER VALUES ARRAY.                                       
C LIV...... LENGTH OF IV... LIV MUST BE AT LEAST P + 80.                
C LV....... LENGTH OF V...  LV  MUST BE AT LEAST 105 + P*(2*P+16).      
C N........ TOTAL NUMBER OF RESIDUALS.                                  
C ND....... MAX. NO. OF RESIDUALS PASSED ON ONE CALL.                   
C N1....... LOWEST  ROW INDEX FOR RESIDUALS SUPPLIED THIS TIME.         
C N2....... HIGHEST ROW INDEX FOR RESIDUALS SUPPLIED THIS TIME.         
C P........ NUMBER OF PARAMETERS (COMPONENTS OF X) BEING ESTIMATED.     
C R........ RESIDUALS.                                                  
C V........ FLOATING-POINT VALUES ARRAY.                                
C X........ PARAMETER VECTOR BEING ESTIMATED (INPUT = INITIAL GUESS,    
C             OUTPUT = BEST VALUE FOUND).                               
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C     THIS ROUTINE CARRIES OUT ITERATIONS FOR SOLVING NONLINEAR         
C  LEAST SQUARES PROBLEMS.  IT IS SIMILAR TO   RN2G, EXCEPT THAT        
C  THIS ROUTINE ENFORCES THE BOUNDS  B(1,I) .LE. X(I) .LE. B(2,I),      
C  I = 1(1)P.                                                           
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C                                                                       
C+++++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++
C                                                                       
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      REAL  D7TPR,  V2NRM                                               
      EXTERNAL IVSET,  D7TPR, D7UPD,  G7ITB, ITSUM, L7VML,  Q7APL,      
     1         Q7RAD,  R7TVM, V7CPY,  V7SCP,  V2NRM                     
C                                                                       
C IVSET.... PROVIDES DEFAULT IV AND V INPUT COMPONENTS.                 
C  D7TPR... COMPUTES INNER PRODUCT OF TWO VECTORS.                      
C D7UPD...  UPDATES SCALE VECTOR D.                                     
C  G7ITB... PERFORMS BASIC MINIMIZATION ALGORITHM.                      
C ITSUM.... PRINTS ITERATION SUMMARY, INFO ABOUT INITIAL AND FINAL X.   
C L7VML.... COMPUTES L * V, V = VECTOR, L = LOWER TRIANGULAR MATRIX.    
C  Q7APL... APPLIES QR TRANSFORMATIONS STORED BY Q7RAD.                 
C Q7RAD.... ADDS A NEW BLOCK OF ROWS TO QR DECOMPOSITION.               
C  R7TVM... MULT. VECTOR BY TRANS. OF UPPER TRIANG. MATRIX FROM QR FACT.
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C  V2NRM... RETURNS THE 2-NORM OF A VECTOR.                             
C                                                                       
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER G1, GI, I, IV1, IVMODE, JTOL1, L, LH, NN, QTR1,           
     1        RD1, RMAT1, YI, Y1                                        
      REAL T                                                            
C                                                                       
      REAL HALF, ZERO                                                   
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER DINIT, DTYPE, DTINIT, D0INIT, F, G, JCN, JTOL, MODE,      
     1        NEXTV, NF0, NF00, NF1, NFCALL, NFCOV, NFGCAL, QTR, RDREQ, 
     1        REGD, RESTOR, RLIMIT, RMAT, TOOBIG, VNEED                 
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA DTYPE/16/, G/28/, JCN/66/, JTOL/59/, MODE/35/, NEXTV/47/,    
C    1     NF0/68/, NF00/81/, NF1/69/, NFCALL/6/, NFCOV/52/, NFGCAL/7/, 
C    2     QTR/77/, RDREQ/57/, RESTOR/9/, REGD/67/, RMAT/78/, TOOBIG/2/,
C    3     VNEED/4/                                                     
C/7                                                                     
      PARAMETER (DTYPE=16, G=28, JCN=66, JTOL=59, MODE=35, NEXTV=47,    
     1           NF0=68, NF00=81, NF1=69, NFCALL=6, NFCOV=52, NFGCAL=7, 
     2           QTR=77, RDREQ=57, RESTOR=9, REGD=67, RMAT=78, TOOBIG=2,
     3           VNEED=4)                                               
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA DINIT/38/, DTINIT/39/, D0INIT/40/, F/10/, RLIMIT/46/         
C/7                                                                     
      PARAMETER (DINIT=38, DTINIT=39, D0INIT=40, F=10, RLIMIT=46)       
C/                                                                      
C/6                                                                     
C     DATA HALF/0.5E+0/, ZERO/0.E+0/                                    
C/7                                                                     
      PARAMETER (HALF=0.5E+0, ZERO=0.E+0)                               
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      LH = P * (P+1) / 2                                                
      NN = N2 - N1 + 1                                                  
      IF (IV(1) .EQ. 0) CALL IVSET(1, IV, LIV, LV, V)                   
      IV1 = IV(1)                                                       
      IF (IV1 .GT. 2) GO TO 10                                          
         IV(RESTOR) = 0                                                 
         I = IV1 + 4                                                    
         IF (IV(TOOBIG) .EQ. 0) GO TO (150, 130, 150, 120, 120, 150), I 
         IF (I .NE. 5) IV(1) = 2                                        
         GO TO 40                                                       
C                                                                       
C  ***  FRESH START OR RESTART -- CHECK INPUT INTEGERS  ***             
C                                                                       
 10   IF (ND .LE. 0) GO TO 220                                          
      IF (P .LE. 0) GO TO 220                                           
      IF (N .LE. 0) GO TO 220                                           
      IF (IV1 .EQ. 14) GO TO 30                                         
      IF (IV1 .GT. 16) GO TO 270                                        
      IF (IV1 .LT. 12) GO TO 40                                         
      IF (IV1 .EQ. 12) IV(1) = 13                                       
      IF (IV(1) .NE. 13) GO TO 20                                       
      IV(VNEED) = IV(VNEED) + P*(P+15)/2                                
 20   CALL  G7ITB(B, D, X, IV, LIV, LV, P, P, V, X, X)                  
      IF (IV(1) .NE. 14) GO TO 999                                      
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
      IV(G) = IV(NEXTV)                                                 
      IV(JCN) = IV(G) + 2*P                                             
      IV(RMAT) = IV(JCN) + P                                            
      IV(QTR) = IV(RMAT) + LH                                           
      IV(JTOL) = IV(QTR) + 2*P                                          
      IV(NEXTV) = IV(JTOL) + 2*P                                        
C  ***  TURN OFF COVARIANCE COMPUTATION  ***                            
      IV(RDREQ) = 0                                                     
      IF (IV1 .EQ. 13) GO TO 999                                        
C                                                                       
 30   JTOL1 = IV(JTOL)                                                  
      IF (V(DINIT) .GE. ZERO) CALL  V7SCP(P, D, V(DINIT))               
      IF (V(DTINIT) .GT. ZERO) CALL  V7SCP(P, V(JTOL1), V(DTINIT))      
      I = JTOL1 + P                                                     
      IF (V(D0INIT) .GT. ZERO) CALL  V7SCP(P, V(I), V(D0INIT))          
      IV(NF0) = 0                                                       
      IV(NF1) = 0                                                       
      IF (ND .GE. N) GO TO 40                                           
C                                                                       
C  ***  SPECIAL CASE HANDLING OF FIRST FUNCTION AND GRADIENT EVALUATION 
C  ***  -- ASK FOR BOTH RESIDUAL AND JACOBIAN AT ONCE                   
C                                                                       
      G1 = IV(G)                                                        
      Y1 = G1 + P                                                       
      CALL  G7ITB(B, D, V(G1), IV, LIV, LV, P, P, V, X, V(Y1))          
      IF (IV(1) .NE. 1) GO TO 260                                       
      V(F) = ZERO                                                       
      CALL  V7SCP(P, V(G1), ZERO)                                       
      IV(1) = -1                                                        
      QTR1 = IV(QTR)                                                    
      CALL  V7SCP(P, V(QTR1), ZERO)                                     
      IV(REGD) = 0                                                      
      RMAT1 = IV(RMAT)                                                  
      GO TO 100                                                         
C                                                                       
 40   G1 = IV(G)                                                        
      Y1 = G1 + P                                                       
      CALL  G7ITB(B, D, V(G1), IV, LIV, LV, P, P, V, X, V(Y1))          
      IF (IV(1) - 2) 50, 60, 260                                        
C                                                                       
 50   V(F) = ZERO                                                       
      IF (IV(NF1) .EQ. 0) GO TO 240                                     
      IF (IV(RESTOR) .NE. 2) GO TO 240                                  
      IV(NF0) = IV(NF1)                                                 
      CALL V7CPY(N, RD, R)                                              
      IV(REGD) = 0                                                      
      GO TO 240                                                         
C                                                                       
 60   CALL  V7SCP(P, V(G1), ZERO)                                       
      IF (IV(MODE) .GT. 0) GO TO 230                                    
      RMAT1 = IV(RMAT)                                                  
      QTR1 = IV(QTR)                                                    
      RD1 = QTR1 + P                                                    
      CALL  V7SCP(P, V(QTR1), ZERO)                                     
      IV(REGD) = 0                                                      
      IF (ND .LT. N) GO TO 90                                           
      IF (N1 .NE. 1) GO TO 90                                           
      IF (IV(MODE) .LT. 0) GO TO 100                                    
      IF (IV(NF1) .EQ. IV(NFGCAL)) GO TO 70                             
         IF (IV(NF0) .NE. IV(NFGCAL)) GO TO 90                          
            CALL V7CPY(N, R, RD)                                        
            GO TO 80                                                    
 70   CALL V7CPY(N, RD, R)                                              
 80   CALL  Q7APL(ND, N, P, DR, RD, 0)                                  
      CALL  R7TVM(ND, P, V(Y1), V(RD1), DR, RD)                         
      IV(REGD) = 0                                                      
      GO TO 110                                                         
C                                                                       
 90   IV(1) = -2                                                        
      IF (IV(MODE) .LT. 0) IV(1) = -3                                   
 100  CALL  V7SCP(P, V(Y1), ZERO)                                       
 110  CALL  V7SCP(LH, V(RMAT1), ZERO)                                   
      GO TO 240                                                         
C                                                                       
C  ***  COMPUTE F(X)  ***                                               
C                                                                       
 120  T =  V2NRM(NN, R)                                                 
      IF (T .GT. V(RLIMIT)) GO TO 210                                   
      V(F) = V(F)  +  HALF * T**2                                       
      IF (N2 .LT. N) GO TO 250                                          
      IF (N1 .EQ. 1) IV(NF1) = IV(NFCALL)                               
      GO TO 40                                                          
C                                                                       
C  ***  COMPUTE Y  ***                                                  
C                                                                       
 130  Y1 = IV(G) + P                                                    
      YI = Y1                                                           
      DO 140 L = 1, P                                                   
         V(YI) = V(YI) +  D7TPR(NN, DR(1,L), R)                         
         YI = YI + 1                                                    
 140     CONTINUE                                                       
      IF (N2 .LT. N) GO TO 250                                          
         IV(1) = 2                                                      
         IF (N1 .GT. 1) IV(1) = -3                                      
         GO TO 240                                                      
C                                                                       
C  ***  COMPUTE GRADIENT INFORMATION  ***                               
C                                                                       
 150  G1 = IV(G)                                                        
      IVMODE = IV(MODE)                                                 
      IF (IVMODE .LT. 0) GO TO 170                                      
      IF (IVMODE .EQ. 0) GO TO 180                                      
      IV(1) = 2                                                         
C                                                                       
C  ***  COMPUTE GRADIENT ONLY (FOR USE IN COVARIANCE COMPUTATION)  ***  
C                                                                       
      GI = G1                                                           
      DO 160 L = 1, P                                                   
         V(GI) = V(GI) +  D7TPR(NN, R, DR(1,L))                         
         GI = GI + 1                                                    
 160     CONTINUE                                                       
      GO TO 200                                                         
C                                                                       
C  *** COMPUTE INITIAL FUNCTION VALUE WHEN ND .LT. N ***                
C                                                                       
 170  IF (N .LE. ND) GO TO 180                                          
         T =  V2NRM(NN, R)                                              
         IF (T .GT. V(RLIMIT)) GO TO 210                                
         V(F) = V(F)  +  HALF * T**2                                    
C                                                                       
C  ***  UPDATE D IF DESIRED  ***                                        
C                                                                       
 180  IF (IV(DTYPE) .GT. 0)                                             
     1      CALL D7UPD(D, DR, IV, LIV, LV, N, ND, NN, N2, P, V)         
C                                                                       
C  ***  COMPUTE RMAT AND QTR  ***                                       
C                                                                       
      QTR1 = IV(QTR)                                                    
      RMAT1 = IV(RMAT)                                                  
      CALL Q7RAD(NN, ND, P, V(QTR1), .TRUE., V(RMAT1), DR, R)           
      IV(NF1) = 0                                                       
      IF (N1 .GT. 1) GO TO 200                                          
      IF (N2 .LT. N) GO TO 250                                          
C                                                                       
C  ***  SAVE DIAGONAL OF R FOR COMPUTING Y LATER  ***                   
C                                                                       
      RD1 = QTR1 + P                                                    
      L = RMAT1 - 1                                                     
      DO 190 I = 1, P                                                   
         L = L + I                                                      
         V(RD1) = V(L)                                                  
         RD1 = RD1 + 1                                                  
 190     CONTINUE                                                       
C                                                                       
 200  IF (N2 .LT. N) GO TO 250                                          
      IF (IVMODE .GT. 0) GO TO 40                                       
      IV(NF00) = IV(NFGCAL)                                             
C                                                                       
C  ***  COMPUTE G FROM RMAT AND QTR  ***                                
C                                                                       
      CALL L7VML(P, V(G1), V(RMAT1), V(QTR1))                           
      IV(1) = 2                                                         
      IF (IVMODE .EQ. 0) GO TO 40                                       
      IF (N .LE. ND) GO TO 40                                           
C                                                                       
C  ***  FINISH SPECIAL CASE HANDLING OF FIRST FUNCTION AND GRADIENT     
C                                                                       
      Y1 = G1 + P                                                       
      IV(1) = 1                                                         
      CALL  G7ITB(B, D, V(G1), IV, LIV, LV, P, P, V, X, V(Y1))          
      IF (IV(1) .NE. 2) GO TO 260                                       
      GO TO 40                                                          
C                                                                       
C  ***  MISC. DETAILS  ***                                              
C                                                                       
C     ***  X IS OUT OF RANGE (OVERSIZE STEP)  ***                       
C                                                                       
 210  IV(TOOBIG) = 1                                                    
      GO TO 40                                                          
C                                                                       
C     ***  BAD N, ND, OR P  ***                                         
C                                                                       
 220  IV(1) = 66                                                        
      GO TO 270                                                         
C                                                                       
C  ***  RECORD EXTRA EVALUATIONS FOR FINITE-DIFFERENCE HESSIAN  ***     
C                                                                       
 230  IV(NFCOV) = IV(NFCOV) + 1                                         
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(NFGCAL) = IV(NFCALL)                                           
      IV(1) = -1                                                        
C                                                                       
C  ***  RETURN FOR MORE FUNCTION OR GRADIENT INFORMATION  ***           
C                                                                       
 240  N2 = 0                                                            
 250  N1 = N2 + 1                                                       
      N2 = N2 + ND                                                      
      IF (N2 .GT. N) N2 = N                                             
      GO TO 999                                                         
C                                                                       
C  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  *** 
C                                                                       
 260  G1 = IV(G)                                                        
 270  CALL ITSUM(D, V(G1), IV, LIV, LV, P, V, X)                        
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF  RN2GB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  C7VFN(IV, L, LH, LIV, LV, N, P, V)                    
C                                                                       
C  ***  FINISH COVARIANCE COMPUTATION FOR   RN2G,   RNSG  ***           
C                                                                       
      INTEGER LH, LIV, LV, N, P                                         
      INTEGER IV(LIV)                                                   
      REAL L(LH), V(LV)                                                 
C                                                                       
      EXTERNAL  L7NVR,  L7TSQ,  V7SCL                                   
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER COV, I                                                    
      REAL HALF                                                         
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, COVMAT, F, FDH, H, MODE, RDREQ, REGD              
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, COVMAT/26/, F/10/, FDH/74/, H/56/, MODE/35/,     
C    1     RDREQ/57/, REGD/67/                                          
C/7                                                                     
      PARAMETER (CNVCOD=55, COVMAT=26, F=10, FDH=74, H=56, MODE=35,     
     1           RDREQ=57, REGD=67)                                     
C/                                                                      
      DATA HALF/0.5E+0/                                                 
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      IV(1) = IV(CNVCOD)                                                
      I = IV(MODE) - P                                                  
      IV(MODE) = 0                                                      
      IV(CNVCOD) = 0                                                    
      IF (IV(FDH) .LE. 0) GO TO 999                                     
      IF ((I-2)**2 .EQ. 1) IV(REGD) = 1                                 
      IF (MOD(IV(RDREQ),2) .NE. 1) GO TO 999                            
C                                                                       
C     ***  FINISH COMPUTING COVARIANCE MATRIX = INVERSE OF F.D. HESSIAN.
C                                                                       
      COV = IABS(IV(H))                                                 
      IV(FDH) = 0                                                       
C                                                                       
      IF (IV(COVMAT) .NE. 0) GO TO 999                                  
      IF (I .GE. 2) GO TO 10                                            
         CALL  L7NVR(P, V(COV), L)                                      
         CALL  L7TSQ(P, V(COV), V(COV))                                 
C                                                                       
 10   CALL  V7SCL(LH, V(COV), V(F)/(HALF * FLOAT(MAX0(1,N-P))), V(COV)) 
      IV(COVMAT) = COV                                                  
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  C7VFN FOLLOWS  ***                                
      END                                                               
        SUBROUTINE  D7DGB(B, D, DIG, DST, G, IPIV, KA, L, LV, P, PC,    
     1                    NWTST, STEP, TD, TG, V, W, X0)                
C                                                                       
C  ***  COMPUTE DOUBLE-DOGLEG STEP, SUBJECT TO SIMPLE BOUNDS ON X  ***  
C                                                                       
      INTEGER LV, KA, P, PC                                             
      INTEGER IPIV(P)                                                   
      REAL B(2,P), D(P), DIG(P), DST(P), G(P), L(1),                    
     1                 NWTST(P), STEP(P), TD(P), TG(P), V(LV), W(P),    
     2                 X0(P)                                            
C                                                                       
C     DIMENSION L(P*(P+1)/2)                                            
C                                                                       
      REAL  D7TPR,  R7MDC,  V2NRM                                       
      EXTERNAL D7DOG,  D7TPR, I7SHFT,  L7ITV,  L7IVM,  L7TVM, L7VML,    
     1          Q7RSH,  R7MDC,  V2NRM, V2AXY, V7CPY,  V7IPR,  V7SCP,    
     2          V7SHF,  V7VMP                                           
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER I, J, K, P1, P1M1                                         
      REAL DNWTST, GHINVG, GNORM, GNORM0, NRED, PRED, RAD,              
     1                 T, T1, T2, TI, X0I, XI                           
      REAL HALF, MEPS2, ONE, TWO, ZERO                                  
C                                                                       
C  ***  V SUBSCRIPTS  ***                                               
C                                                                       
      INTEGER DGNORM, DST0, DSTNRM, GRDFAC, GTHG, GTSTEP, NREDUC,       
     1        NWTFAC, PREDUC, RADIUS, STPPAR                            
C                                                                       
C/6                                                                     
C     DATA DGNORM/1/, DST0/3/, DSTNRM/2/, GRDFAC/45/, GTHG/44/,         
C    1     GTSTEP/4/, NREDUC/6/, NWTFAC/46/, PREDUC/7/, RADIUS/8/,      
C    2     STPPAR/5/                                                    
C/7                                                                     
      PARAMETER (DGNORM=1, DST0=3, DSTNRM=2, GRDFAC=45, GTHG=44,        
     1           GTSTEP=4, NREDUC=6, NWTFAC=46, PREDUC=7, RADIUS=8,     
     2           STPPAR=5)                                              
C/                                                                      
C/6                                                                     
C     DATA HALF/0.5E+0/, ONE/1.E+0/, TWO/2.E+0/, ZERO/0.E+0/            
C/7                                                                     
      PARAMETER (HALF=0.5E+0, ONE=1.E+0, TWO=2.E+0, ZERO=0.E+0)         
      SAVE MEPS2                                                        
C/                                                                      
      DATA MEPS2/0.E+0/                                                 
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      IF (MEPS2 .LE. ZERO) MEPS2 = TWO *  R7MDC(3)                      
      GNORM0 = V(DGNORM)                                                
      V(DSTNRM) = ZERO                                                  
      IF (KA .LT. 0) GO TO 10                                           
         DNWTST = V(DST0)                                               
         NRED = V(NREDUC)                                               
 10   PRED = ZERO                                                       
      V(STPPAR) = ZERO                                                  
      RAD = V(RADIUS)                                                   
      IF (PC .GT. 0) GO TO 20                                           
         DNWTST = ZERO                                                  
         CALL  V7SCP(P, STEP, ZERO)                                     
         GO TO 140                                                      
C                                                                       
 20   P1 = PC                                                           
      CALL V7CPY(P, TD, D)                                              
      CALL  V7IPR(P, IPIV, TD)                                          
      CALL  V7SCP(PC, DST, ZERO)                                        
      CALL V7CPY(P, TG, G)                                              
      CALL  V7IPR(P, IPIV, TG)                                          
C                                                                       
 30   CALL  L7IVM(P1, NWTST, L, TG)                                     
      GHINVG =  D7TPR(P1, NWTST, NWTST)                                 
      V(NREDUC) = HALF * GHINVG                                         
      CALL  L7ITV(P1, NWTST, L, NWTST)                                  
      CALL  V7VMP(P1, STEP, NWTST, TD, 1)                               
      V(DST0) =  V2NRM(PC, STEP)                                        
      IF (KA .GE. 0) GO TO 40                                           
         KA = 0                                                         
         DNWTST = V(DST0)                                               
         NRED = V(NREDUC)                                               
 40   V(RADIUS) = RAD - V(DSTNRM)                                       
      IF (V(RADIUS) .LE. ZERO) GO TO 100                                
      CALL  V7VMP(P1, DIG, TG, TD, -1)                                  
      GNORM =  V2NRM(P1, DIG)                                           
      IF (GNORM .LE. ZERO) GO TO 100                                    
      V(DGNORM) = GNORM                                                 
      CALL  V7VMP(P1, DIG, DIG, TD, -1)                                 
      CALL  L7TVM(P1, W, L, DIG)                                        
      V(GTHG) =  V2NRM(P1, W)                                           
      KA = KA + 1                                                       
      CALL D7DOG(DIG, LV, P1, NWTST, STEP, V)                           
C                                                                       
C     ***  FIND T SUCH THAT X - T*STEP IS STILL FEASIBLE.               
C                                                                       
      T = ONE                                                           
      K = 0                                                             
      DO 70 I = 1, P1                                                   
         J = IPIV(I)                                                    
         X0I = X0(J) + DST(I)/TD(I)                                     
         XI = X0I + STEP(I)                                             
         IF (XI .LT. B(1,J)) GO TO 50                                   
         IF (XI .LE. B(2,J)) GO TO 70                                   
              TI = (B(2,J) - X0I) / STEP(I)                             
              J = I                                                     
              GO TO 60                                                  
 50      TI = (B(1,J) - X0I) / STEP(I)                                  
         J = -I                                                         
 60      IF (T .LE. TI) GO TO 70                                        
              K = J                                                     
              T = TI                                                    
 70      CONTINUE                                                       
C                                                                       
C  ***  UPDATE DST, TG, AND PRED  ***                                   
C                                                                       
      CALL  V7VMP(P1, STEP, STEP, TD, 1)                                
      CALL V2AXY(P1, DST, T, STEP, DST)                                 
      V(DSTNRM) =  V2NRM(PC, DST)                                       
      T1 = T * V(GRDFAC)                                                
      T2 = T * V(NWTFAC)                                                
      PRED = PRED - T1*GNORM * ((T2 + ONE)*GNORM)                       
     1                 - T2 * (ONE + HALF*T2)*GHINVG                    
     2                  - HALF * (V(GTHG)*T1)**2                        
      IF (K .EQ. 0) GO TO 100                                           
      CALL L7VML(P1, W, L, W)                                           
      T2 = ONE - T2                                                     
      DO 80 I = 1, P1                                                   
 80      TG(I) = T2*TG(I) - T1*W(I)                                     
C                                                                       
C     ***  PERMUTE L, ETC. IF NECESSARY  ***                            
C                                                                       
      P1M1 = P1 - 1                                                     
      J = IABS(K)                                                       
      IF (J .EQ. P1) GO TO 90                                           
         CALL  Q7RSH(J, P1, .FALSE., TG, L, W)                          
         CALL I7SHFT(P1, J, IPIV)                                       
         CALL  V7SHF(P1, J, TG)                                         
         CALL  V7SHF(P1, J, TD)                                         
         CALL  V7SHF(P1, J, DST)                                        
 90   IF (K .LT. 0) IPIV(P1) = -IPIV(P1)                                
      P1 = P1M1                                                         
      IF (P1 .GT. 0) GO TO 30                                           
C                                                                       
C     ***  UNSCALE STEP, UPDATE X AND DIHDI  ***                        
C                                                                       
 100  CALL  V7SCP(P, STEP, ZERO)                                        
      DO 110 I = 1, PC                                                  
         J = IABS(IPIV(I))                                              
         STEP(J) = DST(I) / TD(I)                                       
 110     CONTINUE                                                       
C                                                                       
C  ***  FUDGE STEP TO ENSURE THAT IT FORCES APPROPRIATE COMPONENTS      
C  ***  TO THEIR BOUNDS  ***                                            
C                                                                       
      IF (P1 .GE. PC) GO TO 140                                         
      CALL V2AXY(P, TD, ONE, STEP, X0)                                  
      K = P1 + 1                                                        
      DO 130 I = K, PC                                                  
         J = IPIV(I)                                                    
         T = MEPS2                                                      
         IF (J .GT. 0) GO TO 120                                        
            T = -T                                                      
            J = -J                                                      
            IPIV(I) = J                                                 
 120     T = T * AMAX1( ABS(TD(J)),  ABS(X0(J)))                        
         STEP(J) = STEP(J) + T                                          
 130     CONTINUE                                                       
C                                                                       
 140  V(DGNORM) = GNORM0                                                
      V(NREDUC) = NRED                                                  
      V(PREDUC) = PRED                                                  
      V(RADIUS) = RAD                                                   
      V(DST0) = DNWTST                                                  
      V(GTSTEP) =  D7TPR(P, STEP, G)                                    
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  D7DGB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE D7DOG(DIG, LV, N, NWTSTP, STEP, V)                     
C                                                                       
C  ***  COMPUTE DOUBLE DOGLEG STEP  ***                                 
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LV, N                                                     
      REAL DIG(N), NWTSTP(N), STEP(N), V(LV)                            
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        THIS SUBROUTINE COMPUTES A CANDIDATE STEP (FOR USE IN AN UNCON-
C     STRAINED MINIMIZATION CODE) BY THE DOUBLE DOGLEG ALGORITHM OF     
C     DENNIS AND MEI (REF. 1), WHICH IS A VARIATION ON POWELL*S DOGLEG  
C     SCHEME (REF. 2, P. 95).                                           
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C    DIG (INPUT) DIAG(D)**-2 * G -- SEE ALGORITHM NOTES.                
C      G (INPUT) THE CURRENT GRADIENT VECTOR.                           
C     LV (INPUT) LENGTH OF V.                                           
C      N (INPUT) NUMBER OF COMPONENTS IN  DIG, G, NWTSTP,  AND  STEP.   
C NWTSTP (INPUT) NEGATIVE NEWTON STEP -- SEE ALGORITHM NOTES.           
C   STEP (OUTPUT) THE COMPUTED STEP.                                    
C      V (I/O) VALUES ARRAY, THE FOLLOWING COMPONENTS OF WHICH ARE      
C             USED HERE...                                              
C V(BIAS)   (INPUT) BIAS FOR RELAXED NEWTON STEP, WHICH IS V(BIAS) OF   
C             THE WAY FROM THE FULL NEWTON TO THE FULLY RELAXED NEWTON  
C             STEP.  RECOMMENDED VALUE = 0.8 .                          
C V(DGNORM) (INPUT) 2-NORM OF DIAG(D)**-1 * G -- SEE ALGORITHM NOTES.   
C V(DSTNRM) (OUTPUT) 2-NORM OF DIAG(D) * STEP, WHICH IS V(RADIUS)       
C             UNLESS V(STPPAR) = 0 -- SEE ALGORITHM NOTES.              
C V(DST0) (INPUT) 2-NORM OF DIAG(D) * NWTSTP -- SEE ALGORITHM NOTES.    
C V(GRDFAC) (OUTPUT) THE COEFFICIENT OF  DIG  IN THE STEP RETURNED --   
C             STEP(I) = V(GRDFAC)*DIG(I) + V(NWTFAC)*NWTSTP(I).         
C V(GTHG)   (INPUT) SQUARE-ROOT OF (DIG**T) * (HESSIAN) * DIG -- SEE    
C             ALGORITHM NOTES.                                          
C V(GTSTEP) (OUTPUT) INNER PRODUCT BETWEEN G AND STEP.                  
C V(NREDUC) (OUTPUT) FUNCTION REDUCTION PREDICTED FOR THE FULL NEWTON   
C             STEP.                                                     
C V(NWTFAC) (OUTPUT) THE COEFFICIENT OF  NWTSTP  IN THE STEP RETURNED --
C             SEE V(GRDFAC) ABOVE.                                      
C V(PREDUC) (OUTPUT) FUNCTION REDUCTION PREDICTED FOR THE STEP RETURNED.
C V(RADIUS) (INPUT) THE TRUST REGION RADIUS.  D TIMES THE STEP RETURNED 
C             HAS 2-NORM V(RADIUS) UNLESS V(STPPAR) = 0.                
C V(STPPAR) (OUTPUT) CODE TELLING HOW STEP WAS COMPUTED... 0 MEANS A    
C             FULL NEWTON STEP.  BETWEEN 0 AND 1 MEANS V(STPPAR) OF THE 
C             WAY FROM THE NEWTON TO THE RELAXED NEWTON STEP.  BETWEEN  
C             1 AND 2 MEANS A TRUE DOUBLE DOGLEG STEP, V(STPPAR) - 1 OF 
C             THE WAY FROM THE RELAXED NEWTON TO THE CAUCHY STEP.       
C             GREATER THAN 2 MEANS 1 / (V(STPPAR) - 1) TIMES THE CAUCHY 
C             STEP.                                                     
C                                                                       
C-------------------------------  NOTES  -------------------------------
C                                                                       
C  ***  ALGORITHM NOTES  ***                                            
C                                                                       
C        LET  G  AND  H  BE THE CURRENT GRADIENT AND HESSIAN APPROXIMA- 
C     TION RESPECTIVELY AND LET D BE THE CURRENT SCALE VECTOR.  THIS    
C     ROUTINE ASSUMES DIG = DIAG(D)**-2 * G  AND  NWTSTP = H**-1 * G.   
C     THE STEP COMPUTED IS THE SAME ONE WOULD GET BY REPLACING G AND H  
C     BY  DIAG(D)**-1 * G  AND  DIAG(D)**-1 * H * DIAG(D)**-1,          
C     COMPUTING STEP, AND TRANSLATING STEP BACK TO THE ORIGINAL         
C     VARIABLES, I.E., PREMULTIPLYING IT BY DIAG(D)**-1.                
C                                                                       
C  ***  REFERENCES  ***                                                 
C                                                                       
C 1.  DENNIS, J.E., AND MEI, H.H.W. (1979), TWO NEW UNCONSTRAINED OPTI- 
C             MIZATION ALGORITHMS WHICH USE FUNCTION AND GRADIENT       
C             VALUES, J. OPTIM. THEORY APPLIC. 28, PP. 453-482.         
C 2. POWELL, M.J.D. (1970), A HYBRID METHOD FOR NON-LINEAR EQUATIONS,   
C             IN NUMERICAL METHODS FOR NON-LINEAR EQUATIONS, EDITED BY  
C             P. RABINOWITZ, GORDON AND BREACH, LONDON.                 
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH SUPPORTED 
C     BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS MCS-7600324 AND   
C     MCS-7906671.                                                      
C                                                                       
C------------------------  EXTERNAL QUANTITIES  ------------------------
C                                                                       
C  ***  INTRINSIC FUNCTIONS  ***                                        
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C--------------------------  LOCAL VARIABLES  --------------------------
C                                                                       
      INTEGER I                                                         
      REAL CFACT, CNORM, CTRNWT, GHINVG, FEMNSQ, GNORM,                 
     1                 NWTNRM, RELAX, RLAMBD, T, T1, T2                 
      REAL HALF, ONE, TWO, ZERO                                         
C                                                                       
C  ***  V SUBSCRIPTS  ***                                               
C                                                                       
      INTEGER BIAS, DGNORM, DSTNRM, DST0, GRDFAC, GTHG, GTSTEP,         
     1        NREDUC, NWTFAC, PREDUC, RADIUS, STPPAR                    
C                                                                       
C  ***  DATA INITIALIZATIONS  ***                                       
C                                                                       
C/6                                                                     
C     DATA HALF/0.5E+0/, ONE/1.E+0/, TWO/2.E+0/, ZERO/0.E+0/            
C/7                                                                     
      PARAMETER (HALF=0.5E+0, ONE=1.E+0, TWO=2.E+0, ZERO=0.E+0)         
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA BIAS/43/, DGNORM/1/, DSTNRM/2/, DST0/3/, GRDFAC/45/,         
C    1     GTHG/44/, GTSTEP/4/, NREDUC/6/, NWTFAC/46/, PREDUC/7/,       
C    2     RADIUS/8/, STPPAR/5/                                         
C/7                                                                     
      PARAMETER (BIAS=43, DGNORM=1, DSTNRM=2, DST0=3, GRDFAC=45,        
     1           GTHG=44, GTSTEP=4, NREDUC=6, NWTFAC=46, PREDUC=7,      
     2           RADIUS=8, STPPAR=5)                                    
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      NWTNRM = V(DST0)                                                  
      RLAMBD = ONE                                                      
      IF (NWTNRM .GT. ZERO) RLAMBD = V(RADIUS) / NWTNRM                 
      GNORM = V(DGNORM)                                                 
      GHINVG = TWO * V(NREDUC)                                          
      V(GRDFAC) = ZERO                                                  
      V(NWTFAC) = ZERO                                                  
      IF (RLAMBD .LT. ONE) GO TO 30                                     
C                                                                       
C        ***  THE NEWTON STEP IS INSIDE THE TRUST REGION  ***           
C                                                                       
         V(STPPAR) = ZERO                                               
         V(DSTNRM) = NWTNRM                                             
         V(GTSTEP) = -GHINVG                                            
         V(PREDUC) = V(NREDUC)                                          
         V(NWTFAC) = -ONE                                               
         DO 20 I = 1, N                                                 
 20           STEP(I) = -NWTSTP(I)                                      
         GO TO 999                                                      
C                                                                       
 30   V(DSTNRM) = V(RADIUS)                                             
      CFACT = (GNORM / V(GTHG))**2                                      
C     ***  CAUCHY STEP = -CFACT * G.                                    
      CNORM = GNORM * CFACT                                             
      RELAX = ONE - V(BIAS) * (ONE - GNORM*CNORM/GHINVG)                
      IF (RLAMBD .LT. RELAX) GO TO 50                                   
C                                                                       
C        ***  STEP IS BETWEEN RELAXED NEWTON AND FULL NEWTON STEPS  *** 
C                                                                       
         V(STPPAR)  =  ONE  -  (RLAMBD - RELAX) / (ONE - RELAX)         
         T = -RLAMBD                                                    
         V(GTSTEP) = T * GHINVG                                         
         V(PREDUC) = RLAMBD * (ONE - HALF*RLAMBD) * GHINVG              
         V(NWTFAC) = T                                                  
         DO 40 I = 1, N                                                 
 40           STEP(I) = T * NWTSTP(I)                                   
         GO TO 999                                                      
C                                                                       
 50   IF (CNORM .LT. V(RADIUS)) GO TO 70                                
C                                                                       
C        ***  THE CAUCHY STEP LIES OUTSIDE THE TRUST REGION --          
C        ***  STEP = SCALED CAUCHY STEP  ***                            
C                                                                       
         T = -V(RADIUS) / GNORM                                         
         V(GRDFAC) = T                                                  
         V(STPPAR) = ONE  +  CNORM / V(RADIUS)                          
         V(GTSTEP) = -V(RADIUS) * GNORM                                 
      V(PREDUC) = V(RADIUS)*(GNORM - HALF*V(RADIUS)*(V(GTHG)/GNORM)**2) 
         DO 60 I = 1, N                                                 
 60           STEP(I) = T * DIG(I)                                      
         GO TO 999                                                      
C                                                                       
C     ***  COMPUTE DOGLEG STEP BETWEEN CAUCHY AND RELAXED NEWTON  ***   
C     ***  FEMUR = RELAXED NEWTON STEP MINUS CAUCHY STEP  ***           
C                                                                       
 70   CTRNWT = CFACT * RELAX * GHINVG / GNORM                           
C     *** CTRNWT = INNER PROD. OF CAUCHY AND RELAXED NEWTON STEPS,      
C     *** SCALED BY GNORM**-1.                                          
      T1 = CTRNWT - GNORM*CFACT**2                                      
C     ***  T1 = INNER PROD. OF FEMUR AND CAUCHY STEP, SCALED BY         
C     ***  GNORM**-1.                                                   
      T2 = V(RADIUS)*(V(RADIUS)/GNORM) - GNORM*CFACT**2                 
      T = RELAX * NWTNRM                                                
      FEMNSQ = (T/GNORM)*T - CTRNWT - T1                                
C     ***  FEMNSQ = SQUARE OF 2-NORM OF FEMUR, SCALED BY GNORM**-1.     
      T = T2 / (T1 +  SQRT(T1**2 + FEMNSQ*T2))                          
C     ***  DOGLEG STEP  =  CAUCHY STEP  +  T * FEMUR.                   
      T1 = (T - ONE) * CFACT                                            
      V(GRDFAC) = T1                                                    
      T2 = -T * RELAX                                                   
      V(NWTFAC) = T2                                                    
      V(STPPAR) = TWO - T                                               
      V(GTSTEP) = T1*GNORM**2 + T2*GHINVG                               
      V(PREDUC) = -T1*GNORM * ((T2 + ONE)*GNORM)                        
     1                 - T2 * (ONE + HALF*T2)*GHINVG                    
     2                  - HALF * (V(GTHG)*T1)**2                        
      DO 80 I = 1, N                                                    
 80      STEP(I) = T1*DIG(I) + T2*NWTSTP(I)                             
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF D7DOG FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE D7DUP(D, HDIAG, IV, LIV, LV, N, V)                     
C                                                                       
C  ***  UPDATE SCALE VECTOR D FOR   MNH  ***                            
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LIV, LV, N                                                
      INTEGER IV(LIV)                                                   
      REAL D(N), HDIAG(N), V(LV)                                        
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER DTOLI, D0I, I                                             
      REAL T, VDFAC                                                     
C                                                                       
C  ***  INTRINSIC FUNCTIONS  ***                                        
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER DFAC, DTOL, DTYPE, NITER                                  
C/6                                                                     
C     DATA DFAC/41/, DTOL/59/, DTYPE/16/, NITER/31/                     
C/7                                                                     
      PARAMETER (DFAC=41, DTOL=59, DTYPE=16, NITER=31)                  
C/                                                                      
C                                                                       
C-------------------------------  BODY  --------------------------------
C                                                                       
      I = IV(DTYPE)                                                     
      IF (I .EQ. 1) GO TO 10                                            
         IF (IV(NITER) .GT. 0) GO TO 999                                
C                                                                       
 10   DTOLI = IV(DTOL)                                                  
      D0I = DTOLI + N                                                   
      VDFAC = V(DFAC)                                                   
      DO 20 I = 1, N                                                    
         T = AMAX1( SQRT( ABS(HDIAG(I))), VDFAC*D(I))                   
         IF (T .LT. V(DTOLI)) T = AMAX1(V(DTOLI), V(D0I))               
         D(I) = T                                                       
         DTOLI = DTOLI + 1                                              
         D0I = D0I + 1                                                  
 20      CONTINUE                                                       
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF D7DUP FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE D7UPD(D, DR, IV, LIV, LV, N, ND, NN, N2, P, V)         
C                                                                       
C  ***  UPDATE SCALE VECTOR D FOR NL2IT  ***                            
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LIV, LV, N, ND, NN, N2, P                                 
      INTEGER IV(LIV)                                                   
      REAL D(P), DR(ND,P), V(LV)                                        
C     DIMENSION V(*)                                                    
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER D0, I, JCN0, JCN1, JCNI, JTOL0, JTOLI, K, SII             
      REAL T, VDFAC                                                     
C                                                                       
C     ***  CONSTANTS  ***                                               
C                                                                       
      REAL ZERO                                                         
C                                                                       
C  ***  INTRINSIC FUNCTIONS  ***                                        
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C  ***  EXTERNAL SUBROUTINE  ***                                        
C                                                                       
      EXTERNAL  V7SCP                                                   
C                                                                       
C  V7SCP... SETS ALL COMPONENTS OF A VECTOR TO A SCALAR.                
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER DFAC, DTYPE, JCN, JTOL, NITER, S                          
C/6                                                                     
C     DATA DFAC/41/, DTYPE/16/, JCN/66/, JTOL/59/, NITER/31/, S/62/     
C/7                                                                     
      PARAMETER (DFAC=41, DTYPE=16, JCN=66, JTOL=59, NITER=31, S=62)    
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (ZERO=0.E+0)                                            
C/                                                                      
C                                                                       
C-------------------------------  BODY  --------------------------------
C                                                                       
      IF (IV(DTYPE) .NE. 1 .AND. IV(NITER) .GT. 0) GO TO 999            
      JCN1 = IV(JCN)                                                    
      JCN0 = IABS(JCN1) - 1                                             
      IF (JCN1 .LT. 0) GO TO 10                                         
         IV(JCN) = -JCN1                                                
         CALL  V7SCP(P, V(JCN1), ZERO)                                  
 10   DO 30 I = 1, P                                                    
         JCNI = JCN0 + I                                                
         T  = V(JCNI)                                                   
         DO 20 K = 1, NN                                                
 20           T = AMAX1(T,  ABS(DR(K,I)))                               
         V(JCNI) = T                                                    
 30      CONTINUE                                                       
      IF (N2 .LT. N) GO TO 999                                          
      VDFAC = V(DFAC)                                                   
      JTOL0 = IV(JTOL) - 1                                              
      D0 = JTOL0 + P                                                    
      SII = IV(S) - 1                                                   
      DO 50 I = 1, P                                                    
         SII = SII + I                                                  
         JCNI = JCN0 + I                                                
         T = V(JCNI)                                                    
         IF (V(SII) .GT. ZERO) T = AMAX1( SQRT(V(SII)), T)              
         JTOLI = JTOL0 + I                                              
         D0 = D0 + 1                                                    
         IF (T .LT. V(JTOLI)) T = AMAX1(V(D0), V(JTOLI))                
         D(I) = AMAX1(VDFAC*D(I), T)                                    
 50      CONTINUE                                                       
C                                                                       
 999  RETURN                                                            
C  ***  LAST CARD OF D7UPD FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  G7ITB(B, D, G, IV, LIV, LV, P, PS, V, X, Y)           
C                                                                       
C  ***  CARRY OUT NL2SOL-LIKE ITERATIONS FOR GENERALIZED LINEAR   ***   
C  ***  REGRESSION PROBLEMS (AND OTHERS OF SIMILAR STRUCTURE)     ***   
C  ***  HAVING SIMPLE BOUNDS ON THE PARAMETERS BEING ESTIMATED.   ***   
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LIV, LV, P, PS                                            
      INTEGER IV(LIV)                                                   
      REAL B(2,P), D(P), G(P), V(LV), X(P), Y(P)                        
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C B.... VECTOR OF LOWER AND UPPER BOUNDS ON X.                          
C D.... SCALE VECTOR.                                                   
C IV... INTEGER VALUE ARRAY.                                            
C LIV.. LENGTH OF IV.  MUST BE AT LEAST 80.                             
C LH... LENGTH OF H = P*(P+1)/2.                                        
C LV... LENGTH OF V.  MUST BE AT LEAST P*(3*P + 19)/2 + 7.              
C G.... GRADIENT AT X (WHEN IV(1) = 2).                                 
C HC... GAUSS-NEWTON HESSIAN AT X (WHEN IV(1) = 2).                     
C P.... NUMBER OF PARAMETERS (COMPONENTS IN X).                         
C PS... NUMBER OF NONZERO ROWS AND COLUMNS IN S.                        
C V.... FLOATING-POINT VALUE ARRAY.                                     
C X.... PARAMETER VECTOR.                                               
C Y.... PART OF YIELD VECTOR (WHEN IV(1)= 2, SCRATCH OTHERWISE).        
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C         G7ITB IS SIMILAR TO G7LIT, EXCEPT FOR THE EXTRA PARAMETER B   
C     --  G7ITB ENFORCES THE BOUNDS  B(1,I) .LE. X(I) .LE. B(2,I),      
C     I = 1(1)P.                                                        
C         G7ITB PERFORMS NL2SOL-LIKE ITERATIONS FOR A VARIETY OF        
C     REGRESSION PROBLEMS THAT ARE SIMILAR TO NONLINEAR LEAST-SQUARES   
C     IN THAT THE HESSIAN IS THE SUM OF TWO TERMS, A READILY-COMPUTED   
C     FIRST-ORDER TERM AND A SECOND-ORDER TERM.  THE CALLER SUPPLIES    
C     THE FIRST-ORDER TERM OF THE HESSIAN IN HC (LOWER TRIANGLE, STORED 
C     COMPACTLY BY ROWS), AND  G7ITB BUILDS AN APPROXIMATION, S, TO THE 
C     SECOND-ORDER TERM.  THE CALLER ALSO PROVIDES THE FUNCTION VALUE,  
C     GRADIENT, AND PART OF THE YIELD VECTOR USED IN UPDATING S.        
C      G7ITB DECIDES DYNAMICALLY WHETHER OR NOT TO USE S WHEN CHOOSING  
C     THE NEXT STEP TO TRY...  THE HESSIAN APPROXIMATION USED IS EITHER 
C     HC ALONE (GAUSS-NEWTON MODEL) OR HC + S (AUGMENTED MODEL).        
C     IF PS .LT. P, THEN ROWS AND COLUMNS PS+1...P OF S ARE KEPT        
C     CONSTANT.  THEY WILL BE ZERO UNLESS THE CALLER SETS IV(INITS) TO  
C     1 OR 2 AND SUPPLIES NONZERO VALUES FOR THEM, OR THE CALLER SETS   
C     IV(INITS) TO 3 OR 4 AND THE FINITE-DIFFERENCE INITIAL S THEN      
C     COMPUTED HAS NONZERO VALUES IN THESE ROWS.                        
C                                                                       
C        IF IV(INITS) IS 3 OR 4, THEN THE INITIAL S IS COMPUTED BY      
C     FINITE DIFFERENCES.  3 MEANS USE FUNCTION DIFFERENCES, 4 MEANS    
C     USE GRADIENT DIFFERENCES.  FINITE DIFFERENCING IS DONE THE SAME   
C     WAY AS IN COMPUTING A COVARIANCE MATRIX (WITH IV(COVREQ) = -1, -2,
C     1, OR 2).                                                         
C                                                                       
C        FOR UPDATING S,  G7ITB ASSUMES THAT THE GRADIENT HAS THE FORM  
C     OF A SUM OVER I OF RHO(I,X)*GRAD(R(I,X)), WHERE GRAD DENOTES THE  
C     GRADIENT WITH RESPECT TO X.  THE TRUE SECOND-ORDER TERM THEN IS   
C     THE SUM OVER I OF RHO(I,X)*HESSIAN(R(I,X)).  IF X = X0 + STEP,    
C     THEN WE WISH TO UPDATE S SO THAT S*STEP IS THE SUM OVER I OF      
C     RHO(I,X)*(GRAD(R(I,X)) - GRAD(R(I,X0))).  THE CALLER MUST SUPPLY  
C     PART OF THIS IN Y, NAMELY THE SUM OVER I OF                       
C     RHO(I,X)*GRAD(R(I,X0)), WHEN CALLING  G7ITB WITH IV(1) = 2 AND    
C     IV(MODE) = 0 (WHERE MODE = 38).  G THEN CONTANS THE OTHER PART,   
C     SO THAT THE DESIRED YIELD VECTOR IS G - Y.  IF PS .LT. P, THEN    
C     THE ABOVE DISCUSSION APPLIES ONLY TO THE FIRST PS COMPONENTS OF   
C     GRAD(R(I,X)), STEP, AND Y.                                        
C                                                                       
C        PARAMETERS IV, P, V, AND X ARE THE SAME AS THE CORRESPONDING   
C     ONES TO   N2GB (AND NL2SOL), EXCEPT THAT V CAN BE SHORTER         
C     (SINCE THE PART OF V THAT   N2GB USES FOR STORING D, J, AND R IS  
C     NOT NEEDED).  MOREOVER, COMPARED WITH   N2GB (AND NL2SOL), IV(1)  
C     MAY HAVE THE TWO ADDITIONAL OUTPUT VALUES 1 AND 2, WHICH ARE      
C     EXPLAINED BELOW, AS IS THE USE OF IV(TOOBIG) AND IV(NFGCAL).      
C     THE VALUES IV(D), IV(J), AND IV(R), WHICH ARE OUTPUT VALUES FROM  
C       N2GB (AND   N2FB), ARE NOT REFERENCED BY  G7ITB OR THE          
C     SUBROUTINES IT CALLS.                                             
C                                                                       
C        WHEN  G7ITB IS FIRST CALLED, I.E., WHEN  G7ITB IS CALLED WITH  
C     IV(1) = 0 OR 12, V(F), G, AND HC NEED NOT BE INITIALIZED.  TO     
C     OBTAIN THESE STARTING VALUES,  G7ITB RETURNS FIRST WITH IV(1) = 1,
C     THEN WITH IV(1) = 2, WITH IV(MODE) = -1 IN BOTH CASES.  ON        
C     SUBSEQUENT RETURNS WITH IV(1) = 2, IV(MODE) = 0 IMPLIES THAT      
C     Y MUST ALSO BE SUPPLIED.  (NOTE THAT Y IS USED FOR SCRATCH -- ITS 
C     INPUT CONTENTS ARE LOST.  BY CONTRAST, HC IS NEVER CHANGED.)      
C     ONCE CONVERGENCE HAS BEEN OBTAINED, IV(RDREQ) AND IV(COVREQ) MAY  
C     IMPLY THAT A FINITE-DIFFERENCE HESSIAN SHOULD BE COMPUTED FOR USE 
C     IN COMPUTING A COVARIANCE MATRIX.  IN THIS CASE  G7ITB WILL MAKE  
C     A NUMBER OF RETURNS WITH IV(1) = 1 OR 2 AND IV(MODE) POSITIVE.    
C     WHEN IV(MODE) IS POSITIVE, Y SHOULD NOT BE CHANGED.               
C                                                                       
C IV(1) = 1 MEANS THE CALLER SHOULD SET V(F) (I.E., V(10)) TO F(X), THE 
C             FUNCTION VALUE AT X, AND CALL  G7ITB AGAIN, HAVING CHANGED
C             NONE OF THE OTHER PARAMETERS.  AN EXCEPTION OCCURS IF F(X)
C             CANNOT BE EVALUATED (E.G. IF OVERFLOW WOULD OCCUR), WHICH 
C             MAY HAPPEN BECAUSE OF AN OVERSIZED STEP.  IN THIS CASE    
C             THE CALLER SHOULD SET IV(TOOBIG) = IV(2) TO 1, WHICH WILL 
C             CAUSE  G7ITB TO IGNORE V(F) AND TRY A SMALLER STEP.  NOTE 
C             THAT THE CURRENT FUNCTION EVALUATION COUNT IS AVAILABLE   
C             IN IV(NFCALL) = IV(6).  THIS MAY BE USED TO IDENTIFY      
C             WHICH COPY OF SAVED INFORMATION SHOULD BE USED IN COM-    
C             PUTING G, HC, AND Y THE NEXT TIME  G7ITB RETURNS WITH     
C             IV(1) = 2.  SEE MLPIT FOR AN EXAMPLE OF THIS.             
C IV(1) = 2 MEANS THE CALLER SHOULD SET G TO G(X), THE GRADIENT OF F AT 
C             X.  THE CALLER SHOULD ALSO SET HC TO THE GAUSS-NEWTON     
C             HESSIAN AT X.  IF IV(MODE) = 0, THEN THE CALLER SHOULD    
C             ALSO COMPUTE THE PART OF THE YIELD VECTOR DESCRIBED ABOVE.
C             THE CALLER SHOULD THEN CALL  G7ITB AGAIN (WITH IV(1) = 2).
C             THE CALLER MAY ALSO CHANGE D AT THIS TIME, BUT SHOULD NOT 
C             CHANGE X.  NOTE THAT IV(NFGCAL) = IV(7) CONTAINS THE      
C             VALUE THAT IV(NFCALL) HAD DURING THE RETURN WITH          
C             IV(1) = 1 IN WHICH X HAD THE SAME VALUE AS IT NOW HAS.    
C             IV(NFGCAL) IS EITHER IV(NFCALL) OR IV(NFCALL) - 1.  MLPIT 
C             IS AN EXAMPLE WHERE THIS INFORMATION IS USED.  IF G OR HC 
C             CANNOT BE EVALUATED AT X, THEN THE CALLER MAY SET         
C             IV(NFGCAL) TO 0, IN WHICH CASE  G7ITB WILL RETURN WITH    
C             IV(1) = 15.                                               
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C                                                                       
C        (SEE NL2SOL FOR REFERENCES.)                                   
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      LOGICAL HAVQTR, HAVRM                                             
      INTEGER DUMMY, DIG1, G01, H1, HC1, I, I1, IPI, IPIV0, IPIV1,      
     1        IPIV2, IPN, J, K, L, LMAT1, LSTGST, P1, P1LEN, PP1, PP1O2,
     2        QTR1, RMAT1, RSTRST, STEP1, STPMOD, S1, TD1, TEMP1, TEMP2,
     3        TG1, W1, WLM1, X01                                        
      REAL E, GI, STTSST, T, T1, XI                                     
C                                                                       
C     ***  CONSTANTS  ***                                               
C                                                                       
      REAL HALF, NEGONE, ONE, ONEP2, ZERO                               
C                                                                       
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      LOGICAL STOPX                                                     
      REAL  D7TPR,  RLDST,  V2NRM                                       
      EXTERNAL A7SST,  D7TPR,  F7DHB,  G7QSB,I7COPY, I7PNVR, I7SHFT,    
     1         ITSUM,  L7MSB,  L7SQR,  L7TVM, L7VML, PARCK,  Q7RSH,     
     2          RLDST,  S7DMP,  S7IPR,  S7LUP,  S7LVM, STOPX,  V2NRM,   
     3         V2AXY, V7CPY,  V7IPR,  V7SCP,  V7VMP                     
C                                                                       
C A7SST.... ASSESSES CANDIDATE STEP.                                    
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C  F7DHB... COMPUTE FINITE-DIFFERENCE HESSIAN (FOR INIT. S MATRIX).     
C  G7QSB... COMPUTES GOLDFELD-QUANDT-TROTTER STEP (AUGMENTED MODEL).    
C I7COPY.... COPIES ONE INTEGER VECTOR TO ANOTHER.                      
C I7PNVR... INVERTS PERMUTATION ARRAY.                                  
C I7SHFT... SHIFTS AN INTEGER VECTOR.                                   
C ITSUM.... PRINTS ITERATION SUMMARY AND INFO ON INITIAL AND FINAL X.   
C  L7MSB... COMPUTES LEVENBERG-MARQUARDT STEP (GAUSS-NEWTON MODEL).     
C  L7SQR... COMPUTES L * L**T FROM LOWER TRIANGULAR MATRIX L.           
C  L7TVM... COMPUTES L**T * V, V = VECTOR, L = LOWER TRIANGULAR MATRIX. 
C L7VML.... COMPUTES L * V, V = VECTOR, L = LOWER TRIANGULAR MATRIX.    
C PARCK.... CHECK VALIDITY OF IV AND V INPUT COMPONENTS.                
C  Q7RSH... SHIFTS A QR FACTORIZATION.                                  
C  RLDST... COMPUTES V(RELDX) = RELATIVE STEP SIZE.                     
C  S7DMP... MULTIPLIES A SYM. MATRIX FORE AND AFT BY A DIAG. MATRIX.    
C  S7IPR... APPLIES PERMUTATION TO (LOWER TRIANG. OF) SYM. MATRIX.      
C  S7LUP... PERFORMS QUASI-NEWTON UPDATE ON COMPACTLY STORED LOWER TRI- 
C             ANGLE OF A SYMMETRIC MATRIX.                              
C  S7LVM... MULTIPLIES COMPACTLY STORED SYM. MATRIX TIMES VECTOR.       
C STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.           
C  V2NRM... RETURNS THE 2-NORM OF A VECTOR.                             
C V2AXY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.              
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7IPR... APPLIES A PERMUTATION TO A VECTOR.                          
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C  V7VMP... MULTIPLIES (DIVIDES) VECTORS COMPONENTWISE.                 
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, COSMIN, COVMAT, COVREQ, DGNORM, DIG,              
     1        DSTNRM, F, FDH, FDIF, FUZZ, F0, GTSTEP, H, HC, IERR,      
     2        INCFAC, INITS, IPIVOT, IRC, IVNEED, KAGQT, KALM, LMAT,    
     3        LMAX0, LMAXS, MODE, MODEL, MXFCAL, MXITER, NEXTIV, NEXTV, 
     4        NFCALL, NFGCAL, NFCOV, NGCOV, NGCALL, NITER, NVSAVE, P0,  
     5        PC, PERM, PHMXFC, PREDUC, QTR, RADFAC, RADINC, RADIUS,    
     6        RAD0, RDREQ, REGD, RELDX, RESTOR, RMAT, S, SIZE, STEP,    
     7        STGLIM, STPPAR, SUSED, SWITCH, TOOBIG, TUNER4, TUNER5,    
     8        VNEED, VSAVE, W, WSCALE, XIRC, X0                         
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C  ***  (NOTE THAT P0 AND PC ARE STORED IN IV(G0) AND IV(STLSTG) RESP.) 
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, COVMAT/26/, COVREQ/15/, DIG/37/, FDH/74/, H/56/, 
C    1     HC/71/, IERR/75/, INITS/25/, IPIVOT/76/, IRC/29/, IVNEED/3/, 
C    2     KAGQT/33/, KALM/34/, LMAT/42/, MODE/35/, MODEL/5/,           
C    3     MXFCAL/17/, MXITER/18/, NEXTIV/46/, NEXTV/47/, NFCALL/6/,    
C    4     NFGCAL/7/, NFCOV/52/, NGCOV/53/, NGCALL/30/, NITER/31/,      
C    5     P0/48/, PC/41/, PERM/58/, QTR/77/, RADINC/8/, RDREQ/57/,     
C    6     REGD/67/, RESTOR/9/, RMAT/78/, S/62/, STEP/40/, STGLIM/11/,  
C    7     SUSED/64/, SWITCH/12/, TOOBIG/2/, VNEED/4/, VSAVE/60/, W/65/,
C    8     XIRC/13/, X0/43/                                             
C/7                                                                     
      PARAMETER (CNVCOD=55, COVMAT=26, COVREQ=15, DIG=37, FDH=74, H=56, 
     1           HC=71, IERR=75, INITS=25, IPIVOT=76, IRC=29, IVNEED=3, 
     2           KAGQT=33, KALM=34, LMAT=42, MODE=35, MODEL=5,          
     3           MXFCAL=17, MXITER=18, NEXTIV=46, NEXTV=47, NFCALL=6,   
     4           NFGCAL=7, NFCOV=52, NGCOV=53, NGCALL=30, NITER=31,     
     5           P0=48, PC=41, PERM=58, QTR=77, RADINC=8, RDREQ=57,     
     6           REGD=67, RESTOR=9, RMAT=78, S=62, STEP=40, STGLIM=11,  
     7           SUSED=64, SWITCH=12, TOOBIG=2, VNEED=4, VSAVE=60, W=65,
     8           XIRC=13, X0=43)                                        
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA COSMIN/47/, DGNORM/1/, DSTNRM/2/, F/10/, FDIF/11/, FUZZ/45/, 
C    1     F0/13/, GTSTEP/4/, INCFAC/23/, LMAX0/35/, LMAXS/36/,         
C    2     NVSAVE/9/, PHMXFC/21/, PREDUC/7/, RADFAC/16/, RADIUS/8/,     
C    3     RAD0/9/, RELDX/17/, SIZE/55/, STPPAR/5/, TUNER4/29/,         
C    4     TUNER5/30/, WSCALE/56/                                       
C/7                                                                     
      PARAMETER (COSMIN=47, DGNORM=1, DSTNRM=2, F=10, FDIF=11, FUZZ=45, 
     1           F0=13, GTSTEP=4, INCFAC=23, LMAX0=35, LMAXS=36,        
     2           NVSAVE=9, PHMXFC=21, PREDUC=7, RADFAC=16, RADIUS=8,    
     3           RAD0=9, RELDX=17, SIZE=55, STPPAR=5, TUNER4=29,        
     4           TUNER5=30, WSCALE=56)                                  
C/                                                                      
C                                                                       
C                                                                       
C/6                                                                     
C     DATA HALF/0.5E+0/, NEGONE/-1.E+0/, ONE/1.E+0/, ONEP2/1.2E+0/,     
C    1     ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (HALF=0.5E+0, NEGONE=-1.E+0, ONE=1.E+0, ONEP2=1.2E+0,   
     1           ZERO=0.E+0)                                            
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      I = IV(1)                                                         
      IF (I .EQ. 1) GO TO 50                                            
      IF (I .EQ. 2) GO TO 60                                            
C                                                                       
      IF (I .LT. 12) GO TO 10                                           
      IF (I .GT. 13) GO TO 10                                           
         IV(VNEED) = IV(VNEED) + P*(3*P + 25)/2 + 7                     
         IV(IVNEED) = IV(IVNEED) + 4*P                                  
 10   CALL PARCK(1, D, IV, LIV, LV, P, V)                               
      I = IV(1) - 2                                                     
      IF (I .GT. 12) GO TO 999                                          
      GO TO (360, 360, 360, 360, 360, 360, 240, 190, 240, 20, 20, 30), I
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
 20   PP1O2 = P * (P + 1) / 2                                           
      IV(S) = IV(LMAT) + PP1O2                                          
      IV(X0) = IV(S) + PP1O2                                            
      IV(STEP) = IV(X0) + 2*P                                           
      IV(DIG) = IV(STEP) + 3*P                                          
      IV(W) = IV(DIG) + 2*P                                             
      IV(H) = IV(W) + 4*P + 7                                           
      IV(NEXTV) = IV(H) + PP1O2                                         
      IV(IPIVOT) = IV(PERM) + 3*P                                       
      IV(NEXTIV) = IV(IPIVOT) + P                                       
      IF (IV(1) .NE. 13) GO TO 30                                       
         IV(1) = 14                                                     
         GO TO 999                                                      
C                                                                       
C  ***  INITIALIZATION  ***                                             
C                                                                       
 30   IV(NITER) = 0                                                     
      IV(NFCALL) = 1                                                    
      IV(NGCALL) = 1                                                    
      IV(NFGCAL) = 1                                                    
      IV(MODE) = -1                                                     
      IV(STGLIM) = 2                                                    
      IV(TOOBIG) = 0                                                    
      IV(CNVCOD) = 0                                                    
      IV(COVMAT) = 0                                                    
      IV(NFCOV) = 0                                                     
      IV(NGCOV) = 0                                                     
      IV(RADINC) = 0                                                    
      IV(PC) = P                                                        
      V(RAD0) = ZERO                                                    
      V(STPPAR) = ZERO                                                  
      V(RADIUS) = V(LMAX0) / (ONE + V(PHMXFC))                          
C                                                                       
C  ***  CHECK CONSISTENCY OF B AND INITIALIZE IP ARRAY  ***             
C                                                                       
      IPI = IV(IPIVOT)                                                  
      DO 40 I = 1, P                                                    
         IV(IPI) = I                                                    
         IPI = IPI + 1                                                  
         IF (B(1,I) .GT. B(2,I)) GO TO 680                              
 40      CONTINUE                                                       
C                                                                       
C  ***  SET INITIAL MODEL AND S MATRIX  ***                             
C                                                                       
      IV(MODEL) = 1                                                     
      IV(1) = 1                                                         
      IF (IV(S) .LT. 0) GO TO 710                                       
      IF (IV(INITS) .GT. 1) IV(MODEL) = 2                               
      S1 = IV(S)                                                        
      IF (IV(INITS) .EQ. 0 .OR. IV(INITS) .GT. 2)                       
     1   CALL  V7SCP(P*(P+1)/2, V(S1), ZERO)                            
      GO TO 710                                                         
C                                                                       
C  ***  NEW FUNCTION VALUE  ***                                         
C                                                                       
 50   IF (IV(MODE) .EQ. 0) GO TO 360                                    
      IF (IV(MODE) .GT. 0) GO TO 590                                    
C                                                                       
      IF (IV(TOOBIG) .EQ. 0) GO TO 690                                  
         IV(1) = 63                                                     
         GO TO 999                                                      
C                                                                       
C  ***  MAKE SURE GRADIENT COULD BE COMPUTED  ***                       
C                                                                       
 60   IF (IV(TOOBIG) .EQ. 0) GO TO 70                                   
         IV(1) = 65                                                     
         GO TO 999                                                      
C                                                                       
C  ***  NEW GRADIENT  ***                                               
C                                                                       
 70   IV(KALM) = -1                                                     
      IV(KAGQT) = -1                                                    
      IV(FDH) = 0                                                       
      IF (IV(MODE) .GT. 0) GO TO 590                                    
      IF (IV(HC) .LE. 0 .AND. IV(RMAT) .LE. 0) GO TO 670                
C                                                                       
C  ***  CHOOSE INITIAL PERMUTATION  ***                                 
C                                                                       
      IPI = IV(IPIVOT)                                                  
      IPN = IPI + P - 1                                                 
      IPIV2 = IV(PERM) - 1                                              
      K = IV(PC)                                                        
      P1 = P                                                            
      PP1 = P + 1                                                       
      RMAT1 = IV(RMAT)                                                  
      HAVRM = RMAT1 .GT. 0                                              
      QTR1 = IV(QTR)                                                    
      HAVQTR = QTR1 .GT. 0                                              
C     *** MAKE SURE V(QTR1) IS LEGAL (EVEN WHEN NOT REFERENCED) ***     
      W1 = IV(W)                                                        
      IF (.NOT. HAVQTR) QTR1 = W1 + P                                   
C                                                                       
      DO 100 I = 1, P                                                   
         I1 = IV(IPN)                                                   
         IPN = IPN - 1                                                  
         IF (B(1,I1) .GE. B(2,I1)) GO TO 80                             
         XI = X(I1)                                                     
         GI = G(I1)                                                     
         IF (XI .LE. B(1,I1) .AND. GI .GT. ZERO) GO TO 80               
         IF (XI .GE. B(2,I1) .AND. GI .LT. ZERO) GO TO 80               
C           *** DISALLOW CONVERGENCE IF X(I1) HAS JUST BEEN FREED ***   
            J = IPIV2 + I1                                              
            IF (IV(J) .GT. K) IV(CNVCOD) = 0                            
            GO TO 100                                                   
 80      IF (I1 .GE. P1) GO TO 90                                       
            I1 = PP1 - I                                                
            CALL I7SHFT(P1, I1, IV(IPI))                                
            IF (HAVRM)                                                  
     1          CALL  Q7RSH(I1, P1, HAVQTR, V(QTR1), V(RMAT1), V(W1))   
 90      P1 = P1 - 1                                                    
 100     CONTINUE                                                       
      IV(PC) = P1                                                       
C                                                                       
C  ***  COMPUTE V(DGNORM) (AN OUTPUT VALUE IF WE STOP NOW)  ***         
C                                                                       
      V(DGNORM) = ZERO                                                  
      IF (P1 .LE. 0) GO TO 110                                          
      DIG1 = IV(DIG)                                                    
      CALL  V7VMP(P, V(DIG1), G, D, -1)                                 
      CALL  V7IPR(P, IV(IPI), V(DIG1))                                  
      V(DGNORM) =  V2NRM(P1, V(DIG1))                                   
 110  IF (IV(CNVCOD) .NE. 0) GO TO 580                                  
      IF (IV(MODE) .EQ. 0) GO TO 510                                    
      IV(MODE) = 0                                                      
      V(F0) = V(F)                                                      
      IF (IV(INITS) .LE. 2) GO TO 170                                   
C                                                                       
C  ***  ARRANGE FOR FINITE-DIFFERENCE INITIAL S  ***                    
C                                                                       
      IV(XIRC) = IV(COVREQ)                                             
      IV(COVREQ) = -1                                                   
      IF (IV(INITS) .GT. 3) IV(COVREQ) = 1                              
      IV(CNVCOD) = 70                                                   
      GO TO 600                                                         
C                                                                       
C  ***  COME TO NEXT STMT AFTER COMPUTING F.D. HESSIAN FOR INIT. S  *** 
C                                                                       
 120  H1 = IV(FDH)                                                      
      IF (H1 .LE. 0) GO TO 660                                          
      IV(CNVCOD) = 0                                                    
      IV(MODE) = 0                                                      
      IV(NFCOV) = 0                                                     
      IV(NGCOV) = 0                                                     
      IV(COVREQ) = IV(XIRC)                                             
      S1 = IV(S)                                                        
      PP1O2 = PS * (PS + 1) / 2                                         
      HC1 = IV(HC)                                                      
      IF (HC1 .LE. 0) GO TO 130                                         
         CALL V2AXY(PP1O2, V(S1), NEGONE, V(HC1), V(H1))                
         GO TO 140                                                      
 130  RMAT1 = IV(RMAT)                                                  
      LMAT1 = IV(LMAT)                                                  
      CALL  L7SQR(P, V(LMAT1), V(RMAT1))                                
      IPI = IV(IPIVOT)                                                  
      IPIV1 = IV(PERM) + P                                              
      CALL I7PNVR(P, IV(IPIV1), IV(IPI))                                
      CALL  S7IPR(P, IV(IPIV1), V(LMAT1))                               
      CALL V2AXY(PP1O2, V(S1), NEGONE, V(LMAT1), V(H1))                 
C                                                                       
C     *** ZERO PORTION OF S CORRESPONDING TO FIXED X COMPONENTS ***     
C                                                                       
 140  DO 160 I = 1, P                                                   
         IF (B(1,I) .LT. B(2,I)) GO TO 160                              
         K = S1 + I*(I-1)/2                                             
         CALL  V7SCP(I, V(K), ZERO)                                     
         IF (I .GE. P) GO TO 170                                        
         K = K + 2*I - 1                                                
         I1 = I + 1                                                     
         DO 150 J = I1, P                                               
            V(K) = ZERO                                                 
            K = K + J                                                   
 150        CONTINUE                                                    
 160     CONTINUE                                                       
C                                                                       
 170  IV(1) = 2                                                         
C                                                                       
C                                                                       
C-----------------------------  MAIN LOOP  -----------------------------
C                                                                       
C                                                                       
C  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***             
C                                                                       
 180  CALL ITSUM(D, G, IV, LIV, LV, P, V, X)                            
 190  K = IV(NITER)                                                     
      IF (K .LT. IV(MXITER)) GO TO 200                                  
         IV(1) = 10                                                     
         GO TO 999                                                      
 200  IV(NITER) = K + 1                                                 
C                                                                       
C  ***  UPDATE RADIUS  ***                                              
C                                                                       
      IF (K .EQ. 0) GO TO 220                                           
      STEP1 = IV(STEP)                                                  
      DO 210 I = 1, P                                                   
         V(STEP1) = D(I) * V(STEP1)                                     
         STEP1 = STEP1 + 1                                              
 210     CONTINUE                                                       
      STEP1 = IV(STEP)                                                  
      T = V(RADFAC) *  V2NRM(P, V(STEP1))                               
      IF (V(RADFAC) .LT. ONE .OR. T .GT. V(RADIUS)) V(RADIUS) = T       
C                                                                       
C  ***  INITIALIZE FOR START OF NEXT ITERATION  ***                     
C                                                                       
 220  X01 = IV(X0)                                                      
      V(F0) = V(F)                                                      
      IV(IRC) = 4                                                       
      IV(H) = -IABS(IV(H))                                              
      IV(SUSED) = IV(MODEL)                                             
C                                                                       
C     ***  COPY X TO X0  ***                                            
C                                                                       
      CALL V7CPY(P, V(X01), X)                                          
C                                                                       
C  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***                  
C                                                                       
 230  IF (.NOT. STOPX(DUMMY)) GO TO 250                                 
         IV(1) = 11                                                     
         GO TO 260                                                      
C                                                                       
C     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.  
C                                                                       
 240  IF (V(F) .GE. V(F0)) GO TO 250                                    
         V(RADFAC) = ONE                                                
         K = IV(NITER)                                                  
         GO TO 200                                                      
C                                                                       
 250  IF (IV(NFCALL) .LT. IV(MXFCAL) + IV(NFCOV)) GO TO 270             
         IV(1) = 9                                                      
 260     IF (V(F) .GE. V(F0)) GO TO 999                                 
C                                                                       
C        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH        
C        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.                
C                                                                       
              IV(CNVCOD) = IV(1)                                        
              GO TO 500                                                 
C                                                                       
C. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . . 
C                                                                       
 270  STEP1 = IV(STEP)                                                  
      TG1 = IV(DIG)                                                     
      TD1 = TG1 + P                                                     
      X01 = IV(X0)                                                      
      W1 = IV(W)                                                        
      H1 = IV(H)                                                        
      P1 = IV(PC)                                                       
      IPI = IV(PERM)                                                    
      IPIV1 = IPI + P                                                   
      IPIV2 = IPIV1 + P                                                 
      IPIV0 = IV(IPIVOT)                                                
      IF (IV(MODEL) .EQ. 2) GO TO 280                                   
C                                                                       
C        ***  COMPUTE LEVENBERG-MARQUARDT STEP IF POSSIBLE...           
C                                                                       
         RMAT1 = IV(RMAT)                                               
         IF (RMAT1 .LE. 0) GO TO 280                                    
         QTR1 = IV(QTR)                                                 
         IF (QTR1 .LE. 0) GO TO 280                                     
         LMAT1 = IV(LMAT)                                               
         WLM1 = W1 + P                                                  
         CALL  L7MSB(B, D, G, IV(IERR), IV(IPIV0), IV(IPIV1),           
     1               IV(IPIV2), IV(KALM), V(LMAT1), LV, P, IV(P0),      
     2               IV(PC), V(QTR1), V(RMAT1), V(STEP1), V(TD1),       
     3               V(TG1), V, V(W1), V(WLM1), X, V(X01))              
C        *** H IS STORED IN THE END OF W AND HAS JUST BEEN OVERWRITTEN, 
C        *** SO WE MARK IT INVALID...                                   
         IV(H) = -IABS(H1)                                              
C        *** EVEN IF H WERE STORED ELSEWHERE, IT WOULD BE NECESSARY TO  
C        *** MARK INVALID THE INFORMATION G7QTS MAY HAVE STORED IN V... 
         IV(KAGQT) = -1                                                 
         GO TO 330                                                      
C                                                                       
 280  IF (H1 .GT. 0) GO TO 320                                          
C                                                                       
C     ***  SET H TO  D**-1 * (HC + T1*S) * D**-1.  ***                  
C                                                                       
         P1LEN = P1*(P1+1)/2                                            
         H1 = -H1                                                       
         IV(H) = H1                                                     
         IV(FDH) = 0                                                    
         IF (P1 .LE. 0) GO TO 320                                       
C        *** MAKE TEMPORARY PERMUTATION ARRAY ***                       
         CALL I7COPY(P, IV(IPI), IV(IPIV0))                             
         J = IV(HC)                                                     
         IF (J .GT. 0) GO TO 290                                        
            J = H1                                                      
            RMAT1 = IV(RMAT)                                            
            CALL  L7SQR(P1, V(H1), V(RMAT1))                            
            GO TO 300                                                   
 290     CALL V7CPY(P*(P+1)/2, V(H1), V(J))                             
         CALL  S7IPR(P, IV(IPI), V(H1))                                 
 300     IF (IV(MODEL) .EQ. 1) GO TO 310                                
            LMAT1 = IV(LMAT)                                            
            S1 = IV(S)                                                  
            CALL V7CPY(P*(P+1)/2, V(LMAT1), V(S1))                      
            CALL  S7IPR(P, IV(IPI), V(LMAT1))                           
            CALL V2AXY(P1LEN, V(H1), ONE, V(LMAT1), V(H1))              
 310     CALL V7CPY(P, V(TD1), D)                                       
         CALL  V7IPR(P, IV(IPI), V(TD1))                                
         CALL  S7DMP(P1, V(H1), V(H1), V(TD1), -1)                      
         IV(KAGQT) = -1                                                 
C                                                                       
C  ***  COMPUTE ACTUAL GOLDFELD-QUANDT-TROTTER STEP  ***                
C                                                                       
 320  LMAT1 = IV(LMAT)                                                  
      CALL  G7QSB(B, D, V(H1), G, IV(IPI), IV(IPIV1), IV(IPIV2),        
     1            IV(KAGQT), V(LMAT1), LV, P, IV(P0), P1, V(STEP1),     
     2            V(TD1), V(TG1), V, V(W1), X, V(X01))                  
      IF (IV(KALM) .GT. 0) IV(KALM) = 0                                 
C                                                                       
 330  IF (IV(IRC) .NE. 6) GO TO 340                                     
         IF (IV(RESTOR) .NE. 2) GO TO 360                               
         RSTRST = 2                                                     
         GO TO 370                                                      
C                                                                       
C  ***  CHECK WHETHER EVALUATING F(X0 + STEP) LOOKS WORTHWHILE  ***     
C                                                                       
 340  IV(TOOBIG) = 0                                                    
      IF (V(DSTNRM) .LE. ZERO) GO TO 360                                
      IF (IV(IRC) .NE. 5) GO TO 350                                     
      IF (V(RADFAC) .LE. ONE) GO TO 350                                 
      IF (V(PREDUC) .GT. ONEP2 * V(FDIF)) GO TO 350                     
         IF (IV(RESTOR) .NE. 2) GO TO 360                               
         RSTRST = 0                                                     
         GO TO 370                                                      
C                                                                       
C  ***  COMPUTE F(X0 + STEP)  ***                                       
C                                                                       
 350  X01 = IV(X0)                                                      
      STEP1 = IV(STEP)                                                  
      CALL V2AXY(P, X, ONE, V(STEP1), V(X01))                           
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 710                                                         
C                                                                       
C. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
C                                                                       
 360  RSTRST = 3                                                        
 370  X01 = IV(X0)                                                      
      V(RELDX) =  RLDST(P, D, X, V(X01))                                
      CALL A7SST(IV, LIV, LV, V)                                        
      STEP1 = IV(STEP)                                                  
      LSTGST = X01 + P                                                  
      I = IV(RESTOR) + 1                                                
      GO TO (410, 380, 390, 400), I                                     
 380  CALL V7CPY(P, X, V(X01))                                          
      GO TO 410                                                         
 390   CALL V7CPY(P, V(LSTGST), V(STEP1))                               
       GO TO 410                                                        
 400     CALL V7CPY(P, V(STEP1), V(LSTGST))                             
         CALL V2AXY(P, X, ONE, V(STEP1), V(X01))                        
         V(RELDX) =  RLDST(P, D, X, V(X01))                             
C                                                                       
C  ***  IF NECESSARY, SWITCH MODELS  ***                                
C                                                                       
 410  IF (IV(SWITCH) .EQ. 0) GO TO 420                                  
         IV(H) = -IABS(IV(H))                                           
         IV(SUSED) = IV(SUSED) + 2                                      
         L = IV(VSAVE)                                                  
         CALL V7CPY(NVSAVE, V, V(L))                                    
 420  CALL V2AXY(P, V(STEP1), NEGONE, V(X01), X)                        
      L = IV(IRC) - 4                                                   
      STPMOD = IV(MODEL)                                                
      IF (L .GT. 0) GO TO (440,450,460,460,460,460,460,460,570,510), L  
C                                                                       
C  ***  DECIDE WHETHER TO CHANGE MODELS  ***                            
C                                                                       
      E = V(PREDUC) - V(FDIF)                                           
      S1 = IV(S)                                                        
      CALL  S7LVM(PS, Y, V(S1), V(STEP1))                               
      STTSST = HALF *  D7TPR(PS, V(STEP1), Y)                           
      IF (IV(MODEL) .EQ. 1) STTSST = -STTSST                            
      IF ( ABS(E + STTSST) * V(FUZZ) .GE.  ABS(E)) GO TO 430            
C                                                                       
C     ***  SWITCH MODELS  ***                                           
C                                                                       
         IV(MODEL) = 3 - IV(MODEL)                                      
         IF (-2 .LT. L) GO TO 470                                       
              IV(H) = -IABS(IV(H))                                      
              IV(SUSED) = IV(SUSED) + 2                                 
              L = IV(VSAVE)                                             
              CALL V7CPY(NVSAVE, V(L), V)                               
              GO TO 230                                                 
C                                                                       
 430  IF (-3 .LT. L) GO TO 470                                          
C                                                                       
C     ***  RECOMPUTE STEP WITH DIFFERENT RADIUS  ***                    
C                                                                       
 440  V(RADIUS) = V(RADFAC) * V(DSTNRM)                                 
      GO TO 230                                                         
C                                                                       
C  ***  COMPUTE STEP OF LENGTH V(LMAXS) FOR SINGULAR CONVERGENCE TEST   
C                                                                       
 450  V(RADIUS) = V(LMAXS)                                              
      GO TO 270                                                         
C                                                                       
C  ***  CONVERGENCE OR FALSE CONVERGENCE  ***                           
C                                                                       
 460  IV(CNVCOD) = L                                                    
      IF (V(F) .GE. V(F0)) GO TO 580                                    
         IF (IV(XIRC) .EQ. 14) GO TO 580                                
              IV(XIRC) = 14                                             
C                                                                       
C. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
C                                                                       
 470  IV(COVMAT) = 0                                                    
      IV(REGD) = 0                                                      
C                                                                       
C  ***  SEE WHETHER TO SET V(RADFAC) BY GRADIENT TESTS  ***             
C                                                                       
      IF (IV(IRC) .NE. 3) GO TO 500                                     
         STEP1 = IV(STEP)                                               
         TEMP1 = STEP1 + P                                              
         TEMP2 = IV(X0)                                                 
C                                                                       
C     ***  SET  TEMP1 = HESSIAN * STEP  FOR USE IN GRADIENT TESTS  ***  
C                                                                       
         HC1 = IV(HC)                                                   
         IF (HC1 .LE. 0) GO TO 480                                      
              CALL  S7LVM(P, V(TEMP1), V(HC1), V(STEP1))                
              GO TO 490                                                 
 480     RMAT1 = IV(RMAT)                                               
         IPIV0 = IV(IPIVOT)                                             
         CALL V7CPY(P, V(TEMP1), V(STEP1))                              
         CALL  V7IPR(P, IV(IPIV0), V(TEMP1))                            
         CALL  L7TVM(P, V(TEMP1), V(RMAT1), V(TEMP1))                   
         CALL L7VML(P, V(TEMP1), V(RMAT1), V(TEMP1))                    
         IPIV1 = IV(PERM) + P                                           
         CALL I7PNVR(P, IV(IPIV1), IV(IPIV0))                           
         CALL  V7IPR(P, IV(IPIV1), V(TEMP1))                            
C                                                                       
 490     IF (STPMOD .EQ. 1) GO TO 500                                   
              S1 = IV(S)                                                
              CALL  S7LVM(PS, V(TEMP2), V(S1), V(STEP1))                
              CALL V2AXY(PS, V(TEMP1), ONE, V(TEMP2), V(TEMP1))         
C                                                                       
C  ***  SAVE OLD GRADIENT AND COMPUTE NEW ONE  ***                      
C                                                                       
 500  IV(NGCALL) = IV(NGCALL) + 1                                       
      G01 = IV(W)                                                       
      CALL V7CPY(P, V(G01), G)                                          
      GO TO 690                                                         
C                                                                       
C  ***  INITIALIZATIONS -- G0 = G - G0, ETC.  ***                       
C                                                                       
 510  G01 = IV(W)                                                       
      CALL V2AXY(P, V(G01), NEGONE, V(G01), G)                          
      STEP1 = IV(STEP)                                                  
      TEMP1 = STEP1 + P                                                 
      TEMP2 = IV(X0)                                                    
      IF (IV(IRC) .NE. 3) GO TO 540                                     
C                                                                       
C  ***  SET V(RADFAC) BY GRADIENT TESTS  ***                            
C                                                                       
C     ***  SET  TEMP1 = D**-1 * (HESSIAN * STEP  +  (G(X0) - G(X)))  ***
C                                                                       
         K = TEMP1                                                      
         L = G01                                                        
         DO 520 I = 1, P                                                
              V(K) = (V(K) - V(L)) / D(I)                               
              K = K + 1                                                 
              L = L + 1                                                 
 520          CONTINUE                                                  
C                                                                       
C        ***  DO GRADIENT TESTS  ***                                    
C                                                                       
         IF ( V2NRM(P, V(TEMP1)) .LE. V(DGNORM) * V(TUNER4))  GO TO 530 
              IF ( D7TPR(P, G, V(STEP1))                                
     1                  .GE. V(GTSTEP) * V(TUNER5))  GO TO 540          
 530               V(RADFAC) = V(INCFAC)                                
C                                                                       
C  ***  COMPUTE Y VECTOR NEEDED FOR UPDATING S  ***                     
C                                                                       
 540  CALL V2AXY(PS, Y, NEGONE, Y, G)                                   
C                                                                       
C  ***  DETERMINE SIZING FACTOR V(SIZE)  ***                            
C                                                                       
C     ***  SET TEMP1 = S * STEP  ***                                    
      S1 = IV(S)                                                        
      CALL  S7LVM(PS, V(TEMP1), V(S1), V(STEP1))                        
C                                                                       
      T1 =  ABS( D7TPR(PS, V(STEP1), V(TEMP1)))                         
      T =  ABS( D7TPR(PS, V(STEP1), Y))                                 
      V(SIZE) = ONE                                                     
      IF (T .LT. T1) V(SIZE) = T / T1                                   
C                                                                       
C  ***  SET G0 TO WCHMTD CHOICE OF FLETCHER AND AL-BAALI  ***           
C                                                                       
      HC1 = IV(HC)                                                      
      IF (HC1 .LE. 0) GO TO 550                                         
         CALL  S7LVM(PS, V(G01), V(HC1), V(STEP1))                      
         GO TO 560                                                      
C                                                                       
 550  RMAT1 = IV(RMAT)                                                  
      IPIV0 = IV(IPIVOT)                                                
      CALL V7CPY(P, V(G01), V(STEP1))                                   
      I = G01 + PS                                                      
      IF (PS .LT. P) CALL  V7SCP(P-PS, V(I), ZERO)                      
      CALL  V7IPR(P, IV(IPIV0), V(G01))                                 
      CALL  L7TVM(P, V(G01), V(RMAT1), V(G01))                          
      CALL L7VML(P, V(G01), V(RMAT1), V(G01))                           
      IPIV1 = IV(PERM) + P                                              
      CALL I7PNVR(P, IV(IPIV1), IV(IPIV0))                              
      CALL  V7IPR(P, IV(IPIV1), V(G01))                                 
C                                                                       
 560  CALL V2AXY(PS, V(G01), ONE, Y, V(G01))                            
C                                                                       
C  ***  UPDATE S  ***                                                   
C                                                                       
      CALL  S7LUP(V(S1), V(COSMIN), PS, V(SIZE), V(STEP1), V(TEMP1),    
     1            V(TEMP2), V(G01), V(WSCALE), Y)                       
      IV(1) = 2                                                         
      GO TO 180                                                         
C                                                                       
C. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
C                                                                       
C  ***  BAD PARAMETERS TO ASSESS  ***                                   
C                                                                       
 570  IV(1) = 64                                                        
      GO TO 999                                                         
C                                                                       
C                                                                       
C  ***  CONVERGENCE OBTAINED -- SEE WHETHER TO COMPUTE COVARIANCE  ***  
C                                                                       
 580  IF (IV(RDREQ) .EQ. 0) GO TO 660                                   
      IF (IV(FDH) .NE. 0) GO TO 660                                     
      IF (IV(CNVCOD) .GE. 7) GO TO 660                                  
      IF (IV(REGD) .GT. 0) GO TO 660                                    
      IF (IV(COVMAT) .GT. 0) GO TO 660                                  
      IF (IABS(IV(COVREQ)) .GE. 3) GO TO 640                            
      IF (IV(RESTOR) .EQ. 0) IV(RESTOR) = 2                             
      GO TO 600                                                         
C                                                                       
C  ***  COMPUTE FINITE-DIFFERENCE HESSIAN FOR COMPUTING COVARIANCE  *** 
C                                                                       
 590  IV(RESTOR) = 0                                                    
 600  CALL  F7DHB(B, D, G, I, IV, LIV, LV, P, V, X)                     
      GO TO (610, 620, 630), I                                          
 610  IV(NFCOV) = IV(NFCOV) + 1                                         
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 710                                                         
C                                                                       
 620  IV(NGCOV) = IV(NGCOV) + 1                                         
      IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(NFGCAL) = IV(NFCALL) + IV(NGCOV)                               
      GO TO 690                                                         
C                                                                       
 630  IF (IV(CNVCOD) .EQ. 70) GO TO 120                                 
      GO TO 660                                                         
C                                                                       
 640  H1 = IABS(IV(H))                                                  
      IV(FDH) = H1                                                      
      IV(H) = -H1                                                       
      HC1 = IV(HC)                                                      
      IF (HC1 .LE. 0) GO TO 650                                         
           CALL V7CPY(P*(P+1)/2, V(H1), V(HC1))                         
           GO TO 660                                                    
 650  RMAT1 = IV(RMAT)                                                  
      CALL  L7SQR(P, V(H1), V(RMAT1))                                   
C                                                                       
 660  IV(MODE) = 0                                                      
      IV(1) = IV(CNVCOD)                                                
      IV(CNVCOD) = 0                                                    
      GO TO 999                                                         
C                                                                       
C  ***  SPECIAL RETURN FOR MISSING HESSIAN INFORMATION -- BOTH          
C  ***  IV(HC) .LE. 0 AND IV(RMAT) .LE. 0                               
C                                                                       
 670  IV(1) = 1400                                                      
      GO TO 999                                                         
C                                                                       
C  ***  INCONSISTENT B  ***                                             
C                                                                       
 680  IV(1) = 82                                                        
      GO TO 999                                                         
C                                                                       
C  *** SAVE, THEN INITIALIZE IPIVOT ARRAY BEFORE COMPUTING G ***        
C                                                                       
 690  IV(1) = 2                                                         
      J = IV(IPIVOT)                                                    
      IPI = IV(PERM)                                                    
      CALL I7PNVR(P, IV(IPI), IV(J))                                    
      DO 700 I = 1, P                                                   
         IV(J) = I                                                      
         J = J + 1                                                      
 700     CONTINUE                                                       
C                                                                       
C  ***  PROJECT X INTO FEASIBLE REGION (PRIOR TO COMPUTING F OR G)  *** 
C                                                                       
 710  DO 720 I = 1, P                                                   
         IF (X(I) .LT. B(1,I)) X(I) = B(1,I)                            
         IF (X(I) .GT. B(2,I)) X(I) = B(2,I)                            
 720     CONTINUE                                                       
      IV(TOOBIG) = 0                                                    
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST LINE OF  G7ITB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE G7LIT(D, G, IV, LIV, LV, P, PS, V, X, Y)               
C                                                                       
C  ***  CARRY OUT NL2SOL-LIKE ITERATIONS FOR GENERALIZED LINEAR   ***   
C  ***  REGRESSION PROBLEMS (AND OTHERS OF SIMILAR STRUCTURE)     ***   
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LIV, LV, P, PS                                            
      INTEGER IV(LIV)                                                   
      REAL D(P), G(P), V(LV), X(P), Y(P)                                
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C D.... SCALE VECTOR.                                                   
C IV... INTEGER VALUE ARRAY.                                            
C LIV.. LENGTH OF IV.  MUST BE AT LEAST 82.                             
C LH... LENGTH OF H = P*(P+1)/2.                                        
C LV... LENGTH OF V.  MUST BE AT LEAST P*(3*P + 19)/2 + 7.              
C G.... GRADIENT AT X (WHEN IV(1) = 2).                                 
C P.... NUMBER OF PARAMETERS (COMPONENTS IN X).                         
C PS... NUMBER OF NONZERO ROWS AND COLUMNS IN S.                        
C V.... FLOATING-POINT VALUE ARRAY.                                     
C X.... PARAMETER VECTOR.                                               
C Y.... PART OF YIELD VECTOR (WHEN IV(1)= 2, SCRATCH OTHERWISE).        
C                                                                       
C  ***  DISCUSSION  ***                                                 
C                                                                       
C        G7LIT PERFORMS NL2SOL-LIKE ITERATIONS FOR A VARIETY OF         
C     REGRESSION PROBLEMS THAT ARE SIMILAR TO NONLINEAR LEAST-SQUARES   
C     IN THAT THE HESSIAN IS THE SUM OF TWO TERMS, A READILY-COMPUTED   
C     FIRST-ORDER TERM AND A SECOND-ORDER TERM.  THE CALLER SUPPLIES    
C     THE FIRST-ORDER TERM OF THE HESSIAN IN HC (LOWER TRIANGLE, STORED 
C     COMPACTLY BY ROWS IN V, STARTING AT IV(HC)), AND G7LIT BUILDS AN  
C     APPROXIMATION, S, TO THE SECOND-ORDER TERM.  THE CALLER ALSO      
C     PROVIDES THE FUNCTION VALUE, GRADIENT, AND PART OF THE YIELD      
C     VECTOR USED IN UPDATING S.  G7LIT DECIDES DYNAMICALLY WHETHER OR  
C     NOT TO USE S WHEN CHOOSING THE NEXT STEP TO TRY...  THE HESSIAN   
C     APPROXIMATION USED IS EITHER HC ALONE (GAUSS-NEWTON MODEL) OR     
C     HC + S (AUGMENTED MODEL).                                         
C                                                                       
C        IF PS .LT. P, THEN ROWS AND COLUMNS PS+1...P OF S ARE KEPT     
C     CONSTANT.  THEY WILL BE ZERO UNLESS THE CALLER SETS IV(INITS) TO  
C     1 OR 2 AND SUPPLIES NONZERO VALUES FOR THEM, OR THE CALLER SETS   
C     IV(INITS) TO 3 OR 4 AND THE FINITE-DIFFERENCE INITIAL S THEN      
C     COMPUTED HAS NONZERO VALUES IN THESE ROWS.                        
C                                                                       
C        IF IV(INITS) IS 3 OR 4, THEN THE INITIAL S IS COMPUTED BY      
C     FINITE DIFFERENCES.  3 MEANS USE FUNCTION DIFFERENCES, 4 MEANS    
C     USE GRADIENT DIFFERENCES.  FINITE DIFFERENCING IS DONE THE SAME   
C     WAY AS IN COMPUTING A COVARIANCE MATRIX (WITH IV(COVREQ) = -1, -2,
C     1, OR 2).                                                         
C                                                                       
C        FOR UPDATING S, G7LIT ASSUMES THAT THE GRADIENT HAS THE FORM   
C     OF A SUM OVER I OF RHO(I,X)*GRAD(R(I,X)), WHERE GRAD DENOTES THE  
C     GRADIENT WITH RESPECT TO X.  THE TRUE SECOND-ORDER TERM THEN IS   
C     THE SUM OVER I OF RHO(I,X)*HESSIAN(R(I,X)).  IF X = X0 + STEP,    
C     THEN WE WISH TO UPDATE S SO THAT S*STEP IS THE SUM OVER I OF      
C     RHO(I,X)*(GRAD(R(I,X)) - GRAD(R(I,X0))).  THE CALLER MUST SUPPLY  
C     PART OF THIS IN Y, NAMELY THE SUM OVER I OF                       
C     RHO(I,X)*GRAD(R(I,X0)), WHEN CALLING G7LIT WITH IV(1) = 2 AND     
C     IV(MODE) = 0 (WHERE MODE = 38).  G THEN CONTANS THE OTHER PART,   
C     SO THAT THE DESIRED YIELD VECTOR IS G - Y.  IF PS .LT. P, THEN    
C     THE ABOVE DISCUSSION APPLIES ONLY TO THE FIRST PS COMPONENTS OF   
C     GRAD(R(I,X)), STEP, AND Y.                                        
C                                                                       
C        PARAMETERS IV, P, V, AND X ARE THE SAME AS THE CORRESPONDING   
C     ONES TO NL2SOL (WHICH SEE), EXCEPT THAT V CAN BE SHORTER          
C     (SINCE THE PART OF V THAT NL2SOL USES FOR STORING D, J, AND R IS  
C     NOT NEEDED).  MOREOVER, COMPARED WITH NL2SOL, IV(1) MAY HAVE THE  
C     TWO ADDITIONAL OUTPUT VALUES 1 AND 2, WHICH ARE EXPLAINED BELOW,  
C     AS IS THE USE OF IV(TOOBIG) AND IV(NFGCAL).  THE VALUES IV(D),    
C     IV(J), AND IV(R), WHICH ARE OUTPUT VALUES FROM NL2SOL (AND        
C     NL2SNO), ARE NOT REFERENCED BY G7LIT OR THE SUBROUTINES IT CALLS. 
C                                                                       
C        WHEN G7LIT IS FIRST CALLED, I.E., WHEN G7LIT IS CALLED WITH    
C     IV(1) = 0 OR 12, V(F), G, AND HC NEED NOT BE INITIALIZED.  TO     
C     OBTAIN THESE STARTING VALUES, G7LIT RETURNS FIRST WITH IV(1) = 1, 
C     THEN WITH IV(1) = 2, WITH IV(MODE) = -1 IN BOTH CASES.  ON        
C     SUBSEQUENT RETURNS WITH IV(1) = 2, IV(MODE) = 0 IMPLIES THAT      
C     Y MUST ALSO BE SUPPLIED.  (NOTE THAT Y IS USED FOR SCRATCH -- ITS 
C     INPUT CONTENTS ARE LOST.  BY CONTRAST, HC IS NEVER CHANGED.)      
C     ONCE CONVERGENCE HAS BEEN OBTAINED, IV(RDREQ) AND IV(COVREQ) MAY  
C     IMPLY THAT A FINITE-DIFFERENCE HESSIAN SHOULD BE COMPUTED FOR USE 
C     IN COMPUTING A COVARIANCE MATRIX.  IN THIS CASE G7LIT WILL MAKE A 
C     NUMBER OF RETURNS WITH IV(1) = 1 OR 2 AND IV(MODE) POSITIVE.      
C     WHEN IV(MODE) IS POSITIVE, Y SHOULD NOT BE CHANGED.               
C                                                                       
C IV(1) = 1 MEANS THE CALLER SHOULD SET V(F) (I.E., V(10)) TO F(X), THE 
C             FUNCTION VALUE AT X, AND CALL G7LIT AGAIN, HAVING CHANGED 
C             NONE OF THE OTHER PARAMETERS.  AN EXCEPTION OCCURS IF F(X)
C             CANNOT BE EVALUATED (E.G. IF OVERFLOW WOULD OCCUR), WHICH 
C             MAY HAPPEN BECAUSE OF AN OVERSIZED STEP.  IN THIS CASE    
C             THE CALLER SHOULD SET IV(TOOBIG) = IV(2) TO 1, WHICH WILL 
C             CAUSE G7LIT TO IGNORE V(F) AND TRY A SMALLER STEP.  NOTE  
C             THAT THE CURRENT FUNCTION EVALUATION COUNT IS AVAILABLE   
C             IN IV(NFCALL) = IV(6).  THIS MAY BE USED TO IDENTIFY      
C             WHICH COPY OF SAVED INFORMATION SHOULD BE USED IN COM-    
C             PUTING G, HC, AND Y THE NEXT TIME G7LIT RETURNS WITH      
C             IV(1) = 2.  SEE MLPIT FOR AN EXAMPLE OF THIS.             
C IV(1) = 2 MEANS THE CALLER SHOULD SET G TO G(X), THE GRADIENT OF F AT 
C             X.  THE CALLER SHOULD ALSO SET HC TO THE GAUSS-NEWTON     
C             HESSIAN AT X.  IF IV(MODE) = 0, THEN THE CALLER SHOULD    
C             ALSO COMPUTE THE PART OF THE YIELD VECTOR DESCRIBED ABOVE.
C             THE CALLER SHOULD THEN CALL G7LIT AGAIN (WITH IV(1) = 2). 
C             THE CALLER MAY ALSO CHANGE D AT THIS TIME, BUT SHOULD NOT 
C             CHANGE X.  NOTE THAT IV(NFGCAL) = IV(7) CONTAINS THE      
C             VALUE THAT IV(NFCALL) HAD DURING THE RETURN WITH          
C             IV(1) = 1 IN WHICH X HAD THE SAME VALUE AS IT NOW HAS.    
C             IV(NFGCAL) IS EITHER IV(NFCALL) OR IV(NFCALL) - 1.  MLPIT 
C             IS AN EXAMPLE WHERE THIS INFORMATION IS USED.  IF G OR HC 
C             CANNOT BE EVALUATED AT X, THEN THE CALLER MAY SET         
C             IV(TOOBIG) TO 1, IN WHICH CASE G7LIT WILL RETURN WITH     
C             IV(1) = 15.                                               
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH           
C     SUPPORTED IN PART BY D.O.E. GRANT EX-76-A-01-2295 TO MIT/CCREMS.  
C                                                                       
C        (SEE NL2SOL FOR REFERENCES.)                                   
C                                                                       
C+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER DUMMY, DIG1, G01, H1, HC1, I, IPIV1, J, K, L, LMAT1,      
     1        LSTGST, PP1O2, QTR1, RMAT1, RSTRST, STEP1, STPMOD, S1,    
     2        TEMP1, TEMP2, W1, X01                                     
      REAL E, STTSST, T, T1                                             
C                                                                       
C     ***  CONSTANTS  ***                                               
C                                                                       
      REAL HALF, NEGONE, ONE, ONEP2, ZERO                               
C                                                                       
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      LOGICAL STOPX                                                     
      REAL  D7TPR,  L7SVX,  L7SVN,  RLDST,  R7MDC,  V2NRM               
      EXTERNAL A7SST,  D7TPR, F7HES, G7QTS, ITSUM,  L7MST, L7SRT,       
     1          L7SQR,  L7SVX,  L7SVN,  L7TVM, L7VML, PARCK,  RLDST,    
     2          R7MDC,  S7LUP,  S7LVM, STOPX, V2AXY, V7CPY,  V7SCP,     
     3          V2NRM                                                   
C                                                                       
C A7SST.... ASSESSES CANDIDATE STEP.                                    
C  D7TPR... RETURNS INNER PRODUCT OF TWO VECTORS.                       
C F7HES.... COMPUTE FINITE-DIFFERENCE HESSIAN (FOR COVARIANCE).         
C G7QTS.... COMPUTES GOLDFELD-QUANDT-TROTTER STEP (AUGMENTED MODEL).    
C ITSUM.... PRINTS ITERATION SUMMARY AND INFO ON INITIAL AND FINAL X.   
C  L7MST... COMPUTES LEVENBERG-MARQUARDT STEP (GAUSS-NEWTON MODEL).     
C L7SRT.... COMPUTES CHOLESKY FACTOR OF (LOWER TRIANG. OF) SYM. MATRIX. 
C  L7SQR... COMPUTES L * L**T FROM LOWER TRIANGULAR MATRIX L.           
C  L7TVM... COMPUTES L**T * V, V = VECTOR, L = LOWER TRIANGULAR MATRIX. 
C  L7SVX... ESTIMATES LARGEST SING. VALUE OF LOWER TRIANG. MATRIX.      
C  L7SVN... ESTIMATES SMALLEST SING. VALUE OF LOWER TRIANG. MATRIX.     
C L7VML.... COMPUTES L * V, V = VECTOR, L = LOWER TRIANGULAR MATRIX.    
C PARCK.... CHECK VALIDITY OF IV AND V INPUT COMPONENTS.                
C  RLDST... COMPUTES V(RELDX) = RELATIVE STEP SIZE.                     
C  R7MDC... RETURNS MACHINE-DEPENDENT CONSTANTS.                        
C  S7LUP... PERFORMS QUASI-NEWTON UPDATE ON COMPACTLY STORED LOWER TRI- 
C             ANGLE OF A SYMMETRIC MATRIX.                              
C STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.           
C V2AXY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.              
C V7CPY.... COPIES ONE VECTOR TO ANOTHER.                               
C  V7SCP... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.                  
C  V2NRM... RETURNS THE 2-NORM OF A VECTOR.                             
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER CNVCOD, COSMIN, COVMAT, COVREQ, DGNORM, DIG, DSTNRM, F,   
     1        FDH, FDIF, FUZZ, F0, GTSTEP, H, HC, IERR, INCFAC, INITS,  
     2        IPIVOT, IRC, KAGQT, KALM, LMAT, LMAX0, LMAXS, MODE, MODEL,
     3        MXFCAL, MXITER, NEXTV, NFCALL, NFGCAL, NFCOV, NGCOV,      
     4        NGCALL, NITER, NVSAVE, PHMXFC, PREDUC, QTR, RADFAC,       
     5        RADINC, RADIUS, RAD0, RCOND, RDREQ, REGD, RELDX, RESTOR,  
     6        RMAT, S, SIZE, STEP, STGLIM, STLSTG, STPPAR, SUSED,       
     7        SWITCH, TOOBIG, TUNER4, TUNER5, VNEED, VSAVE, W, WSCALE,  
     8        XIRC, X0                                                  
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA CNVCOD/55/, COVMAT/26/, COVREQ/15/, DIG/37/, FDH/74/, H/56/, 
C    1     HC/71/, IERR/75/, INITS/25/, IPIVOT/76/, IRC/29/, KAGQT/33/, 
C    2     KALM/34/, LMAT/42/, MODE/35/, MODEL/5/, MXFCAL/17/,          
C    3     MXITER/18/, NEXTV/47/, NFCALL/6/, NFGCAL/7/, NFCOV/52/,      
C    4     NGCOV/53/, NGCALL/30/, NITER/31/, QTR/77/, RADINC/8/,        
C    5     RDREQ/57/, REGD/67/, RESTOR/9/, RMAT/78/, S/62/, STEP/40/,   
C    6     STGLIM/11/, STLSTG/41/, SUSED/64/, SWITCH/12/, TOOBIG/2/,    
C    7     VNEED/4/, VSAVE/60/, W/65/, XIRC/13/, X0/43/                 
C/7                                                                     
      PARAMETER (CNVCOD=55, COVMAT=26, COVREQ=15, DIG=37, FDH=74, H=56, 
     1           HC=71, IERR=75, INITS=25, IPIVOT=76, IRC=29, KAGQT=33, 
     2           KALM=34, LMAT=42, MODE=35, MODEL=5, MXFCAL=17,         
     3           MXITER=18, NEXTV=47, NFCALL=6, NFGCAL=7, NFCOV=52,     
     4           NGCOV=53, NGCALL=30, NITER=31, QTR=77, RADINC=8,       
     5           RDREQ=57, REGD=67, RESTOR=9, RMAT=78, S=62, STEP=40,   
     6           STGLIM=11, STLSTG=41, SUSED=64, SWITCH=12, TOOBIG=2,   
     7           VNEED=4, VSAVE=60, W=65, XIRC=13, X0=43)               
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA COSMIN/47/, DGNORM/1/, DSTNRM/2/, F/10/, FDIF/11/, FUZZ/45/, 
C    1     F0/13/, GTSTEP/4/, INCFAC/23/, LMAX0/35/, LMAXS/36/,         
C    2     NVSAVE/9/, PHMXFC/21/, PREDUC/7/, RADFAC/16/, RADIUS/8/,     
C    3     RAD0/9/, RCOND/53/, RELDX/17/, SIZE/55/, STPPAR/5/,          
C    4     TUNER4/29/, TUNER5/30/, WSCALE/56/                           
C/7                                                                     
      PARAMETER (COSMIN=47, DGNORM=1, DSTNRM=2, F=10, FDIF=11, FUZZ=45, 
     1           F0=13, GTSTEP=4, INCFAC=23, LMAX0=35, LMAXS=36,        
     2           NVSAVE=9, PHMXFC=21, PREDUC=7, RADFAC=16, RADIUS=8,    
     3           RAD0=9, RCOND=53, RELDX=17, SIZE=55, STPPAR=5,         
     4           TUNER4=29, TUNER5=30, WSCALE=56)                       
C/                                                                      
C                                                                       
C                                                                       
C/6                                                                     
C     DATA HALF/0.5E+0/, NEGONE/-1.E+0/, ONE/1.E+0/, ONEP2/1.2E+0/,     
C    1     ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (HALF=0.5E+0, NEGONE=-1.E+0, ONE=1.E+0, ONEP2=1.2E+0,   
     1           ZERO=0.E+0)                                            
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      I = IV(1)                                                         
      IF (I .EQ. 1) GO TO 40                                            
      IF (I .EQ. 2) GO TO 50                                            
C                                                                       
      IF (I .EQ. 12 .OR. I .EQ. 13)                                     
     1     IV(VNEED) = IV(VNEED) + P*(3*P + 19)/2 + 7                   
      CALL PARCK(1, D, IV, LIV, LV, P, V)                               
      I = IV(1) - 2                                                     
      IF (I .GT. 12) GO TO 999                                          
      GO TO (290, 290, 290, 290, 290, 290, 170, 120, 170, 10, 10, 20), I
C                                                                       
C  ***  STORAGE ALLOCATION  ***                                         
C                                                                       
 10   PP1O2 = P * (P + 1) / 2                                           
      IV(S) = IV(LMAT) + PP1O2                                          
      IV(X0) = IV(S) + PP1O2                                            
      IV(STEP) = IV(X0) + P                                             
      IV(STLSTG) = IV(STEP) + P                                         
      IV(DIG) = IV(STLSTG) + P                                          
      IV(W) = IV(DIG) + P                                               
      IV(H) = IV(W) + 4*P + 7                                           
      IV(NEXTV) = IV(H) + PP1O2                                         
      IF (IV(1) .NE. 13) GO TO 20                                       
         IV(1) = 14                                                     
         GO TO 999                                                      
C                                                                       
C  ***  INITIALIZATION  ***                                             
C                                                                       
 20   IV(NITER) = 0                                                     
      IV(NFCALL) = 1                                                    
      IV(NGCALL) = 1                                                    
      IV(NFGCAL) = 1                                                    
      IV(MODE) = -1                                                     
      IV(STGLIM) = 2                                                    
      IV(TOOBIG) = 0                                                    
      IV(CNVCOD) = 0                                                    
      IV(COVMAT) = 0                                                    
      IV(NFCOV) = 0                                                     
      IV(NGCOV) = 0                                                     
      IV(RADINC) = 0                                                    
      IV(RESTOR) = 0                                                    
      IV(FDH) = 0                                                       
      V(RAD0) = ZERO                                                    
      V(STPPAR) = ZERO                                                  
      V(RADIUS) = V(LMAX0) / (ONE + V(PHMXFC))                          
C                                                                       
C  ***  SET INITIAL MODEL AND S MATRIX  ***                             
C                                                                       
      IV(MODEL) = 1                                                     
      IF (IV(S) .LT. 0) GO TO 999                                       
      IF (IV(INITS) .GT. 1) IV(MODEL) = 2                               
      S1 = IV(S)                                                        
      IF (IV(INITS) .EQ. 0 .OR. IV(INITS) .GT. 2)                       
     1   CALL  V7SCP(P*(P+1)/2, V(S1), ZERO)                            
      IV(1) = 1                                                         
      J = IV(IPIVOT)                                                    
      IF (J .LE. 0) GO TO 999                                           
      DO 30 I = 1, P                                                    
         IV(J) = I                                                      
         J = J + 1                                                      
 30      CONTINUE                                                       
      GO TO 999                                                         
C                                                                       
C  ***  NEW FUNCTION VALUE  ***                                         
C                                                                       
 40   IF (IV(MODE) .EQ. 0) GO TO 290                                    
      IF (IV(MODE) .GT. 0) GO TO 520                                    
C                                                                       
      IV(1) = 2                                                         
      IF (IV(TOOBIG) .EQ. 0) GO TO 999                                  
         IV(1) = 63                                                     
         GO TO 999                                                      
C                                                                       
C  ***  NEW GRADIENT  ***                                               
C                                                                       
 50   IV(KALM) = -1                                                     
      IV(KAGQT) = -1                                                    
      IV(FDH) = 0                                                       
      IF (IV(MODE) .GT. 0) GO TO 520                                    
C                                                                       
C  ***  MAKE SURE GRADIENT COULD BE COMPUTED  ***                       
C                                                                       
      IF (IV(TOOBIG) .EQ. 0) GO TO 60                                   
         IV(1) = 65                                                     
         GO TO 999                                                      
 60   IF (IV(HC) .LE. 0 .AND. IV(RMAT) .LE. 0) GO TO 610                
C                                                                       
C  ***  COMPUTE  D**-1 * GRADIENT  ***                                  
C                                                                       
      DIG1 = IV(DIG)                                                    
      K = DIG1                                                          
      DO 70 I = 1, P                                                    
         V(K) = G(I) / D(I)                                             
         K = K + 1                                                      
 70      CONTINUE                                                       
      V(DGNORM) =  V2NRM(P, V(DIG1))                                    
C                                                                       
      IF (IV(CNVCOD) .NE. 0) GO TO 510                                  
      IF (IV(MODE) .EQ. 0) GO TO 440                                    
      IV(MODE) = 0                                                      
      V(F0) = V(F)                                                      
      IF (IV(INITS) .LE. 2) GO TO 100                                   
C                                                                       
C  ***  ARRANGE FOR FINITE-DIFFERENCE INITIAL S  ***                    
C                                                                       
      IV(XIRC) = IV(COVREQ)                                             
      IV(COVREQ) = -1                                                   
      IF (IV(INITS) .GT. 3) IV(COVREQ) = 1                              
      IV(CNVCOD) = 70                                                   
      GO TO 530                                                         
C                                                                       
C  ***  COME TO NEXT STMT AFTER COMPUTING F.D. HESSIAN FOR INIT. S  *** 
C                                                                       
 80   IV(CNVCOD) = 0                                                    
      IV(MODE) = 0                                                      
      IV(NFCOV) = 0                                                     
      IV(NGCOV) = 0                                                     
      IV(COVREQ) = IV(XIRC)                                             
      S1 = IV(S)                                                        
      PP1O2 = PS * (PS + 1) / 2                                         
      HC1 = IV(HC)                                                      
      IF (HC1 .LE. 0) GO TO 90                                          
         CALL V2AXY(PP1O2, V(S1), NEGONE, V(HC1), V(H1))                
         GO TO 100                                                      
 90   RMAT1 = IV(RMAT)                                                  
      CALL  L7SQR(PS, V(S1), V(RMAT1))                                  
      CALL V2AXY(PP1O2, V(S1), NEGONE, V(S1), V(H1))                    
 100  IV(1) = 2                                                         
C                                                                       
C                                                                       
C-----------------------------  MAIN LOOP  -----------------------------
C                                                                       
C                                                                       
C  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***             
C                                                                       
 110  CALL ITSUM(D, G, IV, LIV, LV, P, V, X)                            
 120  K = IV(NITER)                                                     
      IF (K .LT. IV(MXITER)) GO TO 130                                  
         IV(1) = 10                                                     
         GO TO 999                                                      
 130  IV(NITER) = K + 1                                                 
C                                                                       
C  ***  UPDATE RADIUS  ***                                              
C                                                                       
      IF (K .EQ. 0) GO TO 150                                           
      STEP1 = IV(STEP)                                                  
      DO 140 I = 1, P                                                   
         V(STEP1) = D(I) * V(STEP1)                                     
         STEP1 = STEP1 + 1                                              
 140     CONTINUE                                                       
      STEP1 = IV(STEP)                                                  
      T = V(RADFAC) *  V2NRM(P, V(STEP1))                               
      IF (V(RADFAC) .LT. ONE .OR. T .GT. V(RADIUS)) V(RADIUS) = T       
C                                                                       
C  ***  INITIALIZE FOR START OF NEXT ITERATION  ***                     
C                                                                       
 150  X01 = IV(X0)                                                      
      V(F0) = V(F)                                                      
      IV(IRC) = 4                                                       
      IV(H) = -IABS(IV(H))                                              
      IV(SUSED) = IV(MODEL)                                             
C                                                                       
C     ***  COPY X TO X0  ***                                            
C                                                                       
      CALL V7CPY(P, V(X01), X)                                          
C                                                                       
C  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***                  
C                                                                       
 160  IF (.NOT. STOPX(DUMMY)) GO TO 180                                 
         IV(1) = 11                                                     
         GO TO 190                                                      
C                                                                       
C     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.  
C                                                                       
 170  IF (V(F) .GE. V(F0)) GO TO 180                                    
         V(RADFAC) = ONE                                                
         K = IV(NITER)                                                  
         GO TO 130                                                      
C                                                                       
 180  IF (IV(NFCALL) .LT. IV(MXFCAL) + IV(NFCOV)) GO TO 200             
         IV(1) = 9                                                      
 190     IF (V(F) .GE. V(F0)) GO TO 999                                 
C                                                                       
C        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH        
C        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.                
C                                                                       
              IV(CNVCOD) = IV(1)                                        
              GO TO 430                                                 
C                                                                       
C. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . . 
C                                                                       
 200  STEP1 = IV(STEP)                                                  
      W1 = IV(W)                                                        
      H1 = IV(H)                                                        
      T1 = ONE                                                          
      IF (IV(MODEL) .EQ. 2) GO TO 210                                   
         T1 = ZERO                                                      
C                                                                       
C        ***  COMPUTE LEVENBERG-MARQUARDT STEP IF POSSIBLE...           
C                                                                       
         RMAT1 = IV(RMAT)                                               
         IF (RMAT1 .LE. 0) GO TO 210                                    
         QTR1 = IV(QTR)                                                 
         IF (QTR1 .LE. 0) GO TO 210                                     
         IPIV1 = IV(IPIVOT)                                             
         CALL  L7MST(D, G, IV(IERR), IV(IPIV1), IV(KALM), P, V(QTR1),   
     1               V(RMAT1), V(STEP1), V, V(W1))                      
C        *** H IS STORED IN THE END OF W AND HAS JUST BEEN OVERWRITTEN, 
C        *** SO WE MARK IT INVALID...                                   
         IV(H) = -IABS(H1)                                              
C        *** EVEN IF H WERE STORED ELSEWHERE, IT WOULD BE NECESSARY TO  
C        *** MARK INVALID THE INFORMATION G7QTS MAY HAVE STORED IN V... 
         IV(KAGQT) = -1                                                 
         GO TO 260                                                      
C                                                                       
 210  IF (H1 .GT. 0) GO TO 250                                          
C                                                                       
C     ***  SET H TO  D**-1 * (HC + T1*S) * D**-1.  ***                  
C                                                                       
         H1 = -H1                                                       
         IV(H) = H1                                                     
         IV(FDH) = 0                                                    
         J = IV(HC)                                                     
         IF (J .GT. 0) GO TO 220                                        
            J = H1                                                      
            RMAT1 = IV(RMAT)                                            
            CALL  L7SQR(P, V(H1), V(RMAT1))                             
 220     S1 = IV(S)                                                     
         DO 240 I = 1, P                                                
              T = ONE / D(I)                                            
              DO 230 K = 1, I                                           
                   V(H1) = T * (V(J) + T1*V(S1)) / D(K)                 
                   J = J + 1                                            
                   H1 = H1 + 1                                          
                   S1 = S1 + 1                                          
 230               CONTINUE                                             
 240          CONTINUE                                                  
         H1 = IV(H)                                                     
         IV(KAGQT) = -1                                                 
C                                                                       
C  ***  COMPUTE ACTUAL GOLDFELD-QUANDT-TROTTER STEP  ***                
C                                                                       
 250  DIG1 = IV(DIG)                                                    
      LMAT1 = IV(LMAT)                                                  
      CALL G7QTS(D, V(DIG1), V(H1), IV(KAGQT), V(LMAT1), P, V(STEP1),   
     1            V, V(W1))                                             
      IF (IV(KALM) .GT. 0) IV(KALM) = 0                                 
C                                                                       
 260  IF (IV(IRC) .NE. 6) GO TO 270                                     
         IF (IV(RESTOR) .NE. 2) GO TO 290                               
         RSTRST = 2                                                     
         GO TO 300                                                      
C                                                                       
C  ***  CHECK WHETHER EVALUATING F(X0 + STEP) LOOKS WORTHWHILE  ***     
C                                                                       
 270  IV(TOOBIG) = 0                                                    
      IF (V(DSTNRM) .LE. ZERO) GO TO 290                                
      IF (IV(IRC) .NE. 5) GO TO 280                                     
      IF (V(RADFAC) .LE. ONE) GO TO 280                                 
      IF (V(PREDUC) .GT. ONEP2 * V(FDIF)) GO TO 280                     
         IF (IV(RESTOR) .NE. 2) GO TO 290                               
         RSTRST = 0                                                     
         GO TO 300                                                      
C                                                                       
C  ***  COMPUTE F(X0 + STEP)  ***                                       
C                                                                       
 280  X01 = IV(X0)                                                      
      STEP1 = IV(STEP)                                                  
      CALL V2AXY(P, X, ONE, V(STEP1), V(X01))                           
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 999                                                         
C                                                                       
C. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
C                                                                       
 290  RSTRST = 3                                                        
 300  X01 = IV(X0)                                                      
      V(RELDX) =  RLDST(P, D, X, V(X01))                                
      CALL A7SST(IV, LIV, LV, V)                                        
      STEP1 = IV(STEP)                                                  
      LSTGST = IV(STLSTG)                                               
      I = IV(RESTOR) + 1                                                
      GO TO (340, 310, 320, 330), I                                     
 310  CALL V7CPY(P, X, V(X01))                                          
      GO TO 340                                                         
 320   CALL V7CPY(P, V(LSTGST), V(STEP1))                               
       GO TO 340                                                        
 330     CALL V7CPY(P, V(STEP1), V(LSTGST))                             
         CALL V2AXY(P, X, ONE, V(STEP1), V(X01))                        
         V(RELDX) =  RLDST(P, D, X, V(X01))                             
         IV(RESTOR) = RSTRST                                            
C                                                                       
C  ***  IF NECESSARY, SWITCH MODELS  ***                                
C                                                                       
 340  IF (IV(SWITCH) .EQ. 0) GO TO 350                                  
         IV(H) = -IABS(IV(H))                                           
         IV(SUSED) = IV(SUSED) + 2                                      
         L = IV(VSAVE)                                                  
         CALL V7CPY(NVSAVE, V, V(L))                                    
 350  L = IV(IRC) - 4                                                   
      STPMOD = IV(MODEL)                                                
      IF (L .GT. 0) GO TO (370,380,390,390,390,390,390,390,500,440), L  
C                                                                       
C  ***  DECIDE WHETHER TO CHANGE MODELS  ***                            
C                                                                       
      E = V(PREDUC) - V(FDIF)                                           
      S1 = IV(S)                                                        
      CALL  S7LVM(PS, Y, V(S1), V(STEP1))                               
      STTSST = HALF *  D7TPR(PS, V(STEP1), Y)                           
      IF (IV(MODEL) .EQ. 1) STTSST = -STTSST                            
      IF ( ABS(E + STTSST) * V(FUZZ) .GE.  ABS(E)) GO TO 360            
C                                                                       
C     ***  SWITCH MODELS  ***                                           
C                                                                       
         IV(MODEL) = 3 - IV(MODEL)                                      
         IF (-2 .LT. L) GO TO 400                                       
              IV(H) = -IABS(IV(H))                                      
              IV(SUSED) = IV(SUSED) + 2                                 
              L = IV(VSAVE)                                             
              CALL V7CPY(NVSAVE, V(L), V)                               
              GO TO 160                                                 
C                                                                       
 360  IF (-3 .LT. L) GO TO 400                                          
C                                                                       
C  ***  RECOMPUTE STEP WITH NEW RADIUS  ***                             
C                                                                       
 370  V(RADIUS) = V(RADFAC) * V(DSTNRM)                                 
      GO TO 160                                                         
C                                                                       
C  ***  COMPUTE STEP OF LENGTH V(LMAXS) FOR SINGULAR CONVERGENCE TEST   
C                                                                       
 380  V(RADIUS) = V(LMAXS)                                              
      GO TO 200                                                         
C                                                                       
C  ***  CONVERGENCE OR FALSE CONVERGENCE  ***                           
C                                                                       
 390  IV(CNVCOD) = L                                                    
      IF (V(F) .GE. V(F0)) GO TO 510                                    
         IF (IV(XIRC) .EQ. 14) GO TO 510                                
              IV(XIRC) = 14                                             
C                                                                       
C. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
C                                                                       
 400  IV(COVMAT) = 0                                                    
      IV(REGD) = 0                                                      
C                                                                       
C  ***  SEE WHETHER TO SET V(RADFAC) BY GRADIENT TESTS  ***             
C                                                                       
      IF (IV(IRC) .NE. 3) GO TO 430                                     
         STEP1 = IV(STEP)                                               
         TEMP1 = IV(STLSTG)                                             
         TEMP2 = IV(W)                                                  
C                                                                       
C     ***  SET  TEMP1 = HESSIAN * STEP  FOR USE IN GRADIENT TESTS  ***  
C                                                                       
         HC1 = IV(HC)                                                   
         IF (HC1 .LE. 0) GO TO 410                                      
              CALL  S7LVM(P, V(TEMP1), V(HC1), V(STEP1))                
              GO TO 420                                                 
 410     RMAT1 = IV(RMAT)                                               
         CALL  L7TVM(P, V(TEMP1), V(RMAT1), V(STEP1))                   
         CALL L7VML(P, V(TEMP1), V(RMAT1), V(TEMP1))                    
C                                                                       
 420     IF (STPMOD .EQ. 1) GO TO 430                                   
              S1 = IV(S)                                                
              CALL  S7LVM(PS, V(TEMP2), V(S1), V(STEP1))                
              CALL V2AXY(PS, V(TEMP1), ONE, V(TEMP2), V(TEMP1))         
C                                                                       
C  ***  SAVE OLD GRADIENT AND COMPUTE NEW ONE  ***                      
C                                                                       
 430  IV(NGCALL) = IV(NGCALL) + 1                                       
      G01 = IV(W)                                                       
      CALL V7CPY(P, V(G01), G)                                          
      IV(1) = 2                                                         
      IV(TOOBIG) = 0                                                    
      GO TO 999                                                         
C                                                                       
C  ***  INITIALIZATIONS -- G0 = G - G0, ETC.  ***                       
C                                                                       
 440  G01 = IV(W)                                                       
      CALL V2AXY(P, V(G01), NEGONE, V(G01), G)                          
      STEP1 = IV(STEP)                                                  
      TEMP1 = IV(STLSTG)                                                
      TEMP2 = IV(W)                                                     
      IF (IV(IRC) .NE. 3) GO TO 470                                     
C                                                                       
C  ***  SET V(RADFAC) BY GRADIENT TESTS  ***                            
C                                                                       
C     ***  SET  TEMP1 = D**-1 * (HESSIAN * STEP  +  (G(X0) - G(X)))  ***
C                                                                       
         K = TEMP1                                                      
         L = G01                                                        
         DO 450 I = 1, P                                                
              V(K) = (V(K) - V(L)) / D(I)                               
              K = K + 1                                                 
              L = L + 1                                                 
 450          CONTINUE                                                  
C                                                                       
C        ***  DO GRADIENT TESTS  ***                                    
C                                                                       
         IF ( V2NRM(P, V(TEMP1)) .LE. V(DGNORM) * V(TUNER4))  GO TO 460 
              IF ( D7TPR(P, G, V(STEP1))                                
     1                  .GE. V(GTSTEP) * V(TUNER5))  GO TO 470          
 460               V(RADFAC) = V(INCFAC)                                
C                                                                       
C  ***  COMPUTE Y VECTOR NEEDED FOR UPDATING S  ***                     
C                                                                       
 470  CALL V2AXY(PS, Y, NEGONE, Y, G)                                   
C                                                                       
C  ***  DETERMINE SIZING FACTOR V(SIZE)  ***                            
C                                                                       
C     ***  SET TEMP1 = S * STEP  ***                                    
      S1 = IV(S)                                                        
      CALL  S7LVM(PS, V(TEMP1), V(S1), V(STEP1))                        
C                                                                       
      T1 =  ABS( D7TPR(PS, V(STEP1), V(TEMP1)))                         
      T =  ABS( D7TPR(PS, V(STEP1), Y))                                 
      V(SIZE) = ONE                                                     
      IF (T .LT. T1) V(SIZE) = T / T1                                   
C                                                                       
C  ***  SET G0 TO WCHMTD CHOICE OF FLETCHER AND AL-BAALI  ***           
C                                                                       
      HC1 = IV(HC)                                                      
      IF (HC1 .LE. 0) GO TO 480                                         
         CALL  S7LVM(PS, V(G01), V(HC1), V(STEP1))                      
         GO TO 490                                                      
C                                                                       
 480  RMAT1 = IV(RMAT)                                                  
      CALL  L7TVM(PS, V(G01), V(RMAT1), V(STEP1))                       
      CALL L7VML(PS, V(G01), V(RMAT1), V(G01))                          
C                                                                       
 490  CALL V2AXY(PS, V(G01), ONE, Y, V(G01))                            
C                                                                       
C  ***  UPDATE S  ***                                                   
C                                                                       
      CALL  S7LUP(V(S1), V(COSMIN), PS, V(SIZE), V(STEP1), V(TEMP1),    
     1            V(TEMP2), V(G01), V(WSCALE), Y)                       
      IV(1) = 2                                                         
      GO TO 110                                                         
C                                                                       
C. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
C                                                                       
C  ***  BAD PARAMETERS TO ASSESS  ***                                   
C                                                                       
 500  IV(1) = 64                                                        
      GO TO 999                                                         
C                                                                       
C                                                                       
C  ***  CONVERGENCE OBTAINED -- SEE WHETHER TO COMPUTE COVARIANCE  ***  
C                                                                       
 510  IF (IV(RDREQ) .EQ. 0) GO TO 600                                   
      IF (IV(FDH) .NE. 0) GO TO 600                                     
      IF (IV(CNVCOD) .GE. 7) GO TO 600                                  
      IF (IV(REGD) .GT. 0) GO TO 600                                    
      IF (IV(COVMAT) .GT. 0) GO TO 600                                  
      IF (IABS(IV(COVREQ)) .GE. 3) GO TO 560                            
      IF (IV(RESTOR) .EQ. 0) IV(RESTOR) = 2                             
      GO TO 530                                                         
C                                                                       
C  ***  COMPUTE FINITE-DIFFERENCE HESSIAN FOR COMPUTING COVARIANCE  *** 
C                                                                       
 520  IV(RESTOR) = 0                                                    
 530  CALL F7HES(D, G, I, IV, LIV, LV, P, V, X)                         
      GO TO (540, 550, 580), I                                          
 540  IV(NFCOV) = IV(NFCOV) + 1                                         
      IV(NFCALL) = IV(NFCALL) + 1                                       
      IV(1) = 1                                                         
      GO TO 999                                                         
C                                                                       
 550  IV(NGCOV) = IV(NGCOV) + 1                                         
      IV(NGCALL) = IV(NGCALL) + 1                                       
      IV(NFGCAL) = IV(NFCALL) + IV(NGCOV)                               
      IV(1) = 2                                                         
      GO TO 999                                                         
C                                                                       
 560  H1 = IABS(IV(H))                                                  
      IV(H) = -H1                                                       
      PP1O2 = P * (P + 1) / 2                                           
      RMAT1 = IV(RMAT)                                                  
      IF (RMAT1 .LE. 0) GO TO 570                                       
           LMAT1 = IV(LMAT)                                             
           CALL V7CPY(PP1O2, V(LMAT1), V(RMAT1))                        
           V(RCOND) = ZERO                                              
           GO TO 590                                                    
 570  HC1 = IV(HC)                                                      
      IV(FDH) = H1                                                      
      CALL V7CPY(P*(P+1)/2, V(H1), V(HC1))                              
C                                                                       
C  ***  COMPUTE CHOLESKY FACTOR OF FINITE-DIFFERENCE HESSIAN            
C  ***  FOR USE IN CALLER*S COVARIANCE CALCULATION...                   
C                                                                       
 580  LMAT1 = IV(LMAT)                                                  
      H1 = IV(FDH)                                                      
      IF (H1 .LE. 0) GO TO 600                                          
      IF (IV(CNVCOD) .EQ. 70) GO TO 80                                  
      CALL L7SRT(1, P, V(LMAT1), V(H1), I)                              
      IV(FDH) = -1                                                      
      V(RCOND) = ZERO                                                   
      IF (I .NE. 0) GO TO 600                                           
C                                                                       
 590  IV(FDH) = -1                                                      
      STEP1 = IV(STEP)                                                  
      T =  L7SVN(P, V(LMAT1), V(STEP1), V(STEP1))                       
      IF (T .LE. ZERO) GO TO 600                                        
      T = T /  L7SVX(P, V(LMAT1), V(STEP1), V(STEP1))                   
      IF (T .GT.  R7MDC(4)) IV(FDH) = H1                                
      V(RCOND) = T                                                      
C                                                                       
 600  IV(MODE) = 0                                                      
      IV(1) = IV(CNVCOD)                                                
      IV(CNVCOD) = 0                                                    
      GO TO 999                                                         
C                                                                       
C  ***  SPECIAL RETURN FOR MISSING HESSIAN INFORMATION -- BOTH          
C  ***  IV(HC) .LE. 0 AND IV(RMAT) .LE. 0                               
C                                                                       
 610  IV(1) = 1400                                                      
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST LINE OF G7LIT FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE A7SST(IV, LIV, LV, V)                                  
C                                                                       
C  ***  ASSESS CANDIDATE STEP (***SOL VERSION 2.3)  ***                 
C                                                                       
      INTEGER LIV, LV                                                   
      INTEGER IV(LIV)                                                   
      REAL V(LV)                                                        
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        THIS SUBROUTINE IS CALLED BY AN UNCONSTRAINED MINIMIZATION     
C     ROUTINE TO ASSESS THE NEXT CANDIDATE STEP.  IT MAY RECOMMEND ONE  
C     OF SEVERAL COURSES OF ACTION, SUCH AS ACCEPTING THE STEP, RECOM-  
C     PUTING IT USING THE SAME OR A NEW QUADRATIC MODEL, OR HALTING DUE 
C     TO CONVERGENCE OR FALSE CONVERGENCE.  SEE THE RETURN CODE LISTING 
C     BELOW.                                                            
C                                                                       
C--------------------------  PARAMETER USAGE  --------------------------
C                                                                       
C  IV (I/O) INTEGER PARAMETER AND SCRATCH VECTOR -- SEE DESCRIPTION     
C             BELOW OF IV VALUES REFERENCED.                            
C LIV (IN)  LENGTH OF IV ARRAY.                                         
C  LV (IN)  LENGTH OF V ARRAY.                                          
C   V (I/O) REAL PARAMETER AND SCRATCH VECTOR -- SEE DESCRIPTION        
C             BELOW OF V VALUES REFERENCED.                             
C                                                                       
C  ***  IV VALUES REFERENCED  ***                                       
C                                                                       
C    IV(IRC) (I/O) ON INPUT FOR THE FIRST STEP TRIED IN A NEW ITERATION,
C             IV(IRC) SHOULD BE SET TO 3 OR 4 (THE VALUE TO WHICH IT IS 
C             SET WHEN STEP IS DEFINITELY TO BE ACCEPTED).  ON INPUT    
C             AFTER STEP HAS BEEN RECOMPUTED, IV(IRC) SHOULD BE         
C             UNCHANGED SINCE THE PREVIOUS RETURN OF A7SST.             
C                ON OUTPUT, IV(IRC) IS A RETURN CODE HAVING ONE OF THE  
C             FOLLOWING VALUES...                                       
C                  1 = SWITCH MODELS OR TRY SMALLER STEP.               
C                  2 = SWITCH MODELS OR ACCEPT STEP.                    
C                  3 = ACCEPT STEP AND DETERMINE V(RADFAC) BY GRADIENT  
C                       TESTS.                                          
C                  4 = ACCEPT STEP, V(RADFAC) HAS BEEN DETERMINED.      
C                  5 = RECOMPUTE STEP (USING THE SAME MODEL).           
C                  6 = RECOMPUTE STEP WITH RADIUS = V(LMAXS) BUT DO NOT 
C                       EVAULATE THE OBJECTIVE FUNCTION.                
C                  7 = X-CONVERGENCE (SEE V(XCTOL)).                    
C                  8 = RELATIVE FUNCTION CONVERGENCE (SEE V(RFCTOL)).   
C                  9 = BOTH X- AND RELATIVE FUNCTION CONVERGENCE.       
C                 10 = ABSOLUTE FUNCTION CONVERGENCE (SEE V(AFCTOL)).   
C                 11 = SINGULAR CONVERGENCE (SEE V(LMAXS)).             
C                 12 = FALSE CONVERGENCE (SEE V(XFTOL)).                
C                 13 = IV(IRC) WAS OUT OF RANGE ON INPUT.               
C             RETURN CODE I HAS PRECDENCE OVER I+1 FOR I = 9, 10, 11.   
C IV(MLSTGD) (I/O) SAVED VALUE OF IV(MODEL).                            
C  IV(MODEL) (I/O) ON INPUT, IV(MODEL) SHOULD BE AN INTEGER IDENTIFYING 
C             THE CURRENT QUADRATIC MODEL OF THE OBJECTIVE FUNCTION.    
C             IF A PREVIOUS STEP YIELDED A BETTER FUNCTION REDUCTION,   
C             THEN IV(MODEL) WILL BE SET TO IV(MLSTGD) ON OUTPUT.       
C IV(NFCALL) (IN)  INVOCATION COUNT FOR THE OBJECTIVE FUNCTION.         
C IV(NFGCAL) (I/O) VALUE OF IV(NFCALL) AT STEP THAT GAVE THE BIGGEST    
C             FUNCTION REDUCTION THIS ITERATION.  IV(NFGCAL) REMAINS    
C             UNCHANGED UNTIL A FUNCTION REDUCTION IS OBTAINED.         
C IV(RADINC) (I/O) THE NUMBER OF RADIUS INCREASES (OR MINUS THE NUMBER  
C             OF DECREASES) SO FAR THIS ITERATION.                      
C IV(RESTOR) (OUT) SET TO 1 IF V(F) HAS BEEN RESTORED AND X SHOULD BE   
C             RESTORED TO ITS INITIAL VALUE, TO 2 IF X SHOULD BE SAVED, 
C             TO 3 IF X SHOULD BE RESTORED FROM THE SAVED VALUE, AND TO 
C             0 OTHERWISE.                                              
C  IV(STAGE) (I/O) COUNT OF THE NUMBER OF MODELS TRIED SO FAR IN THE    
C             CURRENT ITERATION.                                        
C IV(STGLIM) (IN)  MAXIMUM NUMBER OF MODELS TO CONSIDER.                
C IV(SWITCH) (OUT) SET TO 0 UNLESS A NEW MODEL IS BEING TRIED AND IT    
C             GIVES A SMALLER FUNCTION VALUE THAN THE PREVIOUS MODEL,   
C             IN WHICH CASE A7SST SETS IV(SWITCH) = 1.                  
C IV(TOOBIG) (IN)  IS NONZERO IF STEP WAS TOO BIG (E.G. IF IT CAUSED    
C             OVERFLOW).                                                
C   IV(XIRC) (I/O) VALUE THAT IV(IRC) WOULD HAVE IN THE ABSENCE OF      
C             CONVERGENCE, FALSE CONVERGENCE, AND OVERSIZED STEPS.      
C                                                                       
C  ***  V VALUES REFERENCED  ***                                        
C                                                                       
C V(AFCTOL) (IN)  ABSOLUTE FUNCTION CONVERGENCE TOLERANCE.  IF THE      
C             ABSOLUTE VALUE OF THE CURRENT FUNCTION VALUE V(F) IS LESS 
C             THAN V(AFCTOL), THEN A7SST RETURNS WITH IV(IRC) = 10.     
C V(DECFAC) (IN)  FACTOR BY WHICH TO DECREASE RADIUS WHEN IV(TOOBIG) IS 
C             NONZERO.                                                  
C V(DSTNRM) (IN)  THE 2-NORM OF D*STEP.                                 
C V(DSTSAV) (I/O) VALUE OF V(DSTNRM) ON SAVED STEP.                     
C   V(DST0) (IN)  THE 2-NORM OF D TIMES THE NEWTON STEP (WHEN DEFINED,  
C             I.E., FOR V(NREDUC) .GE. 0).                              
C      V(F) (I/O) ON BOTH INPUT AND OUTPUT, V(F) IS THE OBJECTIVE FUNC- 
C             TION VALUE AT X.  IF X IS RESTORED TO A PREVIOUS VALUE,   
C             THEN V(F) IS RESTORED TO THE CORRESPONDING VALUE.         
C   V(FDIF) (OUT) THE FUNCTION REDUCTION V(F0) - V(F) (FOR THE OUTPUT   
C             VALUE OF V(F) IF AN EARLIER STEP GAVE A BIGGER FUNCTION   
C             DECREASE, AND FOR THE INPUT VALUE OF V(F) OTHERWISE).     
C V(FLSTGD) (I/O) SAVED VALUE OF V(F).                                  
C     V(F0) (IN)  OBJECTIVE FUNCTION VALUE AT START OF ITERATION.       
C V(GTSLST) (I/O) VALUE OF V(GTSTEP) ON SAVED STEP.                     
C V(GTSTEP) (IN)  INNER PRODUCT BETWEEN STEP AND GRADIENT.              
C V(INCFAC) (IN)  MINIMUM FACTOR BY WHICH TO INCREASE RADIUS.           
C  V(LMAXS) (IN)  MAXIMUM REASONABLE STEP SIZE (AND INITIAL STEP BOUND).
C             IF THE ACTUAL FUNCTION DECREASE IS NO MORE THAN TWICE     
C             WHAT WAS PREDICTED, IF A RETURN WITH IV(IRC) = 7, 8, 9,   
C             OR 10 DOES NOT OCCUR, IF V(DSTNRM) .GT. V(LMAXS), AND IF  
C             V(PREDUC) .LE. V(SCTOL) * ABS(V(F0)), THEN A7SST RE-      
C             TURNS WITH IV(IRC) = 11.  IF SO DOING APPEARS WORTHWHILE, 
C             THEN A7SST REPEATS THIS TEST WITH V(PREDUC) COMPUTED FOR  
C             A STEP OF LENGTH V(LMAXS) (BY A RETURN WITH IV(IRC) = 6). 
C V(NREDUC) (I/O)  FUNCTION REDUCTION PREDICTED BY QUADRATIC MODEL FOR  
C             NEWTON STEP.  IF A7SST IS CALLED WITH IV(IRC) = 6, I.E.,  
C             IF V(PREDUC) HAS BEEN COMPUTED WITH RADIUS = V(LMAXS) FOR 
C             USE IN THE SINGULAR CONVERVENCE TEST, THEN V(NREDUC) IS   
C             SET TO -V(PREDUC) BEFORE THE LATTER IS RESTORED.          
C V(PLSTGD) (I/O) VALUE OF V(PREDUC) ON SAVED STEP.                     
C V(PREDUC) (I/O) FUNCTION REDUCTION PREDICTED BY QUADRATIC MODEL FOR   
C             CURRENT STEP.                                             
C V(RADFAC) (OUT) FACTOR TO BE USED IN DETERMINING THE NEW RADIUS,      
C             WHICH SHOULD BE V(RADFAC)*DST, WHERE  DST  IS EITHER THE  
C             OUTPUT VALUE OF V(DSTNRM) OR THE 2-NORM OF                
C             DIAG(NEWD)*STEP  FOR THE OUTPUT VALUE OF STEP AND THE     
C             UPDATED VERSION, NEWD, OF THE SCALE VECTOR D.  FOR        
C             IV(IRC) = 3, V(RADFAC) = 1.0 IS RETURNED.                 
C V(RDFCMN) (IN)  MINIMUM VALUE FOR V(RADFAC) IN TERMS OF THE INPUT     
C             VALUE OF V(DSTNRM) -- SUGGESTED VALUE = 0.1.              
C V(RDFCMX) (IN)  MAXIMUM VALUE FOR V(RADFAC) -- SUGGESTED VALUE = 4.0. 
C  V(RELDX) (IN) SCALED RELATIVE CHANGE IN X CAUSED BY STEP, COMPUTED   
C             (E.G.) BY FUNCTION   RLDST  AS                            
C                 MAX (D(I)*ABS(X(I)-X0(I)), 1 .LE. I .LE. P) /         
C                    MAX (D(I)*(ABS(X(I))+ABS(X0(I))), 1 .LE. I .LE. P).
C V(RFCTOL) (IN)  RELATIVE FUNCTION CONVERGENCE TOLERANCE.  IF THE      
C             ACTUAL FUNCTION REDUCTION IS AT MOST TWICE WHAT WAS PRE-  
C             DICTED AND  V(NREDUC) .LE. V(RFCTOL)*ABS(V(F0)),  THEN    
C             A7SST RETURNS WITH IV(IRC) = 8 OR 9.                      
C V(STPPAR) (IN)  MARQUARDT PARAMETER -- 0 MEANS FULL NEWTON STEP.      
C V(TUNER1) (IN)  TUNING CONSTANT USED TO DECIDE IF THE FUNCTION        
C             REDUCTION WAS MUCH LESS THAN EXPECTED.  SUGGESTED         
C             VALUE = 0.1.                                              
C V(TUNER2) (IN)  TUNING CONSTANT USED TO DECIDE IF THE FUNCTION        
C             REDUCTION WAS LARGE ENOUGH TO ACCEPT STEP.  SUGGESTED     
C             VALUE = 10**-4.                                           
C V(TUNER3) (IN)  TUNING CONSTANT USED TO DECIDE IF THE RADIUS          
C             SHOULD BE INCREASED.  SUGGESTED VALUE = 0.75.             
C  V(XCTOL) (IN)  X-CONVERGENCE CRITERION.  IF STEP IS A NEWTON STEP    
C             (V(STPPAR) = 0) HAVING V(RELDX) .LE. V(XCTOL) AND GIVING  
C             AT MOST TWICE THE PREDICTED FUNCTION DECREASE, THEN       
C             A7SST RETURNS IV(IRC) = 7 OR 9.                           
C  V(XFTOL) (IN)  FALSE CONVERGENCE TOLERANCE.  IF STEP GAVE NO OR ONLY 
C             A SMALL FUNCTION DECREASE AND V(RELDX) .LE. V(XFTOL),     
C             THEN A7SST RETURNS WITH IV(IRC) = 12.                     
C                                                                       
C-------------------------------  NOTES  -------------------------------
C                                                                       
C  ***  APPLICATION AND USAGE RESTRICTIONS  ***                         
C                                                                       
C        THIS ROUTINE IS CALLED AS PART OF THE NL2SOL (NONLINEAR        
C     LEAST-SQUARES) PACKAGE.  IT MAY BE USED IN ANY UNCONSTRAINED      
C     MINIMIZATION SOLVER THAT USES DOGLEG, GOLDFELD-QUANDT-TROTTER,    
C     OR LEVENBERG-MARQUARDT STEPS.                                     
C                                                                       
C  ***  ALGORITHM NOTES  ***                                            
C                                                                       
C        SEE (1) FOR FURTHER DISCUSSION OF THE ASSESSING AND MODEL      
C     SWITCHING STRATEGIES.  WHILE NL2SOL CONSIDERS ONLY TWO MODELS,    
C     A7SST IS DESIGNED TO HANDLE ANY NUMBER OF MODELS.                 
C                                                                       
C  ***  USAGE NOTES  ***                                                
C                                                                       
C        ON THE FIRST CALL OF AN ITERATION, ONLY THE I/O VARIABLES      
C     STEP, X, IV(IRC), IV(MODEL), V(F), V(DSTNRM), V(GTSTEP), AND      
C     V(PREDUC) NEED HAVE BEEN INITIALIZED.  BETWEEN CALLS, NO I/O      
C     VALUES EXECPT STEP, X, IV(MODEL), V(F) AND THE STOPPING TOLER-    
C     ANCES SHOULD BE CHANGED.                                          
C        AFTER A RETURN FOR CONVERGENCE OR FALSE CONVERGENCE, ONE CAN   
C     CHANGE THE STOPPING TOLERANCES AND CALL A7SST AGAIN, IN WHICH     
C     CASE THE STOPPING TESTS WILL BE REPEATED.                         
C                                                                       
C  ***  REFERENCES  ***                                                 
C                                                                       
C     (1) DENNIS, J.E., JR., GAY, D.M., AND WELSCH, R.E. (1981),        
C        AN ADAPTIVE NONLINEAR LEAST-SQUARES ALGORITHM,                 
C        ACM TRANS. MATH. SOFTWARE, VOL. 7, NO. 3.                      
C                                                                       
C     (2) POWELL, M.J.D. (1970)  A FORTRAN SUBROUTINE FOR SOLVING       
C        SYSTEMS OF NONLINEAR ALGEBRAIC EQUATIONS, IN NUMERICAL         
C        METHODS FOR NONLINEAR ALGEBRAIC EQUATIONS, EDITED BY           
C        P. RABINOWITZ, GORDON AND BREACH, LONDON.                      
C                                                                       
C  ***  HISTORY  ***                                                    
C                                                                       
C        JOHN DENNIS DESIGNED MUCH OF THIS ROUTINE, STARTING WITH       
C     IDEAS IN (2). ROY WELSCH SUGGESTED THE MODEL SWITCHING STRATEGY.  
C        DAVID GAY AND STEPHEN PETERS CAST THIS SUBROUTINE INTO A MORE  
C     PORTABLE FORM (WINTER 1977), AND DAVID GAY CAST IT INTO ITS       
C     PRESENT FORM (FALL 1978).                                         
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH           
C     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS         
C     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND           
C     MCS-7906671.                                                      
C                                                                       
C------------------------  EXTERNAL QUANTITIES  ------------------------
C                                                                       
C  ***  NO EXTERNAL FUNCTIONS AND SUBROUTINES  ***                      
C                                                                       
C--------------------------  LOCAL VARIABLES  --------------------------
C                                                                       
      LOGICAL GOODX                                                     
      INTEGER I, NFC                                                    
      REAL EMAX, EMAXS, GTS, RFAC1, XMAX                                
      REAL HALF, ONE, ONEP2, TWO, ZERO                                  
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER AFCTOL, DECFAC, DSTNRM, DSTSAV, DST0, F, FDIF, FLSTGD, F0,
     1        GTSLST, GTSTEP, INCFAC, IRC, LMAXS, MLSTGD, MODEL, NFCALL,
     2        NFGCAL, NREDUC, PLSTGD, PREDUC, RADFAC, RADINC, RDFCMN,   
     3        RDFCMX, RELDX, RESTOR, RFCTOL, SCTOL, STAGE, STGLIM,      
     4        STPPAR, SWITCH, TOOBIG, TUNER1, TUNER2, TUNER3, XCTOL,    
     5        XFTOL, XIRC                                               
C                                                                       
C  ***  DATA INITIALIZATIONS  ***                                       
C                                                                       
C/6                                                                     
C     DATA HALF/0.5E+0/, ONE/1.E+0/, ONEP2/1.2E+0/, TWO/2.E+0/,         
C    1     ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (HALF=0.5E+0, ONE=1.E+0, ONEP2=1.2E+0, TWO=2.E+0,       
     1           ZERO=0.E+0)                                            
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA IRC/29/, MLSTGD/32/, MODEL/5/, NFCALL/6/, NFGCAL/7/,         
C    1     RADINC/8/, RESTOR/9/, STAGE/10/, STGLIM/11/, SWITCH/12/,     
C    2     TOOBIG/2/, XIRC/13/                                          
C/7                                                                     
      PARAMETER (IRC=29, MLSTGD=32, MODEL=5, NFCALL=6, NFGCAL=7,        
     1           RADINC=8, RESTOR=9, STAGE=10, STGLIM=11, SWITCH=12,    
     2           TOOBIG=2, XIRC=13)                                     
C/                                                                      
C/6                                                                     
C     DATA AFCTOL/31/, DECFAC/22/, DSTNRM/2/, DST0/3/, DSTSAV/18/,      
C    1     F/10/, FDIF/11/, FLSTGD/12/, F0/13/, GTSLST/14/, GTSTEP/4/,  
C    2     INCFAC/23/, LMAXS/36/, NREDUC/6/, PLSTGD/15/, PREDUC/7/,     
C    3     RADFAC/16/, RDFCMN/24/, RDFCMX/25/, RELDX/17/, RFCTOL/32/,   
C    4     SCTOL/37/, STPPAR/5/, TUNER1/26/, TUNER2/27/, TUNER3/28/,    
C    5     XCTOL/33/, XFTOL/34/                                         
C/7                                                                     
      PARAMETER (AFCTOL=31, DECFAC=22, DSTNRM=2, DST0=3, DSTSAV=18,     
     1           F=10, FDIF=11, FLSTGD=12, F0=13, GTSLST=14, GTSTEP=4,  
     2           INCFAC=23, LMAXS=36, NREDUC=6, PLSTGD=15, PREDUC=7,    
     3           RADFAC=16, RDFCMN=24, RDFCMX=25, RELDX=17, RFCTOL=32,  
     4           SCTOL=37, STPPAR=5, TUNER1=26, TUNER2=27, TUNER3=28,   
     5           XCTOL=33, XFTOL=34)                                    
C/                                                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      NFC = IV(NFCALL)                                                  
      IV(SWITCH) = 0                                                    
      IV(RESTOR) = 0                                                    
      RFAC1 = ONE                                                       
      GOODX = .TRUE.                                                    
      I = IV(IRC)                                                       
      IF (I .GE. 1 .AND. I .LE. 12)                                     
     1             GO TO (20,30,10,10,40,280,220,220,220,220,220,170), I
         IV(IRC) = 13                                                   
         GO TO 999                                                      
C                                                                       
C  ***  INITIALIZE FOR NEW ITERATION  ***                               
C                                                                       
 10   IV(STAGE) = 1                                                     
      IV(RADINC) = 0                                                    
      V(FLSTGD) = V(F0)                                                 
      IF (IV(TOOBIG) .EQ. 0) GO TO 110                                  
         IV(STAGE) = -1                                                 
         IV(XIRC) = I                                                   
         GO TO 60                                                       
C                                                                       
C  ***  STEP WAS RECOMPUTED WITH NEW MODEL OR SMALLER RADIUS  ***       
C  ***  FIRST DECIDE WHICH  ***                                         
C                                                                       
 20   IF (IV(MODEL) .NE. IV(MLSTGD)) GO TO 30                           
C        ***  OLD MODEL RETAINED, SMALLER RADIUS TRIED  ***             
C        ***  DO NOT CONSIDER ANY MORE NEW MODELS THIS ITERATION  ***   
         IV(STAGE) = IV(STGLIM)                                         
         IV(RADINC) = -1                                                
         GO TO 110                                                      
C                                                                       
C  ***  A NEW MODEL IS BEING TRIED.  DECIDE WHETHER TO KEEP IT.  ***    
C                                                                       
 30   IV(STAGE) = IV(STAGE) + 1                                         
C                                                                       
C     ***  NOW WE ADD THE POSSIBILTIY THAT STEP WAS RECOMPUTED WITH  ***
C     ***  THE SAME MODEL, PERHAPS BECAUSE OF AN OVERSIZED STEP.     ***
C                                                                       
 40   IF (IV(STAGE) .GT. 0) GO TO 50                                    
C                                                                       
C        ***  STEP WAS RECOMPUTED BECAUSE IT WAS TOO BIG.  ***          
C                                                                       
         IF (IV(TOOBIG) .NE. 0) GO TO 60                                
C                                                                       
C        ***  RESTORE IV(STAGE) AND PICK UP WHERE WE LEFT OFF.  ***     
C                                                                       
         IV(STAGE) = -IV(STAGE)                                         
         I = IV(XIRC)                                                   
         GO TO (20, 30, 110, 110, 70), I                                
C                                                                       
 50   IF (IV(TOOBIG) .EQ. 0) GO TO 70                                   
C                                                                       
C  ***  HANDLE OVERSIZE STEP  ***                                       
C                                                                       
      IF (IV(RADINC) .GT. 0) GO TO 80                                   
         IV(STAGE) = -IV(STAGE)                                         
         IV(XIRC) = IV(IRC)                                             
C                                                                       
 60      V(RADFAC) = V(DECFAC)                                          
         IV(RADINC) = IV(RADINC) - 1                                    
         IV(IRC) = 5                                                    
         IV(RESTOR) = 1                                                 
         GO TO 999                                                      
C                                                                       
 70   IF (V(F) .LT. V(FLSTGD)) GO TO 110                                
C                                                                       
C     *** THE NEW STEP IS A LOSER.  RESTORE OLD MODEL.  ***             
C                                                                       
      IF (IV(MODEL) .EQ. IV(MLSTGD)) GO TO 80                           
         IV(MODEL) = IV(MLSTGD)                                         
         IV(SWITCH) = 1                                                 
C                                                                       
C     ***  RESTORE STEP, ETC. ONLY IF A PREVIOUS STEP DECREASED V(F).   
C                                                                       
 80   IF (V(FLSTGD) .GE. V(F0)) GO TO 110                               
         IV(RESTOR) = 1                                                 
         V(F) = V(FLSTGD)                                               
         V(PREDUC) = V(PLSTGD)                                          
         V(GTSTEP) = V(GTSLST)                                          
         IF (IV(SWITCH) .EQ. 0) RFAC1 = V(DSTNRM) / V(DSTSAV)           
         V(DSTNRM) = V(DSTSAV)                                          
         NFC = IV(NFGCAL)                                               
         GOODX = .FALSE.                                                
C                                                                       
 110  V(FDIF) = V(F0) - V(F)                                            
      IF (V(FDIF) .GT. V(TUNER2) * V(PREDUC)) GO TO 140                 
      IF (IV(RADINC) .GT. 0) GO TO 140                                  
C                                                                       
C        ***  NO (OR ONLY A TRIVIAL) FUNCTION DECREASE                  
C        ***  -- SO TRY NEW MODEL OR SMALLER RADIUS                     
C                                                                       
         IF (V(F) .LT. V(F0)) GO TO 120                                 
              IV(MLSTGD) = IV(MODEL)                                    
              V(FLSTGD) = V(F)                                          
              V(F) = V(F0)                                              
              IV(RESTOR) = 1                                            
              GO TO 130                                                 
 120     IV(NFGCAL) = NFC                                               
 130     IV(IRC) = 1                                                    
         IF (IV(STAGE) .LT. IV(STGLIM)) GO TO 160                       
              IV(IRC) = 5                                               
              IV(RADINC) = IV(RADINC) - 1                               
              GO TO 160                                                 
C                                                                       
C  ***  NONTRIVIAL FUNCTION DECREASE ACHIEVED  ***                      
C                                                                       
 140  IV(NFGCAL) = NFC                                                  
      RFAC1 = ONE                                                       
      V(DSTSAV) = V(DSTNRM)                                             
      IF (V(FDIF) .GT. V(PREDUC)*V(TUNER1)) GO TO 190                   
C                                                                       
C  ***  DECREASE WAS MUCH LESS THAN PREDICTED -- EITHER CHANGE MODELS   
C  ***  OR ACCEPT STEP WITH DECREASED RADIUS.                           
C                                                                       
      IF (IV(STAGE) .GE. IV(STGLIM)) GO TO 150                          
C        ***  CONSIDER SWITCHING MODELS  ***                            
         IV(IRC) = 2                                                    
         GO TO 160                                                      
C                                                                       
C     ***  ACCEPT STEP WITH DECREASED RADIUS  ***                       
C                                                                       
 150  IV(IRC) = 4                                                       
C                                                                       
C  ***  SET V(RADFAC) TO FLETCHER*S DECREASE FACTOR  ***                
C                                                                       
 160  IV(XIRC) = IV(IRC)                                                
      EMAX = V(GTSTEP) + V(FDIF)                                        
      V(RADFAC) = HALF * RFAC1                                          
      IF (EMAX .LT. V(GTSTEP)) V(RADFAC) = RFAC1 * AMAX1(V(RDFCMN),     
     1                                           HALF * V(GTSTEP)/EMAX) 
C                                                                       
C  ***  DO FALSE CONVERGENCE TEST  ***                                  
C                                                                       
 170  IF (V(RELDX) .LE. V(XFTOL)) GO TO 180                             
         IV(IRC) = IV(XIRC)                                             
         IF (V(F) .LT. V(F0)) GO TO 200                                 
              GO TO 230                                                 
C                                                                       
 180  IV(IRC) = 12                                                      
      GO TO 240                                                         
C                                                                       
C  ***  HANDLE GOOD FUNCTION DECREASE  ***                              
C                                                                       
 190  IF (V(FDIF) .LT. (-V(TUNER3) * V(GTSTEP))) GO TO 210              
C                                                                       
C     ***  INCREASING RADIUS LOOKS WORTHWHILE.  SEE IF WE JUST          
C     ***  RECOMPUTED STEP WITH A DECREASED RADIUS OR RESTORED STEP     
C     ***  AFTER RECOMPUTING IT WITH A LARGER RADIUS.                   
C                                                                       
      IF (IV(RADINC) .LT. 0) GO TO 210                                  
      IF (IV(RESTOR) .EQ. 1) GO TO 210                                  
C                                                                       
C        ***  WE DID NOT.  TRY A LONGER STEP UNLESS THIS WAS A NEWTON   
C        ***  STEP.                                                     
C                                                                       
         V(RADFAC) = V(RDFCMX)                                          
         GTS = V(GTSTEP)                                                
         IF (V(FDIF) .LT. (HALF/V(RADFAC) - ONE) * GTS)                 
     1            V(RADFAC) = AMAX1(V(INCFAC), HALF*GTS/(GTS + V(FDIF)))
         IV(IRC) = 4                                                    
         IF (V(STPPAR) .EQ. ZERO) GO TO 230                             
         IF (V(DST0) .GE. ZERO .AND. (V(DST0) .LT. TWO*V(DSTNRM)        
     1             .OR. V(NREDUC) .LT. ONEP2*V(FDIF)))  GO TO 230       
C             ***  STEP WAS NOT A NEWTON STEP.  RECOMPUTE IT WITH       
C             ***  A LARGER RADIUS.                                     
              IV(IRC) = 5                                               
              IV(RADINC) = IV(RADINC) + 1                               
C                                                                       
C  ***  SAVE VALUES CORRESPONDING TO GOOD STEP  ***                     
C                                                                       
 200  V(FLSTGD) = V(F)                                                  
      IV(MLSTGD) = IV(MODEL)                                            
      IF (IV(RESTOR) .NE. 1) IV(RESTOR) = 2                             
      V(DSTSAV) = V(DSTNRM)                                             
      IV(NFGCAL) = NFC                                                  
      V(PLSTGD) = V(PREDUC)                                             
      V(GTSLST) = V(GTSTEP)                                             
      GO TO 230                                                         
C                                                                       
C  ***  ACCEPT STEP WITH RADIUS UNCHANGED  ***                          
C                                                                       
 210  V(RADFAC) = ONE                                                   
      IV(IRC) = 3                                                       
      GO TO 230                                                         
C                                                                       
C  ***  COME HERE FOR A RESTART AFTER CONVERGENCE  ***                  
C                                                                       
 220  IV(IRC) = IV(XIRC)                                                
      IF (V(DSTSAV) .GE. ZERO) GO TO 240                                
         IV(IRC) = 12                                                   
         GO TO 240                                                      
C                                                                       
C  ***  PERFORM CONVERGENCE TESTS  ***                                  
C                                                                       
 230  IV(XIRC) = IV(IRC)                                                
 240  IF (IV(RESTOR) .EQ. 1 .AND. V(FLSTGD) .LT. V(F0)) IV(RESTOR) = 3  
      IF ( ABS(V(F)) .LT. V(AFCTOL)) IV(IRC) = 10                       
      IF (HALF * V(FDIF) .GT. V(PREDUC)) GO TO 999                      
      EMAX = V(RFCTOL) *  ABS(V(F0))                                    
      EMAXS = V(SCTOL) *  ABS(V(F0))                                    
      IF (V(PREDUC) .LE. EMAXS .AND. (V(DSTNRM) .GT. V(LMAXS) .OR.      
     1     V(STPPAR) .EQ. ZERO)) IV(IRC) = 11                           
      IF (V(DST0) .LT. ZERO) GO TO 250                                  
      I = 0                                                             
      IF ((V(NREDUC) .GT. ZERO .AND. V(NREDUC) .LE. EMAX) .OR.          
     1    (V(NREDUC) .EQ. ZERO. AND. V(PREDUC) .EQ. ZERO))  I = 2       
      IF (V(STPPAR) .EQ. ZERO .AND. V(RELDX) .LE. V(XCTOL)              
     1                        .AND. GOODX)                  I = I + 1   
      IF (I .GT. 0) IV(IRC) = I + 6                                     
C                                                                       
C  ***  CONSIDER RECOMPUTING STEP OF LENGTH V(LMAXS) FOR SINGULAR       
C  ***  CONVERGENCE TEST.                                               
C                                                                       
 250  IF (IV(IRC) .GT. 5 .AND. IV(IRC) .NE. 12) GO TO 999               
      IF (V(STPPAR) .EQ. ZERO) GO TO 999                                
      IF (V(DSTNRM) .GT. V(LMAXS)) GO TO 260                            
         IF (V(PREDUC) .GE. EMAXS) GO TO 999                            
              IF (V(DST0) .LE. ZERO) GO TO 270                          
                   IF (HALF * V(DST0) .LE. V(LMAXS)) GO TO 999          
                        GO TO 270                                       
 260  IF (HALF * V(DSTNRM) .LE. V(LMAXS)) GO TO 999                     
      XMAX = V(LMAXS) / V(DSTNRM)                                       
      IF (XMAX * (TWO - XMAX) * V(PREDUC) .GE. EMAXS) GO TO 999         
 270  IF (V(NREDUC) .LT. ZERO) GO TO 290                                
C                                                                       
C  ***  RECOMPUTE V(PREDUC) FOR USE IN SINGULAR CONVERGENCE TEST  ***   
C                                                                       
      V(GTSLST) = V(GTSTEP)                                             
      V(DSTSAV) = V(DSTNRM)                                             
      IF (IV(IRC) .EQ. 12) V(DSTSAV) = -V(DSTSAV)                       
      V(PLSTGD) = V(PREDUC)                                             
      I = IV(RESTOR)                                                    
      IV(RESTOR) = 2                                                    
      IF (I .EQ. 3) IV(RESTOR) = 0                                      
      IV(IRC) = 6                                                       
      GO TO 999                                                         
C                                                                       
C  ***  PERFORM SINGULAR CONVERGENCE TEST WITH RECOMPUTED V(PREDUC)  ***
C                                                                       
 280  V(GTSTEP) = V(GTSLST)                                             
      V(DSTNRM) =  ABS(V(DSTSAV))                                       
      IV(IRC) = IV(XIRC)                                                
      IF (V(DSTSAV) .LE. ZERO) IV(IRC) = 12                             
      V(NREDUC) = -V(PREDUC)                                            
      V(PREDUC) = V(PLSTGD)                                             
      IV(RESTOR) = 3                                                    
 290  IF (-V(NREDUC) .LE. V(RFCTOL) *  ABS(V(F0))) IV(IRC) = 11         
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF A7SST FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  G7QSB(B, D, DIHDI, G, IPIV, IPIV1, IPIV2, KA, L, LV,  
     1                  P, P0, PC, STEP, TD, TG, V, W, X, X0)           
C                                                                       
C  ***  COMPUTE HEURISTIC BOUNDED NEWTON STEP  ***                      
C                                                                       
      INTEGER KA, LV, P, P0, PC                                         
      INTEGER IPIV(P), IPIV1(P), IPIV2(P)                               
      REAL B(2,P), D(P), DIHDI(1), G(P), L(1),                          
     1                 STEP(P,2), TD(P), TG(P), V(LV), W(P), X0(P), X(P)
C     DIMENSION DIHDI(P*(P+1)/2), L(P*(P+1)/2)                          
C                                                                       
      REAL  D7TPR                                                       
      EXTERNAL  D7TPR, G7QTS,  S7BQN,  S7IPR, V7CPY,  V7IPR,            
     1          V7SCP,  V7VMP                                           
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER K, KB, KINIT, NS, P1, P10                                 
      REAL DS0, NRED, PRED, RAD                                         
      REAL ZERO                                                         
C                                                                       
C  ***  V SUBSCRIPTS  ***                                               
C                                                                       
      INTEGER DST0, DSTNRM, GTSTEP, NREDUC, PREDUC, RADIUS              
C                                                                       
C/6                                                                     
C     DATA DST0/3/, DSTNRM/2/, GTSTEP/4/, NREDUC/6/, PREDUC/7/,         
C    1     RADIUS/8/                                                    
C/7                                                                     
      PARAMETER (DST0=3, DSTNRM=2, GTSTEP=4, NREDUC=6, PREDUC=7,        
     1           RADIUS=8)                                              
C/                                                                      
      DATA ZERO/0.E+0/                                                  
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      P1 = PC                                                           
      IF (KA .LT. 0) GO TO 10                                           
         NRED = V(NREDUC)                                               
         DS0 = V(DST0)                                                  
         GO TO 20                                                       
 10   P0 = 0                                                            
      KA = -1                                                           
C                                                                       
 20   KINIT = -1                                                        
      IF (P0 .EQ. P1) KINIT = KA                                        
      CALL V7CPY(P, X, X0)                                              
      PRED = ZERO                                                       
      RAD = V(RADIUS)                                                   
      KB = -1                                                           
      V(DSTNRM) = ZERO                                                  
      IF (P1 .GT. 0) GO TO 30                                           
         NRED = ZERO                                                    
         DS0 = ZERO                                                     
         CALL  V7SCP(P, STEP, ZERO)                                     
         GO TO 60                                                       
C                                                                       
 30   CALL V7CPY(P, TD, D)                                              
      CALL  V7IPR(P, IPIV, TD)                                          
      CALL  V7VMP(P, TG, G, D, -1)                                      
      CALL  V7IPR(P, IPIV, TG)                                          
 40   K = KINIT                                                         
      KINIT = -1                                                        
      V(RADIUS) = RAD - V(DSTNRM)                                       
      CALL G7QTS(TD, TG, DIHDI, K, L, P1, STEP, V, W)                   
      P0 = P1                                                           
      IF (KA .GE. 0) GO TO 50                                           
         NRED = V(NREDUC)                                               
         DS0 = V(DST0)                                                  
C                                                                       
 50   KA = K                                                            
      V(RADIUS) = RAD                                                   
      P10 = P1                                                          
      CALL  S7BQN(B, D, STEP(1,2), IPIV, IPIV1, IPIV2, KB, L, LV,       
     1            NS, P, P1, STEP, TD, TG, V, W, X, X0)                 
      IF (NS .GT. 0) CALL  S7IPR(P10, IPIV1, DIHDI)                     
      PRED = PRED + V(PREDUC)                                           
      IF (NS .NE. 0) P0 = 0                                             
      IF (KB .LE. 0) GO TO 40                                           
C                                                                       
 60   V(DST0) = DS0                                                     
      V(NREDUC) = NRED                                                  
      V(PREDUC) = PRED                                                  
      V(GTSTEP) =  D7TPR(P, G, STEP)                                    
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  G7QSB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  L7MSB(B, D, G, IERR, IPIV, IPIV1, IPIV2, KA, LMAT,    
     1                  LV, P, P0, PC, QTR, RMAT, STEP, TD, TG, V,      
     2                  W, WLM, X, X0)                                  
C                                                                       
C  ***  COMPUTE HEURISTIC BOUNDED NEWTON STEP  ***                      
C                                                                       
      INTEGER IERR, KA, LV, P, P0, PC                                   
      INTEGER IPIV(P), IPIV1(P), IPIV2(P)                               
      REAL B(2,P), D(P), G(P), LMAT(1), QTR(P), RMAT(1),                
     1                 STEP(P,3), TD(P), TG(P), V(LV), W(P), WLM(1),    
     2                 X0(P), X(P)                                      
C     DIMENSION LMAT(P*(P+1)/2), RMAT(P*(P+1)/2), WLM(P*(P+5)/2 + 4)    
C                                                                       
      REAL  D7TPR                                                       
      EXTERNAL  D7MLP,  D7TPR,  L7MST,  L7TVM,  Q7RSH,  S7BQN,          
     1         V2AXY, V7CPY,  V7IPR,  V7SCP,  V7VMP                     
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER I, J, K, K0, KB, KINIT, L, NS, P1, P10, P11               
      REAL DS0, NRED, PRED, RAD                                         
      REAL ONE, ZERO                                                    
C                                                                       
C  ***  V SUBSCRIPTS  ***                                               
C                                                                       
      INTEGER DST0, DSTNRM, GTSTEP, NREDUC, PREDUC, RADIUS              
C                                                                       
C/6                                                                     
C     DATA DST0/3/, DSTNRM/2/, GTSTEP/4/, NREDUC/6/, PREDUC/7/,         
C    1     RADIUS/8/                                                    
C/7                                                                     
      PARAMETER (DST0=3, DSTNRM=2, GTSTEP=4, NREDUC=6, PREDUC=7,        
     1           RADIUS=8)                                              
C/                                                                      
      DATA ONE/1.E+0/, ZERO/0.E+0/                                      
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      P1 = PC                                                           
      IF (KA .LT. 0) GO TO 10                                           
         NRED = V(NREDUC)                                               
         DS0 = V(DST0)                                                  
         GO TO 20                                                       
 10   P0 = 0                                                            
      KA = -1                                                           
C                                                                       
 20   KINIT = -1                                                        
      IF (P0 .EQ. P1) KINIT = KA                                        
      CALL V7CPY(P, X, X0)                                              
      CALL V7CPY(P, TD, D)                                              
C     *** USE STEP(1,3) AS TEMP. COPY OF QTR ***                        
      CALL V7CPY(P, STEP(1,3), QTR)                                     
      CALL  V7IPR(P, IPIV, TD)                                          
      PRED = ZERO                                                       
      RAD = V(RADIUS)                                                   
      KB = -1                                                           
      V(DSTNRM) = ZERO                                                  
      IF (P1 .GT. 0) GO TO 30                                           
         NRED = ZERO                                                    
         DS0 = ZERO                                                     
         CALL  V7SCP(P, STEP, ZERO)                                     
         GO TO 90                                                       
C                                                                       
 30   CALL  V7VMP(P, TG, G, D, -1)                                      
      CALL  V7IPR(P, IPIV, TG)                                          
      P10 = P1                                                          
 40   K = KINIT                                                         
      KINIT = -1                                                        
      V(RADIUS) = RAD - V(DSTNRM)                                       
      CALL  V7VMP(P1, TG, TG, TD, 1)                                    
      DO 50 I = 1, P1                                                   
 50      IPIV1(I) = I                                                   
      K0 = MAX0(0, K)                                                   
      CALL  L7MST(TD, TG, IERR, IPIV1, K, P1, STEP(1,3), RMAT, STEP,    
     1            V, WLM)                                               
      CALL  V7VMP(P1, TG, TG, TD, -1)                                   
      P0 = P1                                                           
      IF (KA .GE. 0) GO TO 60                                           
         NRED = V(NREDUC)                                               
         DS0 = V(DST0)                                                  
C                                                                       
 60   KA = K                                                            
      V(RADIUS) = RAD                                                   
      L = P1 + 5                                                        
      IF (K .LE. K0) CALL  D7MLP(P1, LMAT, TD, RMAT, -1)                
      IF (K .GT. K0) CALL  D7MLP(P1, LMAT, TD, WLM(L), -1)              
      CALL  S7BQN(B, D, STEP(1,2), IPIV, IPIV1, IPIV2, KB, LMAT,        
     1            LV, NS, P, P1, STEP, TD, TG, V, W, X, X0)             
      PRED = PRED + V(PREDUC)                                           
      IF (NS .EQ. 0) GO TO 80                                           
      P0 = 0                                                            
C                                                                       
C  ***  UPDATE RMAT AND QTR  ***                                        
C                                                                       
      P11 = P1 + 1                                                      
      L = P10 + P11                                                     
      DO 70 K = P11, P10                                                
         J = L - K                                                      
         I = IPIV2(J)                                                   
         IF (I .LT. J) CALL  Q7RSH(I, J, .TRUE., QTR, RMAT, W)          
 70      CONTINUE                                                       
C                                                                       
 80   IF (KB .GT. 0) GO TO 90                                           
C                                                                       
C  ***  UPDATE LOCAL COPY OF QTR  ***                                   
C                                                                       
      CALL  V7VMP(P10, W, STEP(1,2), TD, -1)                            
      CALL  L7TVM(P10, W, LMAT, W)                                      
      CALL V2AXY(P10, STEP(1,3), ONE, W, QTR)                           
      GO TO 40                                                          
C                                                                       
 90   V(DST0) = DS0                                                     
      V(NREDUC) = NRED                                                  
      V(PREDUC) = PRED                                                  
      V(GTSTEP) =  D7TPR(P, G, STEP)                                    
C                                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  L7MSB FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  S7BQN(B, D, DST, IPIV, IPIV1, IPIV2, KB, L, LV, NS,   
     1                  P, P1, STEP, TD, TG, V, W, X, X0)               
C                                                                       
C  ***  COMPUTE BOUNDED MODIFIED NEWTON STEP  ***                       
C                                                                       
      INTEGER KB, LV, NS, P, P1                                         
      INTEGER IPIV(P), IPIV1(P), IPIV2(P)                               
      REAL B(2,P), D(P), DST(P), L(1),                                  
     1                 STEP(P), TD(P), TG(P), V(LV), W(P), X(P),        
     2                 X0(P)                                            
C     DIMENSION L(P*(P+1)/2)                                            
C                                                                       
      REAL  D7TPR,  R7MDC,  V2NRM                                       
      EXTERNAL  D7TPR, I7SHFT,  L7ITV,  L7IVM,  Q7RSH,  R7MDC,  V2NRM,  
     1         V2AXY, V7CPY,  V7IPR,  V7SCP,  V7SHF                     
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER I, J, K, P0, P1M1                                         
      REAL ALPHA, DST0, DST1, DSTMAX, DSTMIN, DX, GTS, T,               
     1                 TI, T1, XI                                       
      REAL FUDGE, HALF, MEPS2, ONE, TWO, ZERO                           
C                                                                       
C  ***  V SUBSCRIPTS  ***                                               
C                                                                       
      INTEGER DSTNRM, GTSTEP, PHMNFC, PHMXFC, PREDUC, RADIUS, STPPAR    
C                                                                       
C/6                                                                     
C     DATA DSTNRM/2/, GTSTEP/4/, PHMNFC/20/, PHMXFC/21/, PREDUC/7/,     
C    1     RADIUS/8/, STPPAR/5/                                         
C/7                                                                     
      PARAMETER (DSTNRM=2, GTSTEP=4, PHMNFC=20, PHMXFC=21, PREDUC=7,    
     1           RADIUS=8, STPPAR=5)                                    
      SAVE MEPS2                                                        
C/                                                                      
C                                                                       
      DATA FUDGE/1.0001E+0/, HALF/0.5E+0/, MEPS2/0.E+0/,                
     1     ONE/1.0E+0/, TWO/2.E+0/, ZERO/0.E+0/                         
C                                                                       
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C                                                                       
      DSTMAX = FUDGE * (ONE + V(PHMXFC)) * V(RADIUS)                    
      DSTMIN = (ONE + V(PHMNFC)) * V(RADIUS)                            
      DST1 = ZERO                                                       
      IF (MEPS2 .LE. ZERO) MEPS2 = TWO *  R7MDC(3)                      
      P0 = P1                                                           
      NS = 0                                                            
      DO 10 I = 1, P                                                    
         IPIV1(I) = I                                                   
         IPIV2(I) = I                                                   
 10      CONTINUE                                                       
      DO 20 I = 1, P1                                                   
 20      W(I) = -STEP(I) * TD(I)                                        
      ALPHA =  ABS(V(STPPAR))                                           
      V(PREDUC) = ZERO                                                  
      GTS = -V(GTSTEP)                                                  
      IF (KB .LT. 0) CALL  V7SCP(P, DST, ZERO)                          
      KB = 1                                                            
C                                                                       
C     ***  -W = D TIMES RESTRICTED NEWTON STEP FROM X + DST/D.          
C                                                                       
C     ***  FIND T SUCH THAT X - T*W IS STILL FEASIBLE.                  
C                                                                       
 30   T = ONE                                                           
      K = 0                                                             
      DO 60 I = 1, P1                                                   
         J = IPIV(I)                                                    
         DX = W(I) / D(J)                                               
         XI = X(J) - DX                                                 
         IF (XI .LT. B(1,J)) GO TO 40                                   
         IF (XI .LE. B(2,J)) GO TO 60                                   
              TI = ( X(J)  -  B(2,J) ) / DX                             
              K = I                                                     
              GO TO 50                                                  
 40      TI = ( X(J)  -  B(1,J) ) / DX                                  
              K = -I                                                    
 50      IF (T .LE. TI) GO TO 60                                        
              T = TI                                                    
 60      CONTINUE                                                       
C                                                                       
      IF (P .GT. P1) CALL V7CPY(P-P1, STEP(P1+1), DST(P1+1))            
      CALL V2AXY(P1, STEP, -T, W, DST)                                  
      DST0 = DST1                                                       
      DST1 =  V2NRM(P, STEP)                                            
C                                                                       
C  ***  CHECK FOR OVERSIZE STEP  ***                                    
C                                                                       
      IF (DST1 .LE. DSTMAX) GO TO 80                                    
      IF (P1 .GE. P0) GO TO 70                                          
         IF (DST0 .LT. DSTMIN) KB = 0                                   
         GO TO 110                                                      
C                                                                       
 70   K = 0                                                             
C                                                                       
C  ***  UPDATE DST, TG, AND V(PREDUC)  ***                              
C                                                                       
 80   V(DSTNRM) = DST1                                                  
      CALL V7CPY(P1, DST, STEP)                                         
      T1 = ONE - T                                                      
      DO 90 I = 1, P1                                                   
 90      TG(I) = T1 * TG(I)                                             
      IF (ALPHA .GT. ZERO) CALL V2AXY(P1, TG, T*ALPHA, W, TG)           
      V(PREDUC) = V(PREDUC) + T*((ONE - HALF*T)*GTS +                   
     1                        HALF*ALPHA*T* D7TPR(P1,W,W))              
      IF (K .EQ. 0) GO TO 110                                           
C                                                                       
C     ***  PERMUTE L, ETC. IF NECESSARY  ***                            
C                                                                       
      P1M1 = P1 - 1                                                     
      J = IABS(K)                                                       
      IF (J .EQ. P1) GO TO 100                                          
         NS = NS + 1                                                    
         IPIV2(P1) = J                                                  
         CALL  Q7RSH(J, P1, .FALSE., TG, L, W)                          
         CALL I7SHFT(P1, J, IPIV)                                       
         CALL I7SHFT(P1, J, IPIV1)                                      
         CALL  V7SHF(P1, J, TG)                                         
         CALL  V7SHF(P1, J, DST)                                        
 100  IF (K .LT. 0) IPIV(P1) = -IPIV(P1)                                
      P1 = P1M1                                                         
      IF (P1 .LE. 0) GO TO 110                                          
      CALL  L7IVM(P1, W, L, TG)                                         
      GTS =  D7TPR(P1, W, W)                                            
      CALL  L7ITV(P1, W, L, W)                                          
      GO TO 30                                                          
C                                                                       
C     ***  UNSCALE STEP  ***                                            
C                                                                       
 110  DO 120 I = 1, P                                                   
         J = IABS(IPIV(I))                                              
         STEP(J) = DST(I) / D(J)                                        
 120     CONTINUE                                                       
C                                                                       
C  ***  FUDGE STEP TO ENSURE THAT IT FORCES APPROPRIATE COMPONENTS      
C  ***  TO THEIR BOUNDS  ***                                            
C                                                                       
      IF (P1 .GE. P0) GO TO 150                                         
      K = P1 + 1                                                        
      DO 140 I = K, P0                                                  
         J = IPIV(I)                                                    
         T = MEPS2                                                      
         IF (J .GT. 0) GO TO 130                                        
            T = -T                                                      
            J = -J                                                      
            IPIV(I) = J                                                 
 130     T = T * AMAX1( ABS(X(J)),  ABS(X0(J)))                         
         STEP(J) = STEP(J) + T                                          
 140     CONTINUE                                                       
C                                                                       
 150  CALL V2AXY(P, X, ONE, STEP, X0)                                   
      IF (NS .GT. 0) CALL  V7IPR(P0, IPIV1, TD)                         
 999  RETURN                                                            
C  ***  LAST LINE OF  S7BQN FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  S7IPR(P, IP, H)                                       
C                                                                       
C  APPLY THE PERMUTATION DEFINED BY IP TO THE ROWS AND COLUMNS OF THE   
C  P X P SYMMETRIC MATRIX WHOSE LOWER TRIANGLE IS STORED COMPACTLY IN H.
C  THUS H.OUTPUT(I,J) = H.INPUT(IP(I), IP(J)).                          
C                                                                       
      INTEGER P                                                         
      INTEGER IP(P)                                                     
      REAL H(1)                                                         
C                                                                       
      INTEGER I, J, J1, JM, K, K1, KK, KM, KMJ, L, M                    
      REAL T                                                            
C                                                                       
C ***  BODY  ***                                                        
C                                                                       
      DO 90 I = 1, P                                                    
         J = IP(I)                                                      
         IF (J .EQ. I) GO TO 90                                         
         IP(I) = IABS(J)                                                
         IF (J .LT. 0) GO TO 90                                         
         K = I                                                          
 10         J1 = J                                                      
            K1 = K                                                      
            IF (J .LE. K) GO TO 20                                      
               J1 = K                                                   
               K1 = J                                                   
 20         KMJ = K1-J1                                                 
            L = J1-1                                                    
            JM = J1*L/2                                                 
            KM = K1*(K1-1)/2                                            
            IF (L .LE. 0) GO TO 40                                      
               DO 30 M = 1, L                                           
                  JM = JM+1                                             
                  T = H(JM)                                             
                  KM = KM+1                                             
                  H(JM) = H(KM)                                         
                  H(KM) = T                                             
 30               CONTINUE                                              
 40         KM = KM+1                                                   
            KK = KM+KMJ                                                 
            JM = JM+1                                                   
            T = H(JM)                                                   
            H(JM) = H(KK)                                               
            H(KK) = T                                                   
            J1 = L                                                      
            L = KMJ-1                                                   
            IF (L .LE. 0) GO TO 60                                      
               DO 50 M = 1, L                                           
                  JM = JM+J1+M                                          
                  T = H(JM)                                             
                  KM = KM+1                                             
                  H(JM) = H(KM)                                         
                  H(KM) = T                                             
 50               CONTINUE                                              
 60         IF (K1 .GE. P) GO TO 80                                     
               L = P-K1                                                 
               K1 = K1-1                                                
               KM = KK                                                  
               DO 70 M = 1, L                                           
                  KM = KM+K1+M                                          
                  JM = KM-KMJ                                           
                  T = H(JM)                                             
                  H(JM) = H(KM)                                         
                  H(KM) = T                                             
 70               CONTINUE                                              
 80         K = J                                                       
            J = IP(K)                                                   
            IP(K) = -J                                                  
            IF (J .GT. I) GO TO 10                                      
 90      CONTINUE                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  S7IPR FOLLOWS  ***                                
      END                                                               
      SUBROUTINE ITSUM(D, G, IV, LIV, LV, P, V, X)                      
C                                                                       
C  ***  PRINT ITERATION SUMMARY FOR ***SOL (VERSION 2.3)  ***           
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER LIV, LV, P                                                
      INTEGER IV(LIV)                                                   
      REAL D(P), G(P), V(LV), X(P)                                      
C                                                                       
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      INTEGER ALG, I, IV1, M, NF, NG, OL, PU                            
C/6S                                                                    
C     REAL MODEL1(6), MODEL2(6)                                         
C/7S                                                                    
      CHARACTER*4 MODEL1(6), MODEL2(6)                                  
C/                                                                      
      REAL NRELDF, OLDF, PRELDF, RELDF, ZERO                            
C                                                                       
C  ***  NO EXTERNAL FUNCTIONS OR SUBROUTINES  ***                       
C                                                                       
C  ***  SUBSCRIPTS FOR IV AND V  ***                                    
C                                                                       
      INTEGER ALGSAV, DSTNRM, F, FDIF, F0, NEEDHD, NFCALL, NFCOV, NGCOV,
     1        NGCALL, NITER, NREDUC, OUTLEV, PREDUC, PRNTIT, PRUNIT,    
     2        RELDX, SOLPRT, STATPR, STPPAR, SUSED, X0PRT               
C                                                                       
C  ***  IV SUBSCRIPT VALUES  ***                                        
C                                                                       
C/6                                                                     
C     DATA ALGSAV/51/, NEEDHD/36/, NFCALL/6/, NFCOV/52/, NGCALL/30/,    
C    1     NGCOV/53/, NITER/31/, OUTLEV/19/, PRNTIT/39/, PRUNIT/21/,    
C    2     SOLPRT/22/, STATPR/23/, SUSED/64/, X0PRT/24/                 
C/7                                                                     
      PARAMETER (ALGSAV=51, NEEDHD=36, NFCALL=6, NFCOV=52, NGCALL=30,   
     1           NGCOV=53, NITER=31, OUTLEV=19, PRNTIT=39, PRUNIT=21,   
     2           SOLPRT=22, STATPR=23, SUSED=64, X0PRT=24)              
C/                                                                      
C                                                                       
C  ***  V SUBSCRIPT VALUES  ***                                         
C                                                                       
C/6                                                                     
C     DATA DSTNRM/2/, F/10/, F0/13/, FDIF/11/, NREDUC/6/, PREDUC/7/,    
C    1     RELDX/17/, STPPAR/5/                                         
C/7                                                                     
      PARAMETER (DSTNRM=2, F=10, F0=13, FDIF=11, NREDUC=6, PREDUC=7,    
     1           RELDX=17, STPPAR=5)                                    
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA ZERO/0.E+0/                                                  
C/7                                                                     
      PARAMETER (ZERO=0.E+0)                                            
C/                                                                      
C/6S                                                                    
C     DATA MODEL1(1)/4H    /, MODEL1(2)/4H    /, MODEL1(3)/4H    /,     
C    1     MODEL1(4)/4H    /, MODEL1(5)/4H  G /, MODEL1(6)/4H  S /,     
C    2     MODEL2(1)/4H G  /, MODEL2(2)/4H S  /, MODEL2(3)/4HG-S /,     
C    3     MODEL2(4)/4HS-G /, MODEL2(5)/4H-S-G/, MODEL2(6)/4H-G-S/      
C/7S                                                                    
      DATA MODEL1/'    ','    ','    ','    ','  G ','  S '/,           
     1     MODEL2/' G  ',' S  ','G-S ','S-G ','-S-G','-G-S'/            
C/                                                                      
C                                                                       
C-------------------------------  BODY  --------------------------------
C                                                                       
      PU = IV(PRUNIT)                                                   
      IF (PU .EQ. 0) GO TO 999                                          
      IV1 = IV(1)                                                       
      IF (IV1 .GT. 62) IV1 = IV1 - 51                                   
      OL = IV(OUTLEV)                                                   
      ALG = MOD(IV(ALGSAV)-1,2) + 1                                     
      IF (IV1 .LT. 2 .OR. IV1 .GT. 15) GO TO 370                        
      IF (IV1 .GE. 12) GO TO 120                                        
      IF (IV1 .EQ. 2 .AND. IV(NITER) .EQ. 0) GO TO 390                  
      IF (OL .EQ. 0) GO TO 120                                          
      IF (IV1 .GE. 10 .AND. IV(PRNTIT) .EQ. 0) GO TO 120                
      IF (IV1 .GT. 2) GO TO 10                                          
         IV(PRNTIT) = IV(PRNTIT) + 1                                    
         IF (IV(PRNTIT) .LT. IABS(OL)) GO TO 999                        
 10   NF = IV(NFCALL) - IABS(IV(NFCOV))                                 
      IV(PRNTIT) = 0                                                    
      RELDF = ZERO                                                      
      PRELDF = ZERO                                                     
      OLDF = AMAX1( ABS(V(F0)),  ABS(V(F)))                             
      IF (OLDF .LE. ZERO) GO TO 20                                      
         RELDF = V(FDIF) / OLDF                                         
         PRELDF = V(PREDUC) / OLDF                                      
 20   IF (OL .GT. 0) GO TO 60                                           
C                                                                       
C        ***  PRINT SHORT SUMMARY LINE  ***                             
C                                                                       
         IF (IV(NEEDHD) .EQ. 1 .AND. ALG .EQ. 1) WRITE(PU,30)           
 30   FORMAT(/10H   IT   NF,6X,1HF,7X,5HRELDF,3X,6HPRELDF,3X,5HRELDX,   
     1       2X,13HMODEL  STPPAR)                                       
         IF (IV(NEEDHD) .EQ. 1 .AND. ALG .EQ. 2) WRITE(PU,40)           
 40   FORMAT(/11H    IT   NF,7X,1HF,8X,5HRELDF,4X,6HPRELDF,4X,5HRELDX,  
     1       3X,6HSTPPAR)                                               
         IV(NEEDHD) = 0                                                 
         IF (ALG .EQ. 2) GO TO 50                                       
         M = IV(SUSED)                                                  
         WRITE(PU,100) IV(NITER), NF, V(F), RELDF, PRELDF, V(RELDX),    
     1                 MODEL1(M), MODEL2(M), V(STPPAR)                  
         GO TO 120                                                      
C                                                                       
 50      WRITE(PU,110) IV(NITER), NF, V(F), RELDF, PRELDF, V(RELDX),    
     1                 V(STPPAR)                                        
         GO TO 120                                                      
C                                                                       
C     ***  PRINT LONG SUMMARY LINE  ***                                 
C                                                                       
 60   IF (IV(NEEDHD) .EQ. 1 .AND. ALG .EQ. 1) WRITE(PU,70)              
 70   FORMAT(/11H    IT   NF,6X,1HF,7X,5HRELDF,3X,6HPRELDF,3X,5HRELDX,  
     1       2X,13HMODEL  STPPAR,2X,6HD*STEP,2X,7HNPRELDF)              
      IF (IV(NEEDHD) .EQ. 1 .AND. ALG .EQ. 2) WRITE(PU,80)              
 80   FORMAT(/11H    IT   NF,7X,1HF,8X,5HRELDF,4X,6HPRELDF,4X,5HRELDX,  
     1       3X,6HSTPPAR,3X,6HD*STEP,3X,7HNPRELDF)                      
      IV(NEEDHD) = 0                                                    
      NRELDF = ZERO                                                     
      IF (OLDF .GT. ZERO) NRELDF = V(NREDUC) / OLDF                     
      IF (ALG .EQ. 2) GO TO 90                                          
      M = IV(SUSED)                                                     
      WRITE(PU,100) IV(NITER), NF, V(F), RELDF, PRELDF, V(RELDX),       
     1             MODEL1(M), MODEL2(M), V(STPPAR), V(DSTNRM), NRELDF   
      GO TO 120                                                         
C                                                                       
 90   WRITE(PU,110) IV(NITER), NF, V(F), RELDF, PRELDF,                 
     1             V(RELDX), V(STPPAR), V(DSTNRM), NRELDF               
 100  FORMAT(I6,I5,E10.3,2E9.2,E8.1,A3,A4,2E8.1,E9.2)                   
 110  FORMAT(I6,I5,E11.3,2E10.2,3E9.1,E10.2)                            
C                                                                       
 120  IF (IV1 .LE. 2) GO TO 999                                         
      I = IV(STATPR)                                                    
      IF (I .EQ. (-1)) GO TO 460                                        
      IF (I + IV1 .LT. 0) GO TO 460                                     
      GO TO (999, 999, 130, 150, 170, 190, 210, 230, 250, 270, 290, 310,
     1       330, 350, 500),  IV1                                       
C                                                                       
 130  WRITE(PU,140)                                                     
 140  FORMAT(/26H ***** X-CONVERGENCE *****)                            
      GO TO 430                                                         
C                                                                       
 150  WRITE(PU,160)                                                     
 160  FORMAT(/42H ***** RELATIVE FUNCTION CONVERGENCE *****)            
      GO TO 430                                                         
C                                                                       
 170  WRITE(PU,180)                                                     
 180  FORMAT(/49H ***** X- AND RELATIVE FUNCTION CONVERGENCE *****)     
      GO TO 430                                                         
C                                                                       
 190  WRITE(PU,200)                                                     
 200  FORMAT(/42H ***** ABSOLUTE FUNCTION CONVERGENCE *****)            
      GO TO 430                                                         
C                                                                       
 210  WRITE(PU,220)                                                     
 220  FORMAT(/33H ***** SINGULAR CONVERGENCE *****)                     
      GO TO 430                                                         
C                                                                       
 230  WRITE(PU,240)                                                     
 240  FORMAT(/30H ***** FALSE CONVERGENCE *****)                        
      GO TO 430                                                         
C                                                                       
 250  WRITE(PU,260)                                                     
 260  FORMAT(/38H ***** FUNCTION EVALUATION LIMIT *****)                
      GO TO 430                                                         
C                                                                       
 270  WRITE(PU,280)                                                     
 280  FORMAT(/28H ***** ITERATION LIMIT *****)                          
      GO TO 430                                                         
C                                                                       
 290  WRITE(PU,300)                                                     
 300  FORMAT(/18H ***** STOPX *****)                                    
      GO TO 430                                                         
C                                                                       
 310  WRITE(PU,320)                                                     
 320  FORMAT(/44H ***** INITIAL F(X) CANNOT BE COMPUTED *****)          
C                                                                       
      GO TO 390                                                         
C                                                                       
 330  WRITE(PU,340)                                                     
 340  FORMAT(/37H ***** BAD PARAMETERS TO ASSESS *****)                 
      GO TO 999                                                         
C                                                                       
 350  WRITE(PU,360)                                                     
 360  FORMAT(/43H ***** GRADIENT COULD NOT BE COMPUTED *****)           
      IF (IV(NITER) .GT. 0) GO TO 460                                   
      GO TO 390                                                         
C                                                                       
 370  WRITE(PU,380) IV(1)                                               
 380  FORMAT(/14H ***** IV(1) =,I5,6H *****)                            
      GO TO 999                                                         
C                                                                       
C  ***  INITIAL CALL ON ITSUM  ***                                      
C                                                                       
 390  IF (IV(X0PRT) .NE. 0) WRITE(PU,400) (I, X(I), D(I), I = 1, P)     
 400  FORMAT(/23H     I     INITIAL X(I),8X,4HD(I)//(1X,I5,E17.6,E14.3))
C     *** THE FOLLOWING ARE TO AVOID UNDEFINED VARIABLES WHEN THE       
C     *** FUNCTION EVALUATION LIMIT IS 1...                             
      V(DSTNRM) = ZERO                                                  
      V(FDIF) = ZERO                                                    
      V(NREDUC) = ZERO                                                  
      V(PREDUC) = ZERO                                                  
      V(RELDX) = ZERO                                                   
      IF (IV1 .GE. 12) GO TO 999                                        
      IV(NEEDHD) = 0                                                    
      IV(PRNTIT) = 0                                                    
      IF (OL .EQ. 0) GO TO 999                                          
      IF (OL .LT. 0 .AND. ALG .EQ. 1) WRITE(PU,30)                      
      IF (OL .LT. 0 .AND. ALG .EQ. 2) WRITE(PU,40)                      
      IF (OL .GT. 0 .AND. ALG .EQ. 1) WRITE(PU,70)                      
      IF (OL .GT. 0 .AND. ALG .EQ. 2) WRITE(PU,80)                      
      IF (ALG .EQ. 1) WRITE(PU,410) IV(NFCALL), V(F)                    
      IF (ALG .EQ. 2) WRITE(PU,420) IV(NFCALL), V(F)                    
 410  FORMAT(/6H     0,I5,E10.3)                                        
 420  FORMAT(/6H     0,I5,E11.3)                                        
      GO TO 999                                                         
C                                                                       
C  ***  PRINT VARIOUS INFORMATION REQUESTED ON SOLUTION  ***            
C                                                                       
 430  IV(NEEDHD) = 1                                                    
      IF (IV(STATPR) .LE. 0) GO TO 460                                  
         OLDF = AMAX1( ABS(V(F0)),  ABS(V(F)))                          
         PRELDF = ZERO                                                  
         NRELDF = ZERO                                                  
         IF (OLDF .LE. ZERO) GO TO 440                                  
              PRELDF = V(PREDUC) / OLDF                                 
              NRELDF = V(NREDUC) / OLDF                                 
 440     NF = IV(NFCALL) - IV(NFCOV)                                    
         NG = IV(NGCALL) - IV(NGCOV)                                    
         WRITE(PU,450) V(F), V(RELDX), NF, NG, PRELDF, NRELDF           
 450  FORMAT(/9H FUNCTION,E17.6,8H   RELDX,E17.3/12H FUNC. EVALS,       
     1   I8,9X,11HGRAD. EVALS,I8/7H PRELDF,E16.3,6X,7HNPRELDF,E15.3)    
C                                                                       
 460  IF (IV(SOLPRT) .EQ. 0) GO TO 999                                  
         IV(NEEDHD) = 1                                                 
         IF (IV(ALGSAV) .GT. 2) GO TO 999                               
         WRITE(PU,470)                                                  
 470  FORMAT(/22H     I      FINAL X(I),8X,4HD(I),10X,4HG(I)/)          
         DO 480 I = 1, P                                                
 480          WRITE(PU,490) I, X(I), D(I), G(I)                         
 490     FORMAT(1X,I5,E16.6,2E14.3)                                     
      GO TO 999                                                         
C                                                                       
 500  WRITE(PU,510)                                                     
 510  FORMAT(/24H INCONSISTENT DIMENSIONS)                              
 999  RETURN                                                            
C  ***  LAST CARD OF ITSUM FOLLOWS  ***                                 
      END                                                               
      SUBROUTINE  V7VMP(N, X, Y, Z, K)                                  
C                                                                       
C ***  SET X(I) = Y(I) * Z(I)**K, 1 .LE. I .LE. N (FOR K = 1 OR -1)  ***
C                                                                       
      INTEGER N, K                                                      
      REAL X(N), Y(N), Z(N)                                             
      INTEGER I                                                         
C                                                                       
      IF (K .GE. 0) GO TO 20                                            
      DO 10 I = 1, N                                                    
 10      X(I) = Y(I) / Z(I)                                             
      GO TO 999                                                         
C                                                                       
 20   DO 30 I = 1, N                                                    
 30      X(I) = Y(I) * Z(I)                                             
 999  RETURN                                                            
C  ***  LAST CARD OF  V7VMP FOLLOWS  ***                                
      END                                                               
      SUBROUTINE  V7IPR(N, IP, X)                                       
C                                                                       
C     PERMUTE X SO THAT X.OUTPUT(I) = X.INPUT(IP(I)).                   
C     IP IS UNCHANGED ON OUTPUT.                                        
C                                                                       
      INTEGER N                                                         
      INTEGER IP(N)                                                     
      REAL X(N)                                                         
C                                                                       
      INTEGER I, J, K                                                   
      REAL T                                                            
      DO 30 I = 1, N                                                    
         J = IP(I)                                                      
         IF (J .EQ. I) GO TO 30                                         
         IF (J .GT. 0) GO TO 10                                         
            IP(I) = -J                                                  
            GO TO 30                                                    
 10      T = X(I)                                                       
         K = I                                                          
 20      X(K) = X(J)                                                    
         K = J                                                          
         J = IP(K)                                                      
         IP(K) = -J                                                     
         IF (J .GT. I) GO TO 20                                         
         X(K) = T                                                       
 30      CONTINUE                                                       
 999  RETURN                                                            
C  ***  LAST LINE OF  V7IPR FOLLOWS  ***                                
      END                                                               
      SUBROUTINE G7QTS(D, DIG, DIHDI, KA, L, P, STEP, V, W)             
C                                                                       
C  *** COMPUTE GOLDFELD-QUANDT-TROTTER STEP BY MORE-HEBDEN TECHNIQUE ***
C  ***  (NL2SOL VERSION 2.2), MODIFIED A LA MORE AND SORENSEN  ***      
C                                                                       
C  ***  PARAMETER DECLARATIONS  ***                                     
C                                                                       
      INTEGER KA, P                                                     
      REAL D(P), DIG(P), DIHDI(1), L(1), V(21), STEP(P),                
     1                 W(1)                                             
C     DIMENSION DIHDI(P*(P+1)/2), L(P*(P+1)/2), W(4*P+7)                
C                                                                       
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C                                                                       
C  ***  PURPOSE  ***                                                    
C                                                                       
C        GIVEN THE (COMPACTLY STORED) LOWER TRIANGLE OF A SCALED        
C     HESSIAN (APPROXIMATION) AND A NONZERO SCALED GRADIENT VECTOR,     
C     THIS SUBROUTINE COMPUTES A GOLDFELD-QUANDT-TROTTER STEP OF        
C     APPROXIMATE LENGTH V(RADIUS) BY THE MORE-HEBDEN TECHNIQUE.  IN    
C     OTHER WORDS, STEP IS COMPUTED TO (APPROXIMATELY) MINIMIZE         
C     PSI(STEP) = (G**T)*STEP + 0.5*(STEP**T)*H*STEP  SUCH THAT THE     
C     2-NORM OF D*STEP IS AT MOST (APPROXIMATELY) V(RADIUS), WHERE      
C     G  IS THE GRADIENT,  H  IS THE HESSIAN, AND  D  IS A DIAGONAL     
C     SCALE MATRIX WHOSE DIAGONAL IS STORED IN THE PARAMETER D.         
C     (G7QTS ASSUMES  DIG = D**-1 * G  AND  DIHDI = D**-1 * H * D**-1.) 
C                                                                       
C  ***  PARAMETER DESCRIPTION  ***                                      
C                                                                       
C     D (IN)  = THE SCALE VECTOR, I.E. THE DIAGONAL OF THE SCALE        
C              MATRIX  D  MENTIONED ABOVE UNDER PURPOSE.                
C   DIG (IN)  = THE SCALED GRADIENT VECTOR, D**-1 * G.  IF G = 0, THEN  
C              STEP = 0  AND  V(STPPAR) = 0  ARE RETURNED.              
C DIHDI (IN)  = LOWER TRIANGLE OF THE SCALED HESSIAN (APPROXIMATION),   
C              I.E., D**-1 * H * D**-1, STORED COMPACTLY BY ROWS., I.E.,
C              IN THE ORDER (1,1), (2,1), (2,2), (3,1), (3,2), ETC.     
C    KA (I/O) = THE NUMBER OF HEBDEN ITERATIONS (SO FAR) TAKEN TO DETER-
C              MINE STEP.  KA .LT. 0 ON INPUT MEANS THIS IS THE FIRST   
C              ATTEMPT TO DETERMINE STEP (FOR THE PRESENT DIG AND DIHDI)
C              -- KA IS INITIALIZED TO 0 IN THIS CASE.  OUTPUT WITH     
C              KA = 0  (OR V(STPPAR) = 0)  MEANS  STEP = -(H**-1)*G.    
C     L (I/O) = WORKSPACE OF LENGTH P*(P+1)/2 FOR CHOLESKY FACTORS.     
C     P (IN)  = NUMBER OF PARAMETERS -- THE HESSIAN IS A  P X P  MATRIX.
C  STEP (I/O) = THE STEP COMPUTED.                                      
C     V (I/O) CONTAINS VARIOUS CONSTANTS AND VARIABLES DESCRIBED BELOW. 
C     W (I/O) = WORKSPACE OF LENGTH 4*P + 6.                            
C                                                                       
C  ***  ENTRIES IN V  ***                                               
C                                                                       
C V(DGNORM) (I/O) = 2-NORM OF (D**-1)*G.                                
C V(DSTNRM) (OUTPUT) = 2-NORM OF D*STEP.                                
C V(DST0)   (I/O) = 2-NORM OF D*(H**-1)*G (FOR POS. DEF. H ONLY), OR    
C             OVERESTIMATE OF SMALLEST EIGENVALUE OF (D**-1)*H*(D**-1). 
C V(EPSLON) (IN)  = MAX. REL. ERROR ALLOWED FOR PSI(STEP).  FOR THE     
C             STEP RETURNED, PSI(STEP) WILL EXCEED ITS OPTIMAL VALUE    
C             BY LESS THAN -V(EPSLON)*PSI(STEP).  SUGGESTED VALUE = 0.1.
C V(GTSTEP) (OUT) = INNER PRODUCT BETWEEN G AND STEP.                   
C V(NREDUC) (OUT) = PSI(-(H**-1)*G) = PSI(NEWTON STEP)  (FOR POS. DEF.  
C             H ONLY -- V(NREDUC) IS SET TO ZERO OTHERWISE).            
C V(PHMNFC) (IN)  = TOL. (TOGETHER WITH V(PHMXFC)) FOR ACCEPTING STEP   
C             (MORE*S SIGMA).  THE ERROR V(DSTNRM) - V(RADIUS) MUST LIE 
C             BETWEEN V(PHMNFC)*V(RADIUS) AND V(PHMXFC)*V(RADIUS).      
C V(PHMXFC) (IN)  (SEE V(PHMNFC).)                                      
C             SUGGESTED VALUES -- V(PHMNFC) = -0.25, V(PHMXFC) = 0.5.   
C V(PREDUC) (OUT) = PSI(STEP) = PREDICTED OBJ. FUNC. REDUCTION FOR STEP.
C V(RADIUS) (IN)  = RADIUS OF CURRENT (SCALED) TRUST REGION.            
C V(RAD0)   (I/O) = VALUE OF V(RADIUS) FROM PREVIOUS CALL.              
C V(STPPAR) (I/O) IS NORMALLY THE MARQUARDT PARAMETER, I.E. THE ALPHA   
C             DESCRIBED BELOW UNDER ALGORITHM NOTES.  IF H + ALPHA*D**2 
C             (SEE ALGORITHM NOTES) IS (NEARLY) SINGULAR, HOWEVER,      
C             THEN V(STPPAR) = -ALPHA.                                  
C                                                                       
C  ***  USAGE NOTES  ***                                                
C                                                                       
C     IF IT IS DESIRED TO RECOMPUTE STEP USING A DIFFERENT VALUE OF     
C     V(RADIUS), THEN THIS ROUTINE MAY BE RESTARTED BY CALLING IT       
C     WITH ALL PARAMETERS UNCHANGED EXCEPT V(RADIUS).  (THIS EXPLAINS   
C     WHY STEP AND W ARE LISTED AS I/O).  ON AN INITIAL CALL (ONE WITH  
C     KA .LT. 0), STEP AND W NEED NOT BE INITIALIZED AND ONLY COMPO-    
C     NENTS V(EPSLON), V(STPPAR), V(PHMNFC), V(PHMXFC), V(RADIUS), AND  
C     V(RAD0) OF V MUST BE INITIALIZED.                                 
C                                                                       
C  ***  ALGORITHM NOTES  ***                                            
C                                                                       
C        THE DESIRED G-Q-T STEP (REF. 2, 3, 4, 6) SATISFIES             
C     (H + ALPHA*D**2)*STEP = -G  FOR SOME NONNEGATIVE ALPHA SUCH THAT  
C     H + ALPHA*D**2 IS POSITIVE SEMIDEFINITE.  ALPHA AND STEP ARE      
C     COMPUTED BY A SCHEME ANALOGOUS TO THE ONE DESCRIBED IN REF. 5.    
C     ESTIMATES OF THE SMALLEST AND LARGEST EIGENVALUES OF THE HESSIAN  
C     ARE OBTAINED FROM THE GERSCHGORIN CIRCLE THEOREM ENHANCED BY A    
C     SIMPLE FORM OF THE SCALING DESCRIBED IN REF. 7.  CASES IN WHICH   
C     H + ALPHA*D**2 IS NEARLY (OR EXACTLY) SINGULAR ARE HANDLED BY     
C     THE TECHNIQUE DISCUSSED IN REF. 2.  IN THESE CASES, A STEP OF     
C     (EXACT) LENGTH V(RADIUS) IS RETURNED FOR WHICH PSI(STEP) EXCEEDS  
C     ITS OPTIMAL VALUE BY LESS THAN -V(EPSLON)*PSI(STEP).  THE TEST    
C     SUGGESTED IN REF. 6 FOR DETECTING THE SPECIAL CASE IS PERFORMED   
C     ONCE TWO MATRIX FACTORIZATIONS HAVE BEEN DONE -- DOING SO SOONER  
C     SEEMS TO DEGRADE THE PERFORMANCE OF OPTIMIZATION ROUTINES THAT    
C     CALL THIS ROUTINE.                                                
C                                                                       
C  ***  FUNCTIONS AND SUBROUTINES CALLED  ***                           
C                                                                       
C  D7TPR - RETURNS INNER PRODUCT OF TWO VECTORS.                        
C  L7ITV - APPLIES INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.   
C  L7IVM - APPLIES INVERSE OF COMPACT LOWER TRIANG. MATRIX.             
C L7SRT  - FINDS CHOLESKY FACTOR (OF COMPACTLY STORED LOWER TRIANG.).   
C  L7SVN - RETURNS APPROX. TO MIN. SING. VALUE OF LOWER TRIANG. MATRIX. 
C  R7MDC - RETURNS MACHINE-DEPENDENT CONSTANTS.                         
C  V2NRM - RETURNS 2-NORM OF A VECTOR.                                  
C                                                                       
C  ***  REFERENCES  ***                                                 
C                                                                       
C 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1981), AN ADAPTIVE     
C             NONLINEAR LEAST-SQUARES ALGORITHM, ACM TRANS. MATH.       
C             SOFTWARE, VOL. 7, NO. 3.                                  
C 2.  GAY, D.M. (1981), COMPUTING OPTIMAL LOCALLY CONSTRAINED STEPS,    
C             SIAM J. SCI. STATIST. COMPUTING, VOL. 2, NO. 2, PP.       
C             186-197.                                                  
C 3.  GOLDFELD, S.M., QUANDT, R.E., AND TROTTER, H.F. (1966),           
C             MAXIMIZATION BY QUADRATIC HILL-CLIMBING, ECONOMETRICA 34, 
C             PP. 541-551.                                              
C 4.  HEBDEN, M.D. (1973), AN ALGORITHM FOR MINIMIZATION USING EXACT    
C             SECOND DERIVATIVES, REPORT T.P. 515, THEORETICAL PHYSICS  
C             DIV., A.E.R.E. HARWELL, OXON., ENGLAND.                   
C 5.  MORE, J.J. (1978), THE LEVENBERG-MARQUARDT ALGORITHM, IMPLEMEN-   
C             TATION AND THEORY, PP.105-116 OF SPRINGER LECTURE NOTES   
C             IN MATHEMATICS NO. 630, EDITED BY G.A. WATSON, SPRINGER-  
C             VERLAG, BERLIN AND NEW YORK.                              
C 6.  MORE, J.J., AND SORENSEN, D.C. (1981), COMPUTING A TRUST REGION   
C             STEP, TECHNICAL REPORT ANL-81-83, ARGONNE NATIONAL LAB.   
C 7.  VARGA, R.S. (1965), MINIMAL GERSCHGORIN SETS, PACIFIC J. MATH. 15,
C             PP. 719-729.                                              
C                                                                       
C  ***  GENERAL  ***                                                    
C                                                                       
C     CODED BY DAVID M. GAY.                                            
C     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH           
C     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS         
C     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND           
C     MCS-7906671.                                                      
C                                                                       
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C                                                                       
C  ***  LOCAL VARIABLES  ***                                            
C                                                                       
      LOGICAL RESTRT                                                    
      INTEGER DGGDMX, DIAG, DIAG0, DSTSAV, EMAX, EMIN, I, IM1, INC, IRC,
     1        J, K, KALIM, KAMIN, K1, LK0, PHIPIN, Q, Q0, UK0, X        
      REAL ALPHAK, AKI, AKK, DELTA, DST, EPS, GTSTA, LK,                
     1                 OLDPHI, PHI, PHIMAX, PHIMIN, PSIFAC, RAD, RADSQ, 
     2                 ROOT, SI, SK, SW, T, TWOPSI, T1, T2, UK, WI      
C                                                                       
C     ***  CONSTANTS  ***                                               
      REAL BIG, DGXFAC, EPSFAC, FOUR, HALF, KAPPA, NEGONE,              
     1                 ONE, P001, SIX, THREE, TWO, ZERO                 
C                                                                       
C  ***  INTRINSIC FUNCTIONS  ***                                        
C/+                                                                     
      REAL  SQRT                                                        
C/                                                                      
C  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***                         
C                                                                       
      REAL  D7TPR,  L7SVN,  R7MDC,  V2NRM                               
      EXTERNAL  D7TPR,  L7ITV,  L7IVM, L7SRT,  L7SVN,  R7MDC,  V2NRM    
C                                                                       
C  ***  SUBSCRIPTS FOR V  ***                                           
C                                                                       
      INTEGER DGNORM, DSTNRM, DST0, EPSLON, GTSTEP, STPPAR, NREDUC,     
     1        PHMNFC, PHMXFC, PREDUC, RADIUS, RAD0                      
C/6                                                                     
C     DATA DGNORM/1/, DSTNRM/2/, DST0/3/, EPSLON/19/, GTSTEP/4/,        
C    1     NREDUC/6/, PHMNFC/20/, PHMXFC/21/, PREDUC/7/, RADIUS/8/,     
C    2     RAD0/9/, STPPAR/5/                                           
C/7                                                                     
      PARAMETER (DGNORM=1, DSTNRM=2, DST0=3, EPSLON=19, GTSTEP=4,       
     1           NREDUC=6, PHMNFC=20, PHMXFC=21, PREDUC=7, RADIUS=8,    
     2           RAD0=9, STPPAR=5)                                      
C/                                                                      
C                                                                       
C/6                                                                     
C     DATA EPSFAC/50.0E+0/, FOUR/4.0E+0/, HALF/0.5E+0/,                 
C    1     KAPPA/2.0E+0/, NEGONE/-1.0E+0/, ONE/1.0E+0/, P001/1.0E-3/,   
C    2     SIX/6.0E+0/, THREE/3.0E+0/, TWO/2.0E+0/, ZERO/0.0E+0/        
C/7                                                                     
      PARAMETER (EPSFAC=50.0E+0, FOUR=4.0E+0, HALF=0.5E+0,              
     1     KAPPA=2.0E+0, NEGONE=-1.0E+0, ONE=1.0E+0, P001=1.0E-3,       
     2     SIX=6.0E+0, THREE=3.0E+0, TWO=2.0E+0, ZERO=0.0E+0)           
      SAVE DGXFAC                                                       
C/                                                                      
      DATA BIG/0.E+0/, DGXFAC/0.E+0/                                    
C                                                                       
C  ***  BODY  ***                                                       
C                                                                       
      IF (BIG .LE. ZERO) BIG =  R7MDC(6)                                
C                                                                       
C     ***  STORE LARGEST ABS. ENTRY IN (D**-1)*H*(D**-1) AT W(DGGDMX).  
      DGGDMX = P + 1                                                    
C     ***  STORE GERSCHGORIN OVER- AND UNDERESTIMATES OF THE LARGEST    
C     ***  AND SMALLEST EIGENVALUES OF (D**-1)*H*(D**-1) AT W(EMAX)     
C     ***  AND W(EMIN) RESPECTIVELY.                                    
      EMAX = DGGDMX + 1                                                 
      EMIN = EMAX + 1                                                   
C     ***  FOR USE IN RECOMPUTING STEP, THE FINAL VALUES OF LK, UK, DST,
C     ***  AND THE INVERSE DERIVATIVE OF MORE*S PHI AT 0 (FOR POS. DEF. 
C     ***  H) ARE STORED IN W(LK0), W(UK0), W(DSTSAV), AND W(PHIPIN)    
C     ***  RESPECTIVELY.                                                
      LK0 = EMIN + 1                                                    
      PHIPIN = LK0 + 1                                                  
      UK0 = PHIPIN + 1                                                  
      DSTSAV = UK0 + 1                                                  
C     ***  STORE DIAG OF (D**-1)*H*(D**-1) IN W(DIAG),...,W(DIAG0+P).   
      DIAG0 = DSTSAV                                                    
      DIAG = DIAG0 + 1                                                  
C     ***  STORE -D*STEP IN W(Q),...,W(Q0+P).                           
      Q0 = DIAG0 + P                                                    
      Q = Q0 + 1                                                        
C     ***  ALLOCATE STORAGE FOR SCRATCH VECTOR X  ***                   
      X = Q + P                                                         
      RAD = V(RADIUS)                                                   
      RADSQ = RAD**2                                                    
C     ***  PHITOL = MAX. ERROR ALLOWED IN DST = V(DSTNRM) = 2-NORM OF   
C     ***  D*STEP.                                                      
      PHIMAX = V(PHMXFC) * RAD                                          
      PHIMIN = V(PHMNFC) * RAD                                          
      PSIFAC = BIG                                                      
      T1 = TWO * V(EPSLON) / (THREE * (FOUR * (V(PHMNFC) + ONE) *       
     1                       (KAPPA + ONE)  +  KAPPA  +  TWO) * RAD)    
      IF (T1 .LT. BIG*AMIN1(RAD,ONE)) PSIFAC = T1 / RAD                 
C     ***  OLDPHI IS USED TO DETECT LIMITS OF NUMERICAL ACCURACY.  IF   
C     ***  WE RECOMPUTE STEP AND IT DOES NOT CHANGE, THEN WE ACCEPT IT. 
      OLDPHI = ZERO                                                     
      EPS = V(EPSLON)                                                   
      IRC = 0                                                           
      RESTRT = .FALSE.                                                  
      KALIM = KA + 50                                                   
C                                                                       
C  ***  START OR RESTART, DEPENDING ON KA  ***                          
C                                                                       
      IF (KA .GE. 0) GO TO 290                                          
C                                                                       
C  ***  FRESH START  ***                                                
C                                                                       
      K = 0                                                             
      UK = NEGONE                                                       
      KA = 0                                                            
      KALIM = 50                                                        
      V(DGNORM) =  V2NRM(P, DIG)                                        
      V(NREDUC) = ZERO                                                  
      V(DST0) = ZERO                                                    
      KAMIN = 3                                                         
      IF (V(DGNORM) .EQ. ZERO) KAMIN = 0                                
C                                                                       
C     ***  STORE DIAG(DIHDI) IN W(DIAG0+1),...,W(DIAG0+P)  ***          
C                                                                       
      J = 0                                                             
      DO 10 I = 1, P                                                    
         J = J + I                                                      
         K1 = DIAG0 + I                                                 
         W(K1) = DIHDI(J)                                               
 10      CONTINUE                                                       
C                                                                       
C     ***  DETERMINE W(DGGDMX), THE LARGEST ELEMENT OF DIHDI  ***       
C                                                                       
      T1 = ZERO                                                         
      J = P * (P + 1) / 2                                               
      DO 20 I = 1, J                                                    
         T =  ABS(DIHDI(I))                                             
         IF (T1 .LT. T) T1 = T                                          
 20      CONTINUE                                                       
      W(DGGDMX) = T1                                                    
C                                                                       
C  ***  TRY ALPHA = 0  ***                                              
C                                                                       
 30   CALL L7SRT(1, P, L, DIHDI, IRC)                                   
      IF (IRC .EQ. 0) GO TO 50                                          
C        ***  INDEF. H -- UNDERESTIMATE SMALLEST EIGENVALUE, USE THIS   
C        ***  ESTIMATE TO INITIALIZE LOWER BOUND LK ON ALPHA.           
         J = IRC*(IRC+1)/2                                              
         T = L(J)                                                       
         L(J) = ONE                                                     
         DO 40 I = 1, IRC                                               
 40           W(I) = ZERO                                               
         W(IRC) = ONE                                                   
         CALL  L7ITV(IRC, W, L, W)                                      
         T1 =  V2NRM(IRC, W)                                            
         LK = -T / T1 / T1                                              
         V(DST0) = -LK                                                  
         IF (RESTRT) GO TO 210                                          
         GO TO 70                                                       
C                                                                       
C     ***  POSITIVE DEFINITE H -- COMPUTE UNMODIFIED NEWTON STEP.  ***  
 50   LK = ZERO                                                         
      T =  L7SVN(P, L, W(Q), W(Q))                                      
      IF (T .GE. ONE) GO TO 60                                          
         IF (V(DGNORM) .GE. T*T*BIG) GO TO 70                           
 60   CALL  L7IVM(P, W(Q), L, DIG)                                      
      GTSTA =  D7TPR(P, W(Q), W(Q))                                     
      V(NREDUC) = HALF * GTSTA                                          
      CALL  L7ITV(P, W(Q), L, W(Q))                                     
      DST =  V2NRM(P, W(Q))                                             
      V(DST0) = DST                                                     
      PHI = DST - RAD                                                   
      IF (PHI .LE. PHIMAX) GO TO 260                                    
      IF (RESTRT) GO TO 210                                             
C                                                                       
C  ***  PREPARE TO COMPUTE GERSCHGORIN ESTIMATES OF LARGEST (AND        
C  ***  SMALLEST) EIGENVALUES.  ***                                     
C                                                                       
 70   K = 0                                                             
      DO 100 I = 1, P                                                   
         WI = ZERO                                                      
         IF (I .EQ. 1) GO TO 90                                         
         IM1 = I - 1                                                    
         DO 80 J = 1, IM1                                               
              K = K + 1                                                 
              T =  ABS(DIHDI(K))                                        
              WI = WI + T                                               
              W(J) = W(J) + T                                           
 80           CONTINUE                                                  
 90      W(I) = WI                                                      
         K = K + 1                                                      
 100     CONTINUE                                                       
C                                                                       
C  ***  (UNDER-)ESTIMATE SMALLEST EIGENVALUE OF (D**-1)*H*(D**-1)  ***  
C                                                                       
      K = 1                                                             
      T1 = W(DIAG) - W(1)                                               
      IF (P .LE. 1) GO TO 120                                           
      DO 110 I = 2, P                                                   
         J = DIAG0 + I                                                  
         T = W(J) - W(I)                                                
         IF (T .GE. T1) GO TO 110                                       
              T1 = T                                                    
              K = I                                                     
 110     CONTINUE                                                       
C                                                                       
 120  SK = W(K)                                                         
      J = DIAG0 + K                                                     
      AKK = W(J)                                                        
      K1 = K*(K-1)/2 + 1                                                
      INC = 1                                                           
      T = ZERO                                                          
      DO 150 I = 1, P                                                   
         IF (I .EQ. K) GO TO 130                                        
         AKI =  ABS(DIHDI(K1))                                          
         SI = W(I)                                                      
         J = DIAG0 + I                                                  
         T1 = HALF * (AKK - W(J) + SI - AKI)                            
         T1 = T1 +  SQRT(T1*T1 + SK*AKI)                                
         IF (T .LT. T1) T = T1                                          
         IF (I .LT. K) GO TO 140                                        
 130     INC = I                                                        
 140     K1 = K1 + INC                                                  
 150     CONTINUE                                                       
C                                                                       
      W(EMIN) = AKK - T                                                 
      UK = V(DGNORM)/RAD - W(EMIN)                                      
      IF (V(DGNORM) .EQ. ZERO) UK = UK + P001 + P001*UK                 
      IF (UK .LE. ZERO) UK = P001                                       
C                                                                       
C  ***  COMPUTE GERSCHGORIN (OVER-)ESTIMATE OF LARGEST EIGENVALUE  ***  
C                                                                       
      K = 1                                                             
      T1 = W(DIAG) + W(1)                                               
      IF (P .LE. 1) GO TO 170                                           
      DO 160 I = 2, P                                                   
         J = DIAG0 + I                                                  
         T = W(J) + W(I)                                                
         IF (T .LE. T1) GO TO 160                                       
              T1 = T                                                    
              K = I                                                     
 160     CONTINUE                                                       
C                                                                       
 170  SK = W(K)                                                         
      J = DIAG0 + K                                                     
      AKK = W(J)                                                        
      K1 = K*(K-1)/2 + 1                                                
      INC = 1                                                           
      T = ZERO                                                          
      DO 200 I = 1, P                                                   
         IF (I .EQ. K) GO TO 180                                        
         AKI =  ABS(DIHDI(K1))                                          
         SI = W(I)                                                      
         J = DIAG0 + I                                                  
         T1 = HALF * (W(J) + SI - AKI - AKK)                            
         T1 = T1 +  SQRT(T1*T1 + SK*AKI)                                
         IF (T .LT. T1) T = T1                                          
         IF (I .LT. K) GO TO 190                                        
 180     INC = I                                                        
 190     K1 = K1 + INC                                                  
 200     CONTINUE                                                       
C                                                                       
      W(EMAX) = AKK + T                                                 
      LK = AMAX1(LK, V(DGNORM)/RAD - W(EMAX))                           
C                                                                       
C     ***  ALPHAK = CURRENT VALUE OF ALPHA (SEE ALG. NOTES ABOVE).  WE  
C     ***  USE MORE*S SCHEME FOR INITIALIZING IT.                       
      ALPHAK =  ABS(V(STPPAR)) * V(RAD0)/RAD                            
      ALPHAK = AMIN1(UK, AMAX1(ALPHAK, LK))                             
C                                                                       
      IF (IRC .NE. 0) GO TO 210                                         
C                                                                       
C  ***  COMPUTE L0 FOR POSITIVE DEFINITE H  ***                         
C                                                                       
      CALL  L7IVM(P, W, L, W(Q))                                        
      T =  V2NRM(P, W)                                                  
      W(PHIPIN) = RAD / T / T                                           
      LK = AMAX1(LK, PHI*W(PHIPIN))                                     
C                                                                       
C  ***  SAFEGUARD ALPHAK AND ADD ALPHAK*I TO (D**-1)*H*(D**-1)  ***     
C                                                                       
 210  KA = KA + 1                                                       
      IF (-V(DST0) .GE. ALPHAK .OR. ALPHAK .LT. LK .OR. ALPHAK .GE. UK) 
     1                      ALPHAK = UK * AMAX1(P001,  SQRT(LK/UK))     
      IF (ALPHAK .LE. ZERO) ALPHAK = HALF * UK                          
      IF (ALPHAK .LE. ZERO) ALPHAK = UK                                 
      K = 0                                                             
      DO 220 I = 1, P                                                   
         K = K + I                                                      
         J = DIAG0 + I                                                  
         DIHDI(K) = W(J) + ALPHAK                                       
 220     CONTINUE                                                       
C                                                                       
C  ***  TRY COMPUTING CHOLESKY DECOMPOSITION  ***                       
C                                                                       
      CALL L7SRT(1, P, L, DIHDI, IRC)                                   
      IF (IRC .EQ. 0) GO TO 240                                         
C                                                                       
C  ***  (D**-1)*H*(D**-1) + ALPHAK*I  IS INDEFINITE -- OVERESTIMATE     
C  ***  SMALLEST EIGENVALUE FOR USE IN UPDATING LK  ***                 
C                                                                       
      J = (IRC*(IRC+1))/2                                               
      T = L(J)                                                          
      L(J) = ONE                                                        
      DO 230 I = 1, IRC                                                 
 230     W(I) = ZERO                                                    
      W(IRC) = ONE                                                      
      CALL  L7ITV(IRC, W, L, W)                                         
      T1 =  V2NRM(IRC, W)                                               
      LK = ALPHAK - T/T1/T1                                             
      V(DST0) = -LK                                                     
      IF (UK .LT. LK) UK = LK                                           
      IF (ALPHAK .LT. LK) GO TO 210                                     
C                                                                       
C  ***  NASTY CASE -- EXACT GERSCHGORIN BOUNDS.  FUDGE LK, UK...        
C                                                                       
      T = P001 * ALPHAK                                                 
      IF (T .LE. ZERO) T = P001                                         
      LK = ALPHAK + T                                                   
      IF (UK .LE. LK) UK = LK + T                                       
      GO TO 210                                                         
C                                                                       
C  ***  ALPHAK MAKES (D**-1)*H*(D**-1) POSITIVE DEFINITE.               
C  ***  COMPUTE Q = -D*STEP, CHECK FOR CONVERGENCE.  ***                
C                                                                       
 240  CALL  L7IVM(P, W(Q), L, DIG)                                      
      GTSTA =  D7TPR(P, W(Q), W(Q))                                     
      CALL  L7ITV(P, W(Q), L, W(Q))                                     
      DST =  V2NRM(P, W(Q))                                             
      PHI = DST - RAD                                                   
      IF (PHI .LE. PHIMAX .AND. PHI .GE. PHIMIN) GO TO 270              
      IF (PHI .EQ. OLDPHI) GO TO 270                                    
      OLDPHI = PHI                                                      
      IF (PHI .LT. ZERO) GO TO 330                                      
C                                                                       
C  ***  UNACCEPTABLE ALPHAK -- UPDATE LK, UK, ALPHAK  ***               
C                                                                       
 250  IF (KA .GE. KALIM) GO TO 270                                      
C     ***  THE FOLLOWING AMIN1 IS NECESSARY BECAUSE OF RESTARTS  ***    
      IF (PHI .LT. ZERO) UK = AMIN1(UK, ALPHAK)                         
C     *** KAMIN = 0 ONLY IFF THE GRADIENT VANISHES  ***                 
      IF (KAMIN .EQ. 0) GO TO 210                                       
      CALL  L7IVM(P, W, L, W(Q))                                        
C     *** THE FOLLOWING, COMMENTED CALCULATION OF ALPHAK IS SOMETIMES   
C     *** SAFER BUT WORSE IN PERFORMANCE...                             
C     T1 = DST /  V2NRM(P, W)                                           
C     ALPHAK = ALPHAK  +  T1 * (PHI/RAD) * T1                           
      T1 =  V2NRM(P, W)                                                 
      ALPHAK = ALPHAK  +  (PHI/T1) * (DST/T1) * (DST/RAD)               
      LK = AMAX1(LK, ALPHAK)                                            
      ALPHAK = LK                                                       
      GO TO 210                                                         
C                                                                       
C  ***  ACCEPTABLE STEP ON FIRST TRY  ***                               
C                                                                       
 260  ALPHAK = ZERO                                                     
C                                                                       
C  ***  SUCCESSFUL STEP IN GENERAL.  COMPUTE STEP = -(D**-1)*Q  ***     
C                                                                       
 270  DO 280 I = 1, P                                                   
         J = Q0 + I                                                     
         STEP(I) = -W(J)/D(I)                                           
 280     CONTINUE                                                       
      V(GTSTEP) = -GTSTA                                                
      V(PREDUC) = HALF * ( ABS(ALPHAK)*DST*DST + GTSTA)                 
      GO TO 410                                                         
C                                                                       
C                                                                       
C  ***  RESTART WITH NEW RADIUS  ***                                    
C                                                                       
 290  IF (V(DST0) .LE. ZERO .OR. V(DST0) - RAD .GT. PHIMAX) GO TO 310   
C                                                                       
C     ***  PREPARE TO RETURN NEWTON STEP  ***                           
C                                                                       
         RESTRT = .TRUE.                                                
         KA = KA + 1                                                    
         K = 0                                                          
         DO 300 I = 1, P                                                
              K = K + I                                                 
              J = DIAG0 + I                                             
              DIHDI(K) = W(J)                                           
 300          CONTINUE                                                  
         UK = NEGONE                                                    
         GO TO 30                                                       
C                                                                       
 310  KAMIN = KA + 3                                                    
      IF (V(DGNORM) .EQ. ZERO) KAMIN = 0                                
      IF (KA .EQ. 0) GO TO 50                                           
C                                                                       
      DST = W(DSTSAV)                                                   
      ALPHAK =  ABS(V(STPPAR))                                          
      PHI = DST - RAD                                                   
      T = V(DGNORM)/RAD                                                 
      UK = T - W(EMIN)                                                  
      IF (V(DGNORM) .EQ. ZERO) UK = UK + P001 + P001*UK                 
      IF (UK .LE. ZERO) UK = P001                                       
      IF (RAD .GT. V(RAD0)) GO TO 320                                   
C                                                                       
C        ***  SMALLER RADIUS  ***                                       
         LK = ZERO                                                      
         IF (ALPHAK .GT. ZERO) LK = W(LK0)                              
         LK = AMAX1(LK, T - W(EMAX))                                    
         IF (V(DST0) .GT. ZERO) LK = AMAX1(LK, (V(DST0)-RAD)*W(PHIPIN)) 
         GO TO 250                                                      
C                                                                       
C     ***  BIGGER RADIUS  ***                                           
 320  IF (ALPHAK .GT. ZERO) UK = AMIN1(UK, W(UK0))                      
      LK = AMAX1(ZERO, -V(DST0), T - W(EMAX))                           
      IF (V(DST0) .GT. ZERO) LK = AMAX1(LK, (V(DST0)-RAD)*W(PHIPIN))    
      GO TO 250                                                         
C                                                                       
C  ***  DECIDE WHETHER TO CHECK FOR SPECIAL CASE... IN PRACTICE (FROM   
C  ***  THE STANDPOINT OF THE CALLING OPTIMIZATION CODE) IT SEEMS BEST  
C  ***  NOT TO CHECK UNTIL A FEW ITERATIONS HAVE FAILED -- HENCE THE    
C  ***  TEST ON KAMIN BELOW.                                            
C                                                                       
 330  DELTA = ALPHAK + AMIN1(ZERO, V(DST0))                             
      TWOPSI = ALPHAK*DST*DST + GTSTA                                   
      IF (KA .GE. KAMIN) GO TO 340                                      
C     *** IF THE TEST IN REF. 2 IS SATISFIED, FALL THROUGH TO HANDLE    
C     *** THE SPECIAL CASE (AS SOON AS THE MORE-SORENSEN TEST DETECTS   
C     *** IT).                                                          
      IF (PSIFAC .GE. BIG) GO TO 340                                    
      IF (DELTA .GE. PSIFAC*TWOPSI) GO TO 370                           
C                                                                       
C  ***  CHECK FOR THE SPECIAL CASE OF  H + ALPHA*D**2  (NEARLY)         
C  ***  SINGULAR.  USE ONE STEP OF INVERSE POWER METHOD WITH START      
C  ***  FROM  L7SVN TO OBTAIN APPROXIMATE EIGENVECTOR CORRESPONDING     
C  ***  TO SMALLEST EIGENVALUE OF (D**-1)*H*(D**-1).   L7SVN RETURNS    
C  ***  X AND W WITH  L*W = X.                                          
C                                                                       
 340  T =  L7SVN(P, L, W(X), W)                                         
C                                                                       
C     ***  NORMALIZE W  ***                                             
      DO 350 I = 1, P                                                   
 350     W(I) = T*W(I)                                                  
C     ***  COMPLETE CURRENT INV. POWER ITER. -- REPLACE W BY (L**-T)*W. 
      CALL  L7ITV(P, W, L, W)                                           
      T2 = ONE/ V2NRM(P, W)                                             
      DO 360 I = 1, P                                                   
 360     W(I) = T2*W(I)                                                 
      T = T2 * T                                                        
C                                                                       
C  ***  NOW W IS THE DESIRED APPROXIMATE (UNIT) EIGENVECTOR AND         
C  ***  T*X = ((D**-1)*H*(D**-1) + ALPHAK*I)*W.                         
C                                                                       
      SW =  D7TPR(P, W(Q), W)                                           
      T1 = (RAD + DST) * (RAD - DST)                                    
      ROOT =  SQRT(SW*SW + T1)                                          
      IF (SW .LT. ZERO) ROOT = -ROOT                                    
      SI = T1 / (SW + ROOT)                                             
C                                                                       
C  ***  THE ACTUAL TEST FOR THE SPECIAL CASE...                         
C                                                                       
      IF ((T2*SI)**2 .LE. EPS*(DST**2 + ALPHAK*RADSQ)) GO TO 380        
C                                                                       
C  ***  UPDATE UPPER BOUND ON SMALLEST EIGENVALUE (WHEN NOT POSITIVE)   
C  ***  (AS RECOMMENDED BY MORE AND SORENSEN) AND CONTINUE...           
C                                                                       
      IF (V(DST0) .LE. ZERO) V(DST0) = AMIN1(V(DST0), T2**2 - ALPHAK)   
      LK = AMAX1(LK, -V(DST0))                                          
C                                                                       
C  ***  CHECK WHETHER WE CAN HOPE TO DETECT THE SPECIAL CASE IN         
C  ***  THE AVAILABLE ARITHMETIC.  ACCEPT STEP AS IT IS IF NOT.         
C                                                                       
C     ***  IF NOT YET AVAILABLE, OBTAIN MACHINE DEPENDENT VALUE DGXFAC. 
 370  IF (DGXFAC .EQ. ZERO) DGXFAC = EPSFAC *  R7MDC(3)                 
C                                                                       
      IF (DELTA .GT. DGXFAC*W(DGGDMX)) GO TO 250                        
         GO TO 270                                                      
C                                                                       
C  ***  SPECIAL CASE DETECTED... NEGATE ALPHAK TO INDICATE SPECIAL CASE 
C                                                                       
 380  ALPHAK = -ALPHAK                                                  
      V(PREDUC) = HALF * TWOPSI                                         
C                                                                       
C  ***  ACCEPT CURRENT STEP IF ADDING SI*W WOULD LEAD TO A              
C  ***  FURTHER RELATIVE REDUCTION IN PSI OF LESS THAN V(EPSLON)/3.     
C                                                                       
      T1 = ZERO                                                         
      T = SI*(ALPHAK*SW - HALF*SI*(ALPHAK + T* D7TPR(P,W(X),W)))        
      IF (T .LT. EPS*TWOPSI/SIX) GO TO 390                              
         V(PREDUC) = V(PREDUC) + T                                      
         DST = RAD                                                      
         T1 = -SI                                                       
 390  DO 400 I = 1, P                                                   
         J = Q0 + I                                                     
         W(J) = T1*W(I) - W(J)                                          
         STEP(I) = W(J) / D(I)                                          
 400     CONTINUE                                                       
      V(GTSTEP) =  D7TPR(P, DIG, W(Q))                                  
C                                                                       
C  ***  SAVE VALUES FOR USE IN A POSSIBLE RESTART  ***                  
C                                                                       
 410  V(DSTNRM) = DST                                                   
      V(STPPAR) = ALPHAK                                                
      W(LK0) = LK                                                       
      W(UK0) = UK                                                       
      V(RAD0) = RAD                                                     
      W(DSTSAV) = DST                                                   
C                                                                       
C     ***  RESTORE DIAGONAL OF DIHDI  ***                               
C                                                                       
      J = 0                                                             
      DO 420 I = 1, P                                                   
         J = J + I                                                      
         K = DIAG0 + I                                                  
         DIHDI(J) = W(K)                                                
 420     CONTINUE                                                       
C                                                                       
 999  RETURN                                                            
C                                                                       
C  ***  LAST CARD OF G7QTS FOLLOWS  ***                                 
      END                                                               
C****END OF ROUTINES FOR FIRST PART OF THE PORT 3 OPTIMIZATION CHAPTER**
