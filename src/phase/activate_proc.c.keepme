/*   File      : /afs/psi.ch/user/f/flechsig/phase/src/phase/activate_proc.c */
/*   Date      : <10 Feb 04 16:32:30 flechsig>  */
/*   Time-stamp: <10 Mar 06 11:54:36 flechsig>  */
/*   Author    : Uwe Flechsig, flechsig@psi.ch */

/*   $Source$  */
/*   $Date$ */
/*   $Revision$  */
/*   $Author$  */


/* 23.11.98 SIS, SIM undulator eingefuegt UF */     
                                      
#ifdef HAVE_CONFIG_H
  #include <config.h>
#endif 

#include <stdio.h>   
#include <Xm/Text.h>  
#include <Xm/List.h>       
#include <Mrm/MrmAppl.h>  
#include <X11/Xlib.h>      
#include <X11/Xutil.h> 
#ifdef VMS 
  #include <processes.h>                       
  #include <descrip.h> 
  #include <DXm/DECspecific.h>    
#endif     
#include "cutils.h"     
#include "phase_struct.h"
#include "fg3pck.h" 
#include "mirrorpck.h"  
#include "geometrypck.h" 
#include "phase.h"       
#include "rtrace.h"    

void activate_proc(w, tag, reason)
     Widget		w;
     int			*tag;
     XmAnyCallbackStruct *reason;           
{
  int		widget_num = *tag; 	 /* Convert tag to widget number. */
  int		i, value, *itemlist[10]; /* for del gluebox */
  XmString	topic;    
  char 	command[MaxPathLength], buffer[MaxPathLength];
  extern GRDATSTRUCTTYPE grdatstruct; 
#ifdef VMS
  FString Fname;    
#endif
  struct BeamlineType *bl;
  void *vo;

  printf(" widget_num ",widget_num);     

  switch (widget_num) {

     /*******************   global ****************************************/

  case kNyi:                                       /* Not yet impl. Box */
    FetchWidget(kNyi, "nyi");        
    XtManageChild(widget_array[kNyi]);      
    break;                                  

  case k_create_options:
    create_color();
    break;

    /*******************    File Pdme    **********************************/

            
  case kFPrint:                                    /* File Menu */
    FetchWidget(kFPFBox, "FPrintFileBox"); 
    XtManageChild(widget_array[kFPFBox]);   
    break;      

  case kFPFOK:
    create_print();
    XtUnmanageChild(widget_array[kFPFBox]);  
    break;
  
  case kFPFAdd:                         /* Add Button  */
    ActivateFileSelection(widget_num, "p*.p*");   
    break;

  case kFPFDel:                        /* delete Matrix from List */
    value= XmListGetSelectedPos(widget_array[kFPFList], itemlist, &i);
    if (value == True)  	 {   
      XmListDeletePos(widget_array[kFPFList], **itemlist);   
      XtFree((char *)(*itemlist));      }    
    break;   
  
  case kFPFCancel:
    XtUnmanageChild(widget_array[kFPFBox]);  
    break; 
  
  case kFFile:                                     /* File File */
    FetchWidget(kFFileBox, "FFileBox"); 
    InitFileBox(&PHASESet);  
    XtManageChild(widget_array[kFFileBox]);   
    break;   
            
  case kFFileBoxOK:
    UpdateFilenames(&PHASESet);
    strcpy(buffer, PHASESet.pssourcename);
    /* BL sourcefiles ueberbuegeln !! Reihenfolge ist wichtig (buffer) */
    PutPHASE(&PHASESet, MainPickName);  

    /*  20. 10.97  InitDataSets(&PHASESet, (char *)MainPickName);*/
/* Sourcefilenames mit ueberbuegeln */
    FnameBody(buffer);
    /*    i= sizeof(Beamline.src.so4.fsource4a); */
    i=80; /* sonst zu gefaehrlich U.F. 6.1.00 */
    memset(&Beamline.src.so4.fsource4a, 0, i);
    memset(&Beamline.src.so4.fsource4b, 0, i);
    memset(&Beamline.src.so4.fsource4c, 0, i);
    memset(&Beamline.src.so4.fsource4d, 0, i);
    memset(&Beamline.src.so6.fsource6,  0, i);
    if(Beamline.BLOptions.ifl.ispline != -1)
      {
	sprintf(Beamline.src.so4.fsource4a, "%s.eyre", buffer);
	sprintf(Beamline.src.so4.fsource4b, "%s.eyim", buffer);
	sprintf(Beamline.src.so4.fsource4c, "%s.ezre", buffer);
	sprintf(Beamline.src.so4.fsource4d, "%s.ezim", buffer);
      }
    else
      {
	sprintf(Beamline.src.so4.fsource4a, "%s.yamp", buffer);
	sprintf(Beamline.src.so4.fsource4b, "%s.ypha", buffer);
	sprintf(Beamline.src.so4.fsource4c, "%s.zamp", buffer);
	sprintf(Beamline.src.so4.fsource4d, "%s.zpha", buffer);
      }
    sprintf(Beamline.src.so6.fsource6, "%s.brig", buffer);
    WriteBLFile(PHASESet.beamlinename, &Beamline);   

    /*    if ((widget_array[kESourceBox] != NULL) && 
	XtIsRealized(widget_array[kESourceBox])) 
      InitSourceBox(&Fg3ActDat, &Beamline, widget_num);   
    if ((widget_array[kEOElementBox] != NULL) &&
	XtIsRealized(widget_array[kEOElementBox]))		
      InitOElementBox(&MActDat, &GActDat, widget_num); 
    if ((widget_array[kEGeometryBox] != NULL) &&
	XtIsRealized(widget_array[kEGeometryBox]))
      InitGeometryBox(&GActDat);*/
    if ((widget_array[kCCOptiDialog] != NULL) &&
	XtIsRealized(widget_array[kCCOptiDialog]))
      InitOptiBox(PHASESet.optipckname, &Beamline); 
    XtUnmanageChild(widget_array[kFFileBox]); 
    break; 
 
  case kFFileBoxCancel:
    XtUnmanageChild(widget_array[kFFileBox]);    
    break;   

  case kFFileBoxExpand:
    ExpandFileNames(&PHASESet, "");  
    break;   

  case kFFileButton1:
    ActivateFileSelection(widget_num, "*.omx");   
    break;

  case kFFileButton2:
    ActivateFileSelection(widget_num, "*.map");   
    break;

  case kFFileButton3:
    ActivateFileSelection(widget_num, "*.inp");   
    break;

  case kFFileButton4:
    ActivateFileSelection(widget_num, "*.out");   
    break;

  case kFFileButton5:
    ActivateFileSelection(widget_num, "*.plt");   
    break;

  case kFFileButton6:
    ActivateFileSelection(widget_num, "*.datg");   
    break;

  case kFFileButton7:  
    ActivateFileSelection(widget_num, "*.date");   
    break;

  case kFFileButton8:
    ActivateFileSelection(widget_num, "*.pcks");  
    break;

  case kFFileButton9:
    ActivateFileSelection(widget_num, "*.pckg");  
    break;

  case kFFileButton10: 
    ActivateFileSelection(widget_num, "*.pcke");  
    break;  

  case kFFileButton11: 
    ActivateFileSelection(widget_num, "*.brig");  
    break; 
 
  case kFFileButton12: 
    ActivateFileSelection(widget_num, "p*.pcl");  
    break;    

  case kFFileButton13: 
    ActivateFileSelection(widget_num, "*.pcko");  
    break;   
    
  case kFSaveAsButton: 
    ActivateFileSelection(widget_num, "*.phase");  
    break;       

    /*************************** Edit Pdme *******************************/    
  case kESourceMenuButton:
    FetchWidget(kESourceBox, "ESourceBox");     
    InitSourceBox(&Fg3ActDat, &Beamline, widget_num);  
    XtManageChild(widget_array[kESourceBox]);        
    break;
  case kESRayTraceButton:                        /* Edit- Source- Pdme */
  case kESDipolSourceButton:
  case kESPointSourceButton:
  case kESUndulatorSourceButton:
  case kESundulatorSourceButton:
  case kESUndulatorSISButton:
  case kESUndulatorSIMButton:
  case kESUndulatorButton:
  case kESPhaseSpaceButton:
  case kESFileButton: 
  case kESPhaseSpaceImageButton:
    /* case kESSR1Button:  */                                        
  case kESSR2Button:  
    /*  FetchWidget(kESourceBox, "ESourceBox");    */ 
    initdatset(&Fg3ActDat, &Beamline, widget_num); 
    InitSourceBox(&Fg3ActDat, &Beamline, widget_num);       
    XtManageChild(widget_array[kESourceBox]);        
    break;
   
  case kEParameterButton:
    FetchWidget(kEParameterBox, "EParameterBox");
    /*  printf("PBox opend\n"); i=getchar(); */
    InitParameterBox(&Beamline, NULL);  
    XtManageChild(widget_array[kEParameterBox]);    
    break;  

  case kEParameterInitButton:
    printf("Initialize parameters with fg34.par from J. Bahrdt\n"); 
    if (fexists("fg34.par") == 1)
      {
	/* Sourcefilenames mit ueberbuegeln */
	i= 80; 
	memset(&Beamline.src.so4.fsource4a, 0, i);
	memset(&Beamline.src.so4.fsource4b, 0, i);
	memset(&Beamline.src.so4.fsource4c, 0, i);
	memset(&Beamline.src.so4.fsource4d, 0, i);
	memset(&Beamline.src.so6.fsource6,  0, i);
	readfg34_par(&Beamline.src, &Beamline.BLOptions.apr,
		     &Beamline.BLOptions.ifl, &Beamline.BLOptions.xi,
		     &Beamline.BLOptions.epsilon); 
	strcpy(PHASESet.pssourcename, Beamline.src.so6.fsource6);
	PutPHASE(&PHASESet, MainPickName);  
	Beamline.beamlineOK= 0;
	printf("---> OK\n");
      } else
	printf("fg34.par -- not found\n");
    break;  

  case kEOptiButton:
    FetchWidget(kCCOptiDialog, "CCOptiDialog");  
    InitOptiBox(PHASESet.optipckname, &Beamline);   
    XtManageChild(widget_array[kCCOptiDialog]); 
    break;   

  case kEBLButton:
    FetchWidget(kEBLDialog, "EBLDialog");  
    ReadBLFile(PHASESet.beamlinename, &Beamline); 
    strcpy(PHASESet.pssourcename, Beamline.src.so6.fsource6);
    if ((widget_array[kESourceBox] != NULL) && 
	XtIsRealized(widget_array[kESourceBox])) 
      InitSourceBox(&Fg3ActDat, &Beamline, kESDefaults); 
    InitBLBox(PHASESet.beamlinename, &Beamline);   
    XtManageChild(widget_array[kEBLDialog]); 
    break;   

  case kEOETM:
  case kEOEPM:
  case kEOEPG:
  case kEOEPElliG:
  case kEOEPGV:
  case kEOETG:
  case kEOEVLSG:     
  case kEOEElli:     
  case kEOEPElli: 
  case kEOESlit:
  case kEOEDrift:
  case kEOEGeneral:
  case kEOECone: 
    /*    printf("activate_proc: OEBox PDM: widget_num: %d\n", widget_num);*/
    SetOElementBoxSensitivity(widget_num);
    
    /* last modification: 17 Jun 97 08:49:57 flechsig */
    /* 
    FetchWidget(kEOElement, "EOElementBox");  
    InitOElementBox(&MActDat, &GActDat, widget_num);       
    XtManageChild(widget_array[kEOElement]);
    */ 
    break;

  case kEGeometry: 
    /*    FetchWidget(kEGeometry, "EGeometryBox");  
    InitGeometryBox(&GActDat);   
    XtManageChild(widget_array[kEGeometry]); */
    /* initialisiert die Quellen bei PS */
      start_watch();

      if ((Beamline.src.isrctype == 2) || 
	  (Beamline.src.isrctype == 3) ||
	  (Beamline.src.isrctype == 4) ||
	  (Beamline.src.isrctype == 6))
	{
	  src_ini(&Beamline.src); 
#ifdef DEBUG
	  printf("activate_proc: call src_ini(&Beamline.src)\n");
#endif
	}
      else
	printf("activate_proc: source type %d not supported!\n", 
	       Beamline.src.isrctype);
      stop_watch();
    break;
      
  case kEGT3Button:                                   /* geometry Box */
    printf("call SetTheta\n");
    SetTheta(&Beamline.ElementList[Beamline.position- 1].GDat);     
    break; 

  case kESOK:                                    /* Source Box */ 
    XtUnmanageChild(widget_array[kESourceBox]);
  case kESApply:
    start_watch(); GetSource(&Beamline); 
    Beamline.beamlineOK &= (~resultOK); 
    Beamline.beamlineOK |= sourceOK; 
    stop_watch(); 
    break;  

  case kESDefaults: 
    initdatset(&Fg3ActDat, &Beamline, widget_num);   
    InitSourceBox(&Fg3ActDat, &Beamline, widget_num);      
    break; 

  case kESCancel: 
    XtUnmanageChild(widget_array[kESourceBox]);
    break;     

  case kEOEAB2: 
  case kEOEAB4:                                   /* OElement Box */
    SetRadius(widget_num);     
    xprintf("calculate radius\n");   
    break; 

   case kPreAB: 
   case kSucAB:                                   /* OElement Box */
    CopyLength(widget_num);     
    xprintf("copy contents\n");   
    break; 

   case kEOEOK:                                    /* OElement Box */ 
    XtUnmanageChild(widget_array[kEOElementBox]);
  case kEOEApply:                                 /* 26.6.96 */ 
    bl= &Beamline;   
    if ((bl->position <= bl->elementzahl) && (bl->position != 0)) 
      {
	bl->ElementList[(bl->position)- 1].MDat.Art= 
	i= GetOElement(&PHASESet,	/*  */
		    &bl->ElementList[(bl->position)- 1].MDat,
		    &bl->ElementList[(bl->position)- 1].GDat);  
	printf("activate_proc: returned etype= %d\n" ,i);

      	DefMirrorC(&bl->ElementList[(bl->position)- 1].MDat, 
		   &bl->ElementList[(bl->position)- 1].mir, i,
		   bl->ElementList[(bl->position)- 1].elementname); 
	mputpickfile(&bl->ElementList[(bl->position)- 1].MDat, 
		     PHASESet.elementpckname);
	DefGeometryC(&bl->ElementList[(bl->position)- 1].GDat, 
		     &bl->ElementList[(bl->position)- 1].geo); 
	gputpickfile(&bl->ElementList[(bl->position)- 1].GDat, 
		     PHASESet.geometrypckname);   
	SetDeltaLambda(bl, &bl->ElementList[(bl->position)- 1]);   
                             
	bl->ElementList[(bl->position)- 1].ElementOK |= elementOK;
	bl->ElementList[(bl->position)- 1].ElementOK &= (~mapOK);  
	bl->beamlineOK &= (~mapOK); /* ausschalten */    
      }
    else 
      fprintf(stderr, "activate_proc: no beamline element selected\n");
    UpdateMainList();  
    break;  

  case kEOEDefaults: 
    InitOElementBox(&MDefDat, &GDefDat, widget_num); 
    break; 

  case kEOECancel: 
    XtUnmanageChild(widget_array[kEOElementBox]);
    break;  
        
  case kEGOK:                                    /* Geometry Box */ 
    XtUnmanageChild(widget_array[kEGeometryBox]);    
  case kEGApply: 
    start_watch(); 
    bl= &Beamline;
    if ((bl->position <= bl->elementzahl) && (bl->position != 0)) 
      {
	printf("update geometry\n");
	GetGeometry(&PHASESet, 
		    &bl->ElementList[(bl->position)- 1].GDat);
	DefGeometryC(&bl->ElementList[(bl->position)- 1].GDat, 
		     &bl->ElementList[(bl->position)- 1].geo);  
	gputpickfile(&bl->ElementList[(bl->position)- 1].GDat, 
		     PHASESet.geometrypckname); 
	SetDeltaLambda(bl, &bl->ElementList[(bl->position)- 1]);  
	bl->ElementList[(bl->position)- 1].ElementOK |= geometryOK; 
	bl->ElementList[(bl->position)- 1].ElementOK |= elementOK; 
	bl->ElementList[(bl->position)- 1].ElementOK &= (~mapOK);  
	bl->beamlineOK &= (~mapOK); /* ausschalten */    
      }
    else  
      fprintf(stderr, "activate_proc: no beamline element selected\n");
    UpdateMainList(); 
    stop_watch();  
    break;  

  case kEGDefaults: 
    InitGeometryBox(&GDefDat);    
    break; 

  case kEGCancel: 
    XtUnmanageChild(widget_array[kEGeometryBox]);
    break; 
 
    /* blbox */
  case kEBLNameButton:
    ActivateFileSelection(widget_num, "*.phase"); 
    break;
  case kEBLAdd:
    ActivateFileSelection(widget_num, "*.date"); 
    break;    
  case kEBLDel:                        /* delete Matrix from List */
    DelBLElement(&Beamline);
    break;   

  case kEBLCancel:    
    XtUnmanageChild(widget_array[kEBLDialog]); 
    break; 
  case kEBLOK:    
    XtUnmanageChild(widget_array[kEBLDialog]); 
  case kEBLApply:    
    /* get...*/
    start_watch(); 
    GetBLBox(PHASESet.beamlinename, &Beamline);
    WriteBLFile(PHASESet.beamlinename, &Beamline); 
    BuildBeamline(&Beamline);
    stop_watch(); 
    break; 
  case kEBLAddOK:
 /* modification: 23 Oct 97 08:30:55 flechsig */
 /* modification: 13 Mar 98 08:19:55 flechsig */
    bl= &Beamline; 
    if ((bl->position <= bl->elementzahl) && (bl->position != 0)) 
      {
	GetSlope(&bl->ElementList[(bl->position)- 1]);  
	printf("aperture and slope in dataset\n");
	/* speichern der daten */
	ExpandFileNames(&PHASESet, 
			&bl->ElementList[(bl->position)- 1].elementname);
	mputpickfile(&bl->ElementList[(bl->position)- 1].MDat, 
		     PHASESet.elementpckname); 
	gputpickfile(&bl->ElementList[(bl->position)- 1].GDat,
		     PHASESet.geometrypckname);
	WriteBLFile(PHASESet.beamlinename, bl); 
      }
    else 
      fprintf(stderr, "activate_proc: no beamline element selected\n");
    break;           

    /******************** Commands  Pdme ************************************/

  case kCProductMatrixButton:         /*Multiplikation der Matrix */
    start_watch();  
    FetchWidget(kCCGlueBox,"CCGlueBox");  
    XtManageChild(widget_array[kCCGlueBox]);    
    stop_watch(); 
    break;

  case kCCGOK:                          /* start matrix multiplication */
    start_watch();                        /* Commands Glue Box ok*/
    MultiplyMatrix(); 
    XtUnmanageChild(widget_array[kCCGlueBox]);  
    stop_watch();  
    break;   

  case kCCGResultButton:                /* Product Matrix Button (GBox)*/ 
  case kCCGAdd:                         /* Add Button (GBox) */
    ActivateFileSelection(widget_num, "*.omx");   
    break;  
 
  case kCCGDel:                        /* delete Matrix from List (GBox)*/
    value= XmListGetSelectedPos(widget_array[kCCGList], itemlist, &i);
    if (value == True)  	 {   
      XmListDeletePos(widget_array[kCCGList], **itemlist);   
      XtFree((char *)(*itemlist));      }    
    break;    

  case kCCGCancel:
    XtUnmanageChild(widget_array[kCCGlueBox]);
    break;                                    /* Glue Box end */
        
  case kCMatrixReadButton:                   /* read Matrix from file */
    start_watch();     
              
    bl= &Beamline; 
    printf("activate_proc: read matrix from file: %s\n", 
	   PHASESet.matrixname); 
#ifdef VMS
    CreateFString(&Fname, PHASESet.matrixname);
    readmatrixfile(&Fname, bl->map70, &Beamline.BLOptions.ifl.iord);  
    CreateFString(&Fname, PHASESet.intersecname);  
    /*   readintersection(&Fname, bl->wc, bl->xlc, &iord);       */
#else
    readmatrixfile(PHASESet.matrixname, bl->map70, 
		   &Beamline.BLOptions.ifl.iord, strlen(PHASESet.matrixname));
#endif
    printf("activate_proc: read matrix ende, hardcoded: iord= %d\n", 
	   Beamline.BLOptions.ifl.iord);    
    extractmap(bl->map70, 
	       bl->ypc1, bl->zpc1, bl->dypc, bl->dzpc, 
	       &Beamline.BLOptions.ifl.iord); 
    bl->beamlineOK |= mapOK; 
    stop_watch(); 
    break;      

  case kCCRayTraceButton:                          /*  Ray Trace */  
    start_watch();  
    Beamline.BLOptions.CalcMod= 1;
    Fg3ActDat.imodus= 1; Fg3ActDat.itrans= 0;
    /*    putpickfile(&Fg3ActDat, &Beamline, PHASESet.sourcepckname);  
        sprintf(command,
      "@PHASE$prg:startofor fg3dp_phasep /%s", MainPickName);
      system(command); */  

    if ((Beamline.beamlineOK & (sourceOK | mapOK)) != 
	(sourceOK | mapOK))
      { 
	fprintf(stderr, 
		"act_pr: beamline is not OK: beamlineOK: %X\n", 
		Beamline.beamlineOK); 
	if ((Beamline.beamlineOK & sourceOK) == 0)
	  fprintf(stderr, "source not OK\n");

	/*  exit(-1); */ 
      } else  
	RayTracec(&PHASESet, &Beamline);       
    UpdateMainList();  
    stop_watch();    
    break;  
 
  case kCCPTButton:                              /*  Phase Trafo */  
    start_watch();   
    Beamline.BLOptions.CalcMod= 3;
#ifdef DEBUG
    printf("activate_proc: call PST\n");
#endif
    PST(&Beamline);     
    UpdateMainList();
    stop_watch();    
    break;   

  case kCCMPTButton:                              /*  Phase Trafo */  
    MPST(&Beamline);     
    break;   
     
  case kCCSR1Button:                          /*  footprint */  
    start_watch(); 
    Footprint(&Beamline, Beamline.position);
    stop_watch();    
    break; 
  
  case kCCSR2Button:                          /*  full Ray Trace */  
    start_watch();  
    Beamline.BLOptions.CalcMod= 2;
    if ((Beamline.beamlineOK & (sourceOK | mapOK)) != 
	(sourceOK | mapOK))
      { 
	fprintf(stderr, 
		"act_pr: beamline is not OK: beamlineOK: %X\n", 
		Beamline.beamlineOK); 
	if ((Beamline.beamlineOK & sourceOK) == 0)
	  fprintf(stderr, "source not OK\n");
      } else  
	{
	  printf("full ray trace\n");    
	  RayTraceFull(&Beamline); 
	  printf("full ray trace-> done\n");    
	  Beamline.beamlineOK|= resultOK;
	}
    stop_watch();  
    break;   
        
  case kCCOptiButton: 	                /*  Opti*/  
    sprintf(command,
	    "PHASEopti %s", PHASESet.optipckname);
    system(command); 
    break;  
 
  case kCCExtractButton: 	                /*  Extr*/  
    sprintf(command,
	    "PHASEextract %s", PHASESet.optipckname);
    system(command); 
    break;   

  case kCOptiResultButton: 
    ActivateFileSelection(widget_num, "*.dat");  
    break;

  case kCOptiMinuitButton: 
    ActivateFileSelection(widget_num, "*.inp");  
    break;

  case kCOptiAdd:
    ActivateFileSelection(widget_num, "*.date");  
    break;   

  case kCOptiDel:                 /* delete Matrix from List*/
    value= 
      XmListGetSelectedPos(widget_array[kCOptiList], itemlist, &i);
    if (value == True)
      {   
	XmListDeletePos(widget_array[kCOptiList], **itemlist);   
	XtFree((char *)(*itemlist));  
	topic = XmStringCreateLocalized("select items ");   
	set_something(widget_array[kCOptiSelectedLabel], 
		      XmNlabelString, topic); 
      }    
    break;       
  
  case kCOptiDel1:                 /* delete  from List*/
    value= 
      XmListGetSelectedPos(widget_array[kCOptiList2], itemlist, &i);
    if ((value == True) && (**itemlist > 2))
      {   
	XmListDeletePos(widget_array[kCOptiList2], **itemlist);   
	XtFree((char *)(*itemlist)); 
      }    
    break;       

  case kCOptiOK:                       /* optibox */
    GetOptiBox(&PHASESet);  
  case kCOptiCancel:    
    XtUnmanageChild(widget_array[kCCOptiDialog]); 
    break;
                     
  case kCOptiT1:
  case kCOptiAddOK: 
    /* printf("aktivated\n");   */
    InitOptiList2(-1, NULL);        /*replace */
    break;
   
  case kCOptiAdd1: 
    printf("aktivated\n");	
    InitOptiList2(-2, NULL);        /*Add  */
    break;   

  case kCWriteMapButton: 
    bl= &Beamline;   
    if ((bl->beamlineOK & mapOK) != 0)
      {
	if ((bl->position <= bl->elementzahl) && (bl->position != 0))
	  {
	    printf("write map of element %d to file\n", bl->position);  
	    /* casting 15.12.99 ist noch nicht OK */
	    writemapc(PHASESet.mapname, bl->BLOptions.ifl.iord, 
		      (double *)(bl->ElementList[bl->position- 1].ypc1), 
		      (double *) bl->ElementList[bl->position- 1].zpc1, 
		      (double *) bl->ElementList[bl->position- 1].dypc, 
		      (double *) bl->ElementList[bl->position- 1].dzpc,
		      (double *) bl->ElementList[bl->position- 1].wc, 
		      (double *) bl->ElementList[bl->position- 1].xlc, 
		      (double *) bl->ElementList[bl->position- 1].xlm.xlen1c, 
		      (double *) bl->ElementList[bl->position- 1].xlm.xlen2c);
	  } 
	else
	  {
	    printf("write map of beamline to file\n");         
	    writemapc(PHASESet.mapname, bl->BLOptions.ifl.iord, 
		      (double *) bl->ypc1, (double *) bl->zpc1, 
		      (double *) bl->dypc, (double *) bl->dzpc,
		      (double *) bl->wc,   (double *) bl->xlc, 
		      (double *) bl->xlm.xlen1c, 
		      (double *) bl->xlm.xlen2c);
  
	  }
      } else 
	fprintf(stderr, 
		"activateproc: beamline is not OK: beamlineOK: 0x%X\n", 
		bl->beamlineOK); 
    break;   

  case kCWriteMCoButton: 
    bl= &Beamline;   
     /* \n weggenommen J.B. 10.11.2003 */
    sprintf(buffer,"%s", "mirror-coefficients.dat");
    printf("%s\n", buffer);
    WriteMKos((struct mirrortype *)&bl->ElementList[bl->position- 1].mir, buffer); 
    break;   
    

  case kCWriteResultButton: 
    bl= &Beamline;   
    if ((bl->beamlineOK & resultOK) > 0) 
      {

	/*  WriteRayFile(PHASESet.imageraysname, &bl->RTSource.raynumber, 
	    bl->raysout); */ 
	if ((bl->RESULT.typ & PLphspacetype) > 0)
	  {
#ifdef DEBUG
	    printf("activate_proc: call WritePsd\n");
#endif
	    WritePsd(PHASESet.imageraysname, &bl->RESULT.RESUnion.PSD, 
		     bl->RESULT.RESUnion.PSD.iy, 
		     bl->RESULT.RESUnion.PSD.iz);   
	  }
	else 
	  WriteRayFile(PHASESet.imageraysname, &bl->RESULT.points,
		       bl->RESULT.RESUnion.Rays); 
      } else 
	fprintf(stderr, 
		"activateproc: result is not OK: beamlineOK: 0x%X\n", 
		bl->beamlineOK); 
    break;   

          
    /******************* graphic Box **************************************/
  case kGraphicCommand:                          /* Commands */  
    start_watch();
    FetchWidget(kCGrBox, "CGrafBox"); 
    InitGrafBox(&PHASESet, &grdatstruct);  
    XtManageChild(widget_array[kCGrBox]); 
    xprintf("PHASEgraf started! \n");      
    stop_watch(); 
    break;
  
  case kCGrPSFileButton:
    ActivateFileSelection(widget_num, "*.ps");   
    break;   

  case kCGrOK: 
    XtUnmanageChild(widget_array[kCGrBox]); 
  case kCGrApply:    
    if (GetGrafBox(&PHASESet, &grdatstruct, 
		   Beamline.RESULT.typ) != -1)
      { 
#ifdef DEBUG
	printf("activate_proc: grafic start\n");  
#endif
	vo= SetGrDatStruct(PHASESet.imageraysname, &Beamline,
			   &grdatstruct);
	if ((grdatstruct.status & PLrttype) > 0) 
	  hplotdisplay(&Beamline, &grdatstruct, &PHASESet, 
		       (struct RayType *) vo); 

	if ((grdatstruct.status & PLphspacetype) > 0) /* Phase Space */
	  {
	    if ((grdatstruct.status - PLphspacetype) == 0)
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->psd);
	    if ((grdatstruct.status & PLfd1phmax) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->stfd1phmaxc);
	    if ((grdatstruct.status & PLinumb) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->stinumbc); 
	    if ((grdatstruct.status & PLS1) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->s1c);
	    if ((grdatstruct.status & PLS2) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->s2c);
	    if ((grdatstruct.status & PLS3) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->s3c);
	    if ((grdatstruct.status & PLEyreal) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->eyrec);
	    if ((grdatstruct.status & PLEzreal) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->ezrec);
	    if ((grdatstruct.status & PLEyimag) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->eyimc);
	    if ((grdatstruct.status & PLEzimag) > 0) 
	      hplotpsdc(&Beamline, &grdatstruct, &PHASESet, 
			(struct PSDType *)vo, 
			(double *)((struct PSDType *)vo)->ezimc);

	    if ((grdatstruct.status & PLsimpre) > 0) 
	      hplotpssimc(&Beamline, &grdatstruct, &PHASESet, 
			  (double *)((struct PSDType *)vo)->simpre);
	    if ((grdatstruct.status & PLsimpim) > 0) 
	      hplotpssimc(&Beamline, &grdatstruct, &PHASESet, 
			  (double *)((struct PSDType *)vo)->simpim);
	    if ((grdatstruct.status & PLsintre) > 0) 
	      hplotpssimc(&Beamline, &grdatstruct, &PHASESet, 
			  (double *)((struct PSDType *)vo)->sintre);
	    if ((grdatstruct.status & PLsintim) > 0) 
	      hplotpssimc(&Beamline, &grdatstruct, &PHASESet, 
			  (double *)((struct PSDType *)vo)->sintim);
	    if ((grdatstruct.status & PLsimpam) > 0) 
	      hplotpssimc(&Beamline, &grdatstruct, &PHASESet, 
			  (double *)((struct PSDType *)vo)->simpa);
	    if ((grdatstruct.status & PLsimpph) > 0) 
	      hplotpssimc(&Beamline, &grdatstruct, &PHASESet, 
			  (double *)((struct PSDType *)vo)->simpp);

	  } /* end plotinhaltmenue phasespace */
     }
    break;

  case kCGrDefaults:
    if (GetGrafBox(&PHASESet, &grdatstruct, 
		   Beamline.RESULT.typ) != -1)  /* st. initialisiert */
      {
	vo= SetGrDatStruct(PHASESet.imageraysname, &Beamline, 
			   &grdatstruct);  
	if ((grdatstruct.status & PLrttype) > 0)   
	  AutoScale((struct RayType *)vo, &grdatstruct, &Beamline);  
	else 
	  AutoScalePS((struct PSDType *)vo, &grdatstruct);  

	InitGrafBox(&PHASESet, &grdatstruct);   
      } else printf("error getgrafbox\n");
    break;
	
  case kCGrCancel: 
    XtUnmanageChild(widget_array[kCGrBox]); 
    break;

  case kDirCommand:                            /* Druck */    
    GeneratePrintDataFile(PHASESet.printpclname);
    xprintf("PCL- File generated!");
    break;   
  
  case kCPurge:  
    start_watch();
    sprintf(command,
	    "PHASEusercom %s", PHASESet.printpclname);
    printf("user command: %s\n", command);
    system(command); 
    xprintf("user finished!");
    stop_watch(); 
    break;
  case kSetupInfo:
    FetchWidget(kSetupInfo, "SetupInfo");
#ifdef VMS
	strcpy(buffer, ".lib]news.");
	PrependEnv(PHASE_HOME, buffer);
#else
       sprintf(buffer, "%s/share/phase/news", PREFIX);
#endif 
    
    PrintFileInMainList(buffer);  
    XtManageChild(widget_array[kSetupInfo]);   
    break;

  case k_help_overview:
    topic = XmStringCreateLocalized("overview");   
    create_help(topic);
    XmStringFree(topic);
    break;      
          
  case k_help_about:
    topic = XmStringCreateLocalized("about");   
    create_help(topic);
    XmStringFree(topic);
    break;      
          
  case k_help_onhelp:
    topic = XmStringCreateLocalized("onhelp");
    create_help(topic);          
    XmStringFree(topic);
    break;   
            
  case k_help_sensitive:
    tracking_help(); 
    break;      
                  
  default: 
    break;
  }
}
/* end activate_proc.c */
